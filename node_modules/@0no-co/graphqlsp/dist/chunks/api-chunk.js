var e = require("graphql");

var t = require("crypto");

exports.ts = void 0;

class CharacterStream {
  constructor(e) {
    this._start = 0;
    this._pos = 0;
    this.getStartOfToken = () => this._start;
    this.getCurrentPosition = () => this._pos;
    this.eol = () => this._sourceText.length === this._pos;
    this.sol = () => 0 === this._pos;
    this.peek = () => this._sourceText.charAt(this._pos) || null;
    this.next = () => {
      var e = this._sourceText.charAt(this._pos);
      this._pos++;
      return e;
    };
    this.eat = e => {
      if (this._testNextCharacter(e)) {
        this._start = this._pos;
        this._pos++;
        return this._sourceText.charAt(this._pos - 1);
      }
      return;
    };
    this.eatWhile = e => {
      var t = this._testNextCharacter(e);
      var i = !1;
      if (t) {
        i = t;
        this._start = this._pos;
      }
      while (t) {
        this._pos++;
        t = this._testNextCharacter(e);
        i = !0;
      }
      return i;
    };
    this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
    this.skipToEnd = () => {
      this._pos = this._sourceText.length;
    };
    this.skipTo = e => {
      this._pos = e;
    };
    this.match = (e, t = !0, i = !1) => {
      var r = null;
      var s = null;
      if ("string" == typeof e) {
        s = new RegExp(e, i ? "i" : "g").test(this._sourceText.slice(this._pos, this._pos + e.length));
        r = e;
      } else if (e instanceof RegExp) {
        r = null == (s = this._sourceText.slice(this._pos).match(e)) ? void 0 : s[0];
      }
      if (null != s && ("string" == typeof e || s instanceof Array && this._sourceText.startsWith(s[0], this._pos))) {
        if (t) {
          this._start = this._pos;
          if (r && r.length) {
            this._pos += r.length;
          }
        }
        return s;
      }
      return !1;
    };
    this.backUp = e => {
      this._pos -= e;
    };
    this.column = () => this._pos;
    this.indentation = () => {
      var e = this._sourceText.match(/\s*/);
      var t = 0;
      if (e && 0 !== e.length) {
        var i = e[0];
        var r = 0;
        while (i.length > r) {
          if (9 === i.charCodeAt(r)) {
            t += 2;
          } else {
            t++;
          }
          r++;
        }
      }
      return t;
    };
    this.current = () => this._sourceText.slice(this._start, this._pos);
    this._sourceText = e;
  }
  _testNextCharacter(e) {
    var t = this._sourceText.charAt(this._pos);
    var i = !1;
    if ("string" == typeof e) {
      i = t === e;
    } else {
      i = e instanceof RegExp ? e.test(t) : e(t);
    }
    return i;
  }
}

function opt(e) {
  return {
    ofRule: e
  };
}

function list(e, t) {
  return {
    ofRule: e,
    isList: !0,
    separator: t
  };
}

function t$1(e, t) {
  return {
    style: t,
    match: t => t.kind === e
  };
}

function p$1(e, t) {
  return {
    style: t || "punctuation",
    match: t => "Punctuation" === t.kind && t.value === e
  };
}

var isIgnored = e => " " === e || "\t" === e || "," === e || "\n" === e || "\r" === e || "\ufeff" === e || "Â " === e;

var i = {
  Name: /^[_A-Za-z][_0-9A-Za-z]*/,
  Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
  String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
  Comment: /^#.*/
};

var r = {
  Document: [ list("Definition") ],
  Definition(t) {
    switch (t.value) {
     case "{":
      return "ShortQuery";

     case "query":
      return "Query";

     case "mutation":
      return "Mutation";

     case "subscription":
      return "Subscription";

     case "fragment":
      return e.Kind.FRAGMENT_DEFINITION;

     case "schema":
      return "SchemaDef";

     case "scalar":
      return "ScalarDef";

     case "type":
      return "ObjectTypeDef";

     case "interface":
      return "InterfaceDef";

     case "union":
      return "UnionDef";

     case "enum":
      return "EnumDef";

     case "input":
      return "InputDef";

     case "extend":
      return "ExtendDef";

     case "directive":
      return "DirectiveDef";
    }
  },
  ShortQuery: [ "SelectionSet" ],
  Query: [ word("query"), opt(name$1("def")), opt("VariableDefinitions"), list("Directive"), "SelectionSet" ],
  Mutation: [ word("mutation"), opt(name$1("def")), opt("VariableDefinitions"), list("Directive"), "SelectionSet" ],
  Subscription: [ word("subscription"), opt(name$1("def")), opt("VariableDefinitions"), list("Directive"), "SelectionSet" ],
  VariableDefinitions: [ p$1("("), list("VariableDefinition"), p$1(")") ],
  VariableDefinition: [ "Variable", p$1(":"), "Type", opt("DefaultValue") ],
  Variable: [ p$1("$", "variable"), name$1("variable") ],
  DefaultValue: [ p$1("="), "Value" ],
  SelectionSet: [ p$1("{"), list("Selection"), p$1("}") ],
  Selection: (e, t) => "..." === e.value ? t.match(/[\s\u00a0,]*(on\b|@|{)/, !1) ? "InlineFragment" : "FragmentSpread" : t.match(/[\s\u00a0,]*:/, !1) ? "AliasedField" : "Field",
  AliasedField: [ name$1("property"), p$1(":"), name$1("qualifier"), opt("Arguments"), list("Directive"), opt("SelectionSet") ],
  Field: [ name$1("property"), opt("Arguments"), list("Directive"), opt("SelectionSet") ],
  Arguments: [ p$1("("), list("Argument"), p$1(")") ],
  Argument: [ name$1("attribute"), p$1(":"), "Value" ],
  FragmentSpread: [ p$1("..."), name$1("def"), list("Directive") ],
  InlineFragment: [ p$1("..."), opt("TypeCondition"), list("Directive"), "SelectionSet" ],
  FragmentDefinition: [ word("fragment"), opt(function butNot(e, t) {
    var i = e.match;
    e.match = e => {
      var r = !1;
      if (i) {
        r = i(e);
      }
      return r && t.every((t => t.match && !t.match(e)));
    };
    return e;
  }(name$1("def"), [ word("on") ])), "TypeCondition", list("Directive"), "SelectionSet" ],
  TypeCondition: [ word("on"), "NamedType" ],
  Value(e) {
    switch (e.kind) {
     case "Number":
      return "NumberValue";

     case "String":
      return "StringValue";

     case "Punctuation":
      switch (e.value) {
       case "[":
        return "ListValue";

       case "{":
        return "ObjectValue";

       case "$":
        return "Variable";

       case "&":
        return "NamedType";
      }
      return null;

     case "Name":
      switch (e.value) {
       case "true":
       case "false":
        return "BooleanValue";
      }
      if ("null" === e.value) {
        return "NullValue";
      }
      return "EnumValue";
    }
  },
  NumberValue: [ t$1("Number", "number") ],
  StringValue: [ {
    style: "string",
    match: e => "String" === e.kind,
    update(e, t) {
      if (t.value.startsWith('"""')) {
        e.inBlockstring = !t.value.slice(3).endsWith('"""');
      }
    }
  } ],
  BooleanValue: [ t$1("Name", "builtin") ],
  NullValue: [ t$1("Name", "keyword") ],
  EnumValue: [ name$1("string-2") ],
  ListValue: [ p$1("["), list("Value"), p$1("]") ],
  ObjectValue: [ p$1("{"), list("ObjectField"), p$1("}") ],
  ObjectField: [ name$1("attribute"), p$1(":"), "Value" ],
  Type: e => "[" === e.value ? "ListType" : "NonNullType",
  ListType: [ p$1("["), "Type", p$1("]"), opt(p$1("!")) ],
  NonNullType: [ "NamedType", opt(p$1("!")) ],
  NamedType: [ function type$1(e) {
    return {
      style: e,
      match: e => "Name" === e.kind,
      update(e, t) {
        var i;
        if (null === (i = e.prevState) || void 0 === i ? void 0 : i.prevState) {
          e.name = t.value;
          e.prevState.prevState.type = t.value;
        }
      }
    };
  }("atom") ],
  Directive: [ p$1("@", "meta"), name$1("meta"), opt("Arguments") ],
  DirectiveDef: [ word("directive"), p$1("@", "meta"), name$1("meta"), opt("ArgumentsDef"), word("on"), list("DirectiveLocation", p$1("|")) ],
  InterfaceDef: [ word("interface"), name$1("atom"), opt("Implements"), list("Directive"), p$1("{"), list("FieldDef"), p$1("}") ],
  Implements: [ word("implements"), list("NamedType", p$1("&")) ],
  DirectiveLocation: [ name$1("string-2") ],
  SchemaDef: [ word("schema"), list("Directive"), p$1("{"), list("OperationTypeDef"), p$1("}") ],
  OperationTypeDef: [ name$1("keyword"), p$1(":"), name$1("atom") ],
  ScalarDef: [ word("scalar"), name$1("atom"), list("Directive") ],
  ObjectTypeDef: [ word("type"), name$1("atom"), opt("Implements"), list("Directive"), p$1("{"), list("FieldDef"), p$1("}") ],
  FieldDef: [ name$1("property"), opt("ArgumentsDef"), p$1(":"), "Type", list("Directive") ],
  ArgumentsDef: [ p$1("("), list("InputValueDef"), p$1(")") ],
  InputValueDef: [ name$1("attribute"), p$1(":"), "Type", opt("DefaultValue"), list("Directive") ],
  UnionDef: [ word("union"), name$1("atom"), list("Directive"), p$1("="), list("UnionMember", p$1("|")) ],
  UnionMember: [ "NamedType" ],
  EnumDef: [ word("enum"), name$1("atom"), list("Directive"), p$1("{"), list("EnumValueDef"), p$1("}") ],
  EnumValueDef: [ name$1("string-2"), list("Directive") ],
  InputDef: [ word("input"), name$1("atom"), list("Directive"), p$1("{"), list("InputValueDef"), p$1("}") ],
  ExtendDef: [ word("extend"), "ExtensionDefinition" ],
  ExtensionDefinition(t) {
    switch (t.value) {
     case "schema":
      return e.Kind.SCHEMA_EXTENSION;

     case "scalar":
      return e.Kind.SCALAR_TYPE_EXTENSION;

     case "type":
      return e.Kind.OBJECT_TYPE_EXTENSION;

     case "interface":
      return e.Kind.INTERFACE_TYPE_EXTENSION;

     case "union":
      return e.Kind.UNION_TYPE_EXTENSION;

     case "enum":
      return e.Kind.ENUM_TYPE_EXTENSION;

     case "input":
      return e.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
  },
  [e.Kind.SCHEMA_EXTENSION]: [ "SchemaDef" ],
  [e.Kind.SCALAR_TYPE_EXTENSION]: [ "ScalarDef" ],
  [e.Kind.OBJECT_TYPE_EXTENSION]: [ "ObjectTypeDef" ],
  [e.Kind.INTERFACE_TYPE_EXTENSION]: [ "InterfaceDef" ],
  [e.Kind.UNION_TYPE_EXTENSION]: [ "UnionDef" ],
  [e.Kind.ENUM_TYPE_EXTENSION]: [ "EnumDef" ],
  [e.Kind.INPUT_OBJECT_TYPE_EXTENSION]: [ "InputDef" ]
};

function word(e) {
  return {
    style: "keyword",
    match: t => "Name" === t.kind && t.value === e
  };
}

function name$1(e) {
  return {
    style: e,
    match: e => "Name" === e.kind,
    update(e, t) {
      e.name = t.value;
    }
  };
}

function onlineParser(t = {
  eatWhitespace: e => e.eatWhile(isIgnored),
  lexRules: i,
  parseRules: r,
  editorConfig: {}
}) {
  return {
    startState() {
      var i = {
        level: 0,
        step: 0,
        name: null,
        kind: null,
        type: null,
        rule: null,
        needsSeparator: !1,
        prevState: null
      };
      pushRule(t.parseRules, i, e.Kind.DOCUMENT);
      return i;
    },
    token: (e, i) => function getToken(e, t, i) {
      var r;
      if (t.inBlockstring) {
        if (e.match(/.*"""/)) {
          t.inBlockstring = !1;
          return "string";
        }
        e.skipToEnd();
        return "string";
      }
      var {lexRules: a, parseRules: n, eatWhitespace: o, editorConfig: l} = i;
      if (t.rule && 0 === t.rule.length) {
        popRule(t);
      } else if (t.needsAdvance) {
        t.needsAdvance = !1;
        advanceRule(t, !0);
      }
      if (e.sol()) {
        var u = (null == l ? void 0 : l.tabSize) || 2;
        t.indentLevel = Math.floor(e.indentation() / u);
      }
      if (o(e)) {
        return "ws";
      }
      var h = function lex(e, t) {
        var i = Object.keys(e);
        for (var r = 0; r < i.length; r++) {
          var s = t.match(e[i[r]]);
          if (s && s instanceof Array) {
            return {
              kind: i[r],
              value: s[0]
            };
          }
        }
      }(a, e);
      if (!h) {
        if (!e.match(/\S+/)) {
          e.match(/\s/);
        }
        pushRule(s, t, "Invalid");
        return "invalidchar";
      }
      if ("Comment" === h.kind) {
        pushRule(s, t, "Comment");
        return "comment";
      }
      var p = assign({}, t);
      if ("Punctuation" === h.kind) {
        if (/^[{([]/.test(h.value)) {
          if (void 0 !== t.indentLevel) {
            t.levels = (t.levels || []).concat(t.indentLevel + 1);
          }
        } else if (/^[})\]]/.test(h.value)) {
          var f = t.levels = (t.levels || []).slice(0, -1);
          if (t.indentLevel && f.length > 0 && f.at(-1) < t.indentLevel) {
            t.indentLevel = f.at(-1);
          }
        }
      }
      while (t.rule) {
        var c = "function" == typeof t.rule ? 0 === t.step ? t.rule(h, e) : null : t.rule[t.step];
        if (t.needsSeparator) {
          c = null == c ? void 0 : c.separator;
        }
        if (c) {
          if (c.ofRule) {
            c = c.ofRule;
          }
          if ("string" == typeof c) {
            pushRule(n, t, c);
            continue;
          }
          if (null === (r = c.match) || void 0 === r ? void 0 : r.call(c, h)) {
            if (c.update) {
              c.update(t, h);
            }
            if ("Punctuation" === h.kind) {
              advanceRule(t, !0);
            } else {
              t.needsAdvance = !0;
            }
            return c.style;
          }
        }
        unsuccessful(t);
      }
      assign(t, p);
      pushRule(s, t, "Invalid");
      return "invalidchar";
    }(e, i, t)
  };
}

function assign(e, t) {
  var i = Object.keys(t);
  for (var r = 0; r < i.length; r++) {
    e[i[r]] = t[i[r]];
  }
  return e;
}

var s = {
  Invalid: [],
  Comment: []
};

function pushRule(e, t, i) {
  if (!e[i]) {
    throw new TypeError("Unknown rule: " + i);
  }
  t.prevState = Object.assign({}, t);
  t.kind = i;
  t.name = null;
  t.type = null;
  t.rule = e[i];
  t.step = 0;
  t.needsSeparator = !1;
}

function popRule(e) {
  if (!e.prevState) {
    return;
  }
  e.kind = e.prevState.kind;
  e.name = e.prevState.name;
  e.type = e.prevState.type;
  e.rule = e.prevState.rule;
  e.step = e.prevState.step;
  e.needsSeparator = e.prevState.needsSeparator;
  e.prevState = e.prevState.prevState;
}

function advanceRule(e, t) {
  var i;
  if (isList(e) && e.rule) {
    var r = e.rule[e.step];
    if (r.separator) {
      var {separator: s} = r;
      e.needsSeparator = !e.needsSeparator;
      if (!e.needsSeparator && s.ofRule) {
        return;
      }
    }
    if (t) {
      return;
    }
  }
  e.needsSeparator = !1;
  e.step++;
  while (e.rule && !(Array.isArray(e.rule) && e.step < e.rule.length)) {
    popRule(e);
    if (e.rule) {
      if (isList(e)) {
        if (null === (i = e.rule) || void 0 === i ? void 0 : i[e.step].separator) {
          e.needsSeparator = !e.needsSeparator;
        }
      } else {
        e.needsSeparator = !1;
        e.step++;
      }
    }
  }
}

function isList(e) {
  var t = Array.isArray(e.rule) && "string" != typeof e.rule[e.step] && e.rule[e.step];
  return t && t.isList;
}

function unsuccessful(e) {
  while (e.rule && (!Array.isArray(e.rule) || !e.rule[e.step].ofRule)) {
    popRule(e);
  }
  if (e.rule) {
    advanceRule(e, !1);
  }
}

function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}

class Range {
  constructor(e, t) {
    this.containsPosition = e => {
      if (this.start.line === e.line) {
        return this.start.character <= e.character;
      }
      if (this.end.line === e.line) {
        return this.end.character >= e.character;
      }
      return this.start.line <= e.line && this.end.line >= e.line;
    };
    this.start = e;
    this.end = t;
  }
  setStart(e, t) {
    this.start = new Position(e, t);
  }
  setEnd(e, t) {
    this.end = new Position(e, t);
  }
}

class Position {
  constructor(e, t) {
    this.lessThanOrEqualTo = e => this.line < e.line || this.line === e.line && this.character <= e.character;
    this.line = e;
    this.character = t;
  }
  setLine(e) {
    this.line = e;
  }
  setCharacter(e) {
    this.character = e;
  }
}

var a = [ e.LoneSchemaDefinitionRule, e.UniqueOperationTypesRule, e.UniqueTypeNamesRule, e.UniqueEnumValueNamesRule, e.UniqueFieldDefinitionNamesRule, e.UniqueDirectiveNamesRule, e.KnownTypeNamesRule, e.KnownDirectivesRule, e.UniqueDirectivesPerLocationRule, e.PossibleTypeExtensionsRule, e.UniqueArgumentNamesRule, e.UniqueInputFieldNamesRule ];

var n = {
  ["Error"]: 1,
  ["Warning"]: 2,
  ["Information"]: 3,
  ["Hint"]: 4
};

var invariant = (e, t) => {
  if (!e) {
    throw new Error(t);
  }
};

function getDiagnostics(t, i = null, r, s, o) {
  var l, u;
  var h = null;
  var p = "";
  if (o) {
    p = "string" == typeof o ? o : o.reduce(((t, i) => t + e.print(i) + "\n\n"), "");
  }
  var f = p ? `${t}\n\n${p}` : t;
  try {
    h = e.parse(f);
  } catch (t) {
    if (t instanceof e.GraphQLError) {
      var c = function getRange(e, t) {
        var i = onlineParser();
        var r = i.startState();
        var s = t.split("\n");
        invariant(s.length >= e.line, "Query text must have more lines than where the error happened");
        var a = null;
        for (var n = 0; n < e.line; n++) {
          a = new CharacterStream(s[n]);
          while (!a.eol()) {
            if ("invalidchar" === i.token(a, r)) {
              break;
            }
          }
        }
        invariant(a, "Expected Parser stream to be available.");
        var o = e.line - 1;
        var l = a.getStartOfToken();
        var u = a.getCurrentPosition();
        return new Range(new Position(o, l), new Position(o, u));
      }(null !== (u = null === (l = t.locations) || void 0 === l ? void 0 : l[0]) && void 0 !== u ? u : {
        line: 0,
        column: 0
      }, f);
      return [ {
        severity: n.Error,
        message: t.message,
        source: "GraphQL: Syntax",
        range: c
      } ];
    }
    throw t;
  }
  return function validateQuery(t, i = null, r, s) {
    if (!i) {
      return [];
    }
    var o = function validateWithCustomRules(t, i, r, s, n) {
      var o = e.specifiedRules.filter((t => {
        if (t === e.NoUnusedFragmentsRule || t === e.ExecutableDefinitionsRule) {
          return !1;
        }
        if (s && t === e.KnownFragmentNamesRule) {
          return !1;
        }
        return !0;
      }));
      if (r) {
        Array.prototype.push.apply(o, r);
      }
      if (n) {
        Array.prototype.push.apply(o, a);
      }
      return e.validate(t, i, o).filter((t => {
        if (t.message.includes("Unknown directive") && t.nodes) {
          var i = t.nodes[0];
          if (i && i.kind === e.Kind.DIRECTIVE) {
            var r = i.name.value;
            if ("arguments" === r || "argumentDefinitions" === r) {
              return !1;
            }
          }
        }
        return !0;
      }));
    }(i, t, r, s).flatMap((e => annotations(e, n.Error, "Validation")));
    var l = e.validate(i, t, [ e.NoDeprecatedCustomRule ]).flatMap((e => annotations(e, n.Warning, "Deprecation")));
    return o.concat(l);
  }(h, i, r, s);
}

function annotations(e, t, i) {
  if (!e.nodes) {
    return [];
  }
  var r = [];
  for (var [s, a] of e.nodes.entries()) {
    var n = "Variable" !== a.kind && "name" in a && void 0 !== a.name ? a.name : "variable" in a && void 0 !== a.variable ? a.variable : a;
    if (n) {
      invariant(e.locations, "GraphQL validation error requires locations.");
      var o = e.locations[s];
      var l = getLocation(n);
      var u = o.column + (l.end - l.start);
      r.push({
        source: `GraphQL: ${i}`,
        message: e.message,
        severity: t,
        range: new Range(new Position(o.line - 1, o.column - 1), new Position(o.line - 1, u))
      });
    }
  }
  return r;
}

function getLocation(e) {
  var t = e.loc;
  invariant(t, "Expected ASTNode to have a location.");
  return t;
}

class GraphQLError extends Error {
  constructor(e, t, i, r, s, a, n) {
    super(e);
    this.name = "GraphQLError";
    this.message = e;
    if (s) {
      this.path = s;
    }
    if (t) {
      this.nodes = Array.isArray(t) ? t : [ t ];
    }
    if (i) {
      this.source = i;
    }
    if (r) {
      this.positions = r;
    }
    if (a) {
      this.originalError = a;
    }
    var o = n;
    if (!o && a) {
      var l = a.extensions;
      if (l && "object" == typeof l) {
        o = l;
      }
    }
    this.extensions = o || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
}

var o;

var l;

function error(e) {
  return new GraphQLError(`Syntax Error: Unexpected token at ${l} in ${e}`);
}

function advance(e) {
  e.lastIndex = l;
  if (e.test(o)) {
    return o.slice(l, l = e.lastIndex);
  }
}

var u = / +(?=[^\s])/y;

function blockString(e) {
  var t = e.split("\n");
  var i = "";
  var r = 0;
  var s = 0;
  var a = t.length - 1;
  for (var n = 0; n < t.length; n++) {
    u.lastIndex = 0;
    if (u.test(t[n])) {
      if (n && (!r || u.lastIndex < r)) {
        r = u.lastIndex;
      }
      s = s || n;
      a = n;
    }
  }
  for (var o = s; o <= a; o++) {
    if (o !== s) {
      i += "\n";
    }
    i += t[o].slice(r).replace(/\\"""/g, '"""');
  }
  return i;
}

function ignored() {
  for (var e = 0 | o.charCodeAt(l++); 9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e; e = 0 | o.charCodeAt(l++)) {
    if (35 === e) {
      while (10 !== (e = o.charCodeAt(l++)) && 13 !== e) {}
    }
  }
  l--;
}

var h = /[_A-Za-z]\w*/y;

function name() {
  var e;
  if (e = advance(h)) {
    return {
      kind: "Name",
      value: e
    };
  }
}

var p = /(?:null|true|false)/y;

var f = /\$[_A-Za-z]\w*/y;

var c = /-?\d+/y;

var d = /(?:\.\d+)?[eE][+-]?\d+|\.\d+/y;

var v = /\\/g;

var g = /"""(?:"""|(?:[\s\S]*?[^\\])""")/y;

var m = /"(?:"|[^\r\n]*?[^\\]")/y;

function value(e) {
  var t;
  var i;
  if (i = advance(p)) {
    t = "null" === i ? {
      kind: "NullValue"
    } : {
      kind: "BooleanValue",
      value: "true" === i
    };
  } else if (!e && (i = advance(f))) {
    t = {
      kind: "Variable",
      name: {
        kind: "Name",
        value: i.slice(1)
      }
    };
  } else if (i = advance(c)) {
    var r = i;
    if (i = advance(d)) {
      t = {
        kind: "FloatValue",
        value: r + i
      };
    } else {
      t = {
        kind: "IntValue",
        value: r
      };
    }
  } else if (i = advance(h)) {
    t = {
      kind: "EnumValue",
      value: i
    };
  } else if (i = advance(g)) {
    t = {
      kind: "StringValue",
      value: blockString(i.slice(3, -3)),
      block: !0
    };
  } else if (i = advance(m)) {
    t = {
      kind: "StringValue",
      value: v.test(i) ? JSON.parse(i) : i.slice(1, -1),
      block: !1
    };
  } else if (t = function list(e) {
    var t;
    if (91 === o.charCodeAt(l)) {
      l++;
      ignored();
      var i = [];
      while (t = value(e)) {
        i.push(t);
      }
      if (93 !== o.charCodeAt(l++)) {
        throw error("ListValue");
      }
      ignored();
      return {
        kind: "ListValue",
        values: i
      };
    }
  }(e) || function object(e) {
    if (123 === o.charCodeAt(l)) {
      l++;
      ignored();
      var t = [];
      var i;
      while (i = name()) {
        ignored();
        if (58 !== o.charCodeAt(l++)) {
          throw error("ObjectField");
        }
        ignored();
        var r = value(e);
        if (!r) {
          throw error("ObjectField");
        }
        t.push({
          kind: "ObjectField",
          name: i,
          value: r
        });
      }
      if (125 !== o.charCodeAt(l++)) {
        throw error("ObjectValue");
      }
      ignored();
      return {
        kind: "ObjectValue",
        fields: t
      };
    }
  }(e)) {
    return t;
  }
  ignored();
  return t;
}

function arguments_(e) {
  var t = [];
  ignored();
  if (40 === o.charCodeAt(l)) {
    l++;
    ignored();
    var i;
    while (i = name()) {
      ignored();
      if (58 !== o.charCodeAt(l++)) {
        throw error("Argument");
      }
      ignored();
      var r = value(e);
      if (!r) {
        throw error("Argument");
      }
      t.push({
        kind: "Argument",
        name: i,
        value: r
      });
    }
    if (!t.length || 41 !== o.charCodeAt(l++)) {
      throw error("Argument");
    }
    ignored();
  }
  return t;
}

function directives(e) {
  var t = [];
  ignored();
  while (64 === o.charCodeAt(l)) {
    l++;
    var i = name();
    if (!i) {
      throw error("Directive");
    }
    ignored();
    t.push({
      kind: "Directive",
      name: i,
      arguments: arguments_(e)
    });
  }
  return t;
}

function field() {
  var e = name();
  if (e) {
    ignored();
    var t;
    if (58 === o.charCodeAt(l)) {
      l++;
      ignored();
      t = e;
      if (!(e = name())) {
        throw error("Field");
      }
      ignored();
    }
    return {
      kind: "Field",
      alias: t,
      name: e,
      arguments: arguments_(!1),
      directives: directives(!1),
      selectionSet: selectionSet()
    };
  }
}

function type() {
  var e;
  ignored();
  if (91 === o.charCodeAt(l)) {
    l++;
    ignored();
    var t = type();
    if (!t || 93 !== o.charCodeAt(l++)) {
      throw error("ListType");
    }
    e = {
      kind: "ListType",
      type: t
    };
  } else if (e = name()) {
    e = {
      kind: "NamedType",
      name: e
    };
  } else {
    throw error("NamedType");
  }
  ignored();
  if (33 === o.charCodeAt(l)) {
    l++;
    ignored();
    return {
      kind: "NonNullType",
      type: e
    };
  } else {
    return e;
  }
}

var x = /on/y;

function typeCondition() {
  if (advance(x)) {
    ignored();
    var e = name();
    if (!e) {
      throw error("NamedType");
    }
    ignored();
    return {
      kind: "NamedType",
      name: e
    };
  }
}

var S = /\.\.\./y;

function fragmentSpread() {
  if (advance(S)) {
    ignored();
    var e = l;
    var t;
    if ((t = name()) && "on" !== t.value) {
      return {
        kind: "FragmentSpread",
        name: t,
        directives: directives(!1)
      };
    } else {
      l = e;
      var i = typeCondition();
      var r = directives(!1);
      var s = selectionSet();
      if (!s) {
        throw error("InlineFragment");
      }
      return {
        kind: "InlineFragment",
        typeCondition: i,
        directives: r,
        selectionSet: s
      };
    }
  }
}

function selectionSet() {
  var e;
  ignored();
  if (123 === o.charCodeAt(l)) {
    l++;
    ignored();
    var t = [];
    while (e = fragmentSpread() || field()) {
      t.push(e);
    }
    if (!t.length || 125 !== o.charCodeAt(l++)) {
      throw error("SelectionSet");
    }
    ignored();
    return {
      kind: "SelectionSet",
      selections: t
    };
  }
}

var y = /fragment/y;

function fragmentDefinition() {
  if (advance(y)) {
    ignored();
    var e = name();
    if (!e) {
      throw error("FragmentDefinition");
    }
    ignored();
    var t = typeCondition();
    if (!t) {
      throw error("FragmentDefinition");
    }
    var i = directives(!1);
    var r = selectionSet();
    if (!r) {
      throw error("FragmentDefinition");
    }
    return {
      kind: "FragmentDefinition",
      name: e,
      typeCondition: t,
      directives: i,
      selectionSet: r
    };
  }
}

var T = /(?:query|mutation|subscription)/y;

function operationDefinition() {
  var e;
  var t;
  var i = [];
  var r = [];
  if (e = advance(T)) {
    ignored();
    t = name();
    i = function variableDefinitions() {
      var e;
      var t = [];
      ignored();
      if (40 === o.charCodeAt(l)) {
        l++;
        ignored();
        while (e = advance(f)) {
          ignored();
          if (58 !== o.charCodeAt(l++)) {
            throw error("VariableDefinition");
          }
          var i = type();
          var r = void 0;
          if (61 === o.charCodeAt(l)) {
            l++;
            ignored();
            if (!(r = value(!0))) {
              throw error("VariableDefinition");
            }
          }
          ignored();
          t.push({
            kind: "VariableDefinition",
            variable: {
              kind: "Variable",
              name: {
                kind: "Name",
                value: e.slice(1)
              }
            },
            type: i,
            defaultValue: r,
            directives: directives(!0)
          });
        }
        if (41 !== o.charCodeAt(l++)) {
          throw error("VariableDefinition");
        }
        ignored();
      }
      return t;
    }();
    r = directives(!1);
  }
  var s = selectionSet();
  if (s) {
    return {
      kind: "OperationDefinition",
      operation: e || "query",
      name: t,
      variableDefinitions: i,
      directives: r,
      selectionSet: s
    };
  }
}

var E = {};

var hasItems = e => !(!e || !e.length);

var b = {
  OperationDefinition(e) {
    if ("query" === e.operation && !e.name && !hasItems(e.variableDefinitions) && !hasItems(e.directives)) {
      return b.SelectionSet(e.selectionSet);
    }
    var t = e.operation;
    if (e.name) {
      t += " " + e.name.value;
    }
    if (hasItems(e.variableDefinitions)) {
      if (!e.name) {
        t += " ";
      }
      t += "(" + e.variableDefinitions.map(b.VariableDefinition).join(", ") + ")";
    }
    if (hasItems(e.directives)) {
      t += " " + e.directives.map(b.Directive).join(" ");
    }
    return t + " " + b.SelectionSet(e.selectionSet);
  },
  VariableDefinition(e) {
    var t = b.Variable(e.variable) + ": " + print(e.type);
    if (e.defaultValue) {
      t += " = " + print(e.defaultValue);
    }
    if (hasItems(e.directives)) {
      t += " " + e.directives.map(b.Directive).join(" ");
    }
    return t;
  },
  Field(e) {
    var t = (e.alias ? e.alias.value + ": " : "") + e.name.value;
    if (hasItems(e.arguments)) {
      var i = e.arguments.map(b.Argument);
      var r = t + "(" + i.join(", ") + ")";
      t = r.length > 80 ? t + "(\n  " + i.join("\n").replace(/\n/g, "\n  ") + "\n)" : r;
    }
    if (hasItems(e.directives)) {
      t += " " + e.directives.map(b.Directive).join(" ");
    }
    return e.selectionSet ? t + " " + b.SelectionSet(e.selectionSet) : t;
  },
  StringValue: e => e.block ? function printBlockString(e) {
    return '"""\n' + e.replace(/"""/g, '\\"""') + '\n"""';
  }(e.value) : function printString(e) {
    return JSON.stringify(e);
  }(e.value),
  BooleanValue: e => "" + e.value,
  NullValue: e => "null",
  IntValue: e => e.value,
  FloatValue: e => e.value,
  EnumValue: e => e.value,
  Name: e => e.value,
  Variable: e => "$" + e.name.value,
  ListValue: e => "[" + e.values.map(print).join(", ") + "]",
  ObjectValue: e => "{" + e.fields.map(b.ObjectField).join(", ") + "}",
  ObjectField: e => e.name.value + ": " + print(e.value),
  Document: e => hasItems(e.definitions) ? e.definitions.map(print).join("\n\n") : "",
  SelectionSet: e => "{\n  " + e.selections.map(print).join("\n").replace(/\n/g, "\n  ") + "\n}",
  Argument: e => e.name.value + ": " + print(e.value),
  FragmentSpread(e) {
    var t = "..." + e.name.value;
    if (hasItems(e.directives)) {
      t += " " + e.directives.map(b.Directive).join(" ");
    }
    return t;
  },
  InlineFragment(e) {
    var t = "...";
    if (e.typeCondition) {
      t += " on " + e.typeCondition.name.value;
    }
    if (hasItems(e.directives)) {
      t += " " + e.directives.map(b.Directive).join(" ");
    }
    return t + " " + print(e.selectionSet);
  },
  FragmentDefinition(e) {
    var t = "fragment " + e.name.value;
    t += " on " + e.typeCondition.name.value;
    if (hasItems(e.directives)) {
      t += " " + e.directives.map(b.Directive).join(" ");
    }
    return t + " " + print(e.selectionSet);
  },
  Directive(e) {
    var t = "@" + e.name.value;
    if (hasItems(e.arguments)) {
      t += "(" + e.arguments.map(b.Argument).join(", ") + ")";
    }
    return t;
  },
  NamedType: e => e.name.value,
  ListType: e => "[" + print(e.type) + "]",
  NonNullType: e => print(e.type) + "!"
};

function print(e) {
  return b[e.kind] ? b[e.kind](e) : "";
}

var A = new Set([ "gql", "graphql" ]);

function getSource(e, t) {
  var i = e.languageService.getProgram();
  if (!i) {
    return;
  }
  var r = i.getSourceFile(t);
  if (!r) {
    return;
  }
  return r;
}

function findNode(e, t) {
  return function find(e) {
    if (t >= e.getStart() && t < e.getEnd()) {
      return exports.ts.forEachChild(e, find) || e;
    }
  }(e);
}

function unrollFragment(t, i) {
  var r = [];
  var s = i.languageService.getDefinitionAtPosition(t.getSourceFile().fileName, t.getStart());
  if (!s || !s.length) {
    return r;
  }
  var [a] = s;
  var n = getSource(i, a.fileName);
  if (!n) {
    return r;
  }
  var o = findNode(n, a.textSpan.start);
  if (!o) {
    return r;
  }
  if (exports.ts.isVariableDeclaration(o.parent) && o.parent.initializer && exports.ts.isCallExpression(o.parent.initializer)) {
    o = o.parent.initializer;
  } else if (exports.ts.isPropertyAssignment(o.parent)) {
    o = o.parent.initializer;
  }
  if (exports.ts.isCallExpression(o) && A.has(o.expression.getText())) {
    var [l, u] = o.arguments;
    if (u && exports.ts.isArrayLiteralExpression(u)) {
      u.elements.forEach((e => {
        if (exports.ts.isIdentifier(e)) {
          r.push(...unrollFragment(e, i));
        }
      }));
    }
    try {
      e.parse(l.getText().slice(1, -1), {
        noLocation: !0
      }).definitions.forEach((e => {
        if ("FragmentDefinition" === e.kind) {
          r.push(e);
        }
      }));
    } catch (e) {}
  }
  return r;
}

function findAllCallExpressions(e, t, i = !0) {
  var r = [];
  var s = [];
  var a = i ? !1 : !0;
  !function find(i) {
    if (exports.ts.isCallExpression(i) && A.has(i.expression.getText())) {
      var [n, o] = i.arguments;
      if (!a && !o) {
        a = !0;
        s.push(...getAllFragments(e.fileName, i, t));
      } else if (o && exports.ts.isArrayLiteralExpression(o)) {
        o.elements.forEach((e => {
          if (exports.ts.isIdentifier(e)) {
            s.push(...unrollFragment(e, t));
          } else if (exports.ts.isPropertyAccessExpression(e)) {
            var i = e;
            while (exports.ts.isPropertyAccessExpression(i.expression)) {
              i = i.expression;
            }
            if (exports.ts.isIdentifier(i.name)) {
              s.push(...unrollFragment(i.name, t));
            }
          }
        }));
      }
      if (n && exports.ts.isNoSubstitutionTemplateLiteral(n)) {
        r.push(n);
      }
      return;
    } else {
      exports.ts.forEachChild(i, find);
    }
  }(e);
  return {
    nodes: r,
    fragments: s
  };
}

function findAllPersistedCallExpressions(e) {
  var t = [];
  !function find(e) {
    if (exports.ts.isCallExpression(e)) {
      var i = e.expression.getText().split(".");
      if (2 !== i.length) {
        return;
      }
      var [r, s] = i;
      if (!A.has(r) || "persisted" !== s) {
        return;
      }
      t.push(e);
    } else {
      exports.ts.forEachChild(e, find);
    }
  }(e);
  return t;
}

function getAllFragments(t, i, r) {
  var s = [];
  var a = r.languageService.getDefinitionAtPosition(t, i.expression.getStart());
  if (!a || !a.length) {
    return s;
  }
  if (i.arguments[1] && exports.ts.isArrayLiteralExpression(i.arguments[1])) {
    i.arguments[1].elements.forEach((e => {
      if (exports.ts.isIdentifier(e)) {
        s.push(...unrollFragment(e, r));
      }
    }));
    return s;
  }
  var n = a[0];
  if (!n) {
    return s;
  }
  var o = getSource(r, n.fileName);
  if (!o) {
    return s;
  }
  exports.ts.forEachChild(o, (t => {
    if (exports.ts.isVariableStatement(t) && t.declarationList && "documents" === t.declarationList.declarations[0].name.getText()) {
      var [i] = t.declarationList.declarations;
      if (i.initializer && exports.ts.isObjectLiteralExpression(i.initializer)) {
        i.initializer.properties.forEach((t => {
          if (exports.ts.isPropertyAssignment(t) && exports.ts.isStringLiteral(t.name)) {
            try {
              var i = JSON.parse(`${t.name.getText().replace(/'/g, '"')}`);
              if (i.includes("fragment ") && i.includes(" on ")) {
                e.parse(i, {
                  noLocation: !0
                }).definitions.forEach((e => {
                  if ("FragmentDefinition" === e.kind) {
                    s.push(e);
                  }
                }));
              }
            } catch (e) {}
          }
        }));
      }
    }
  }));
  return s;
}

function resolveTemplate(e, t, i) {
  if (exports.ts.isNoSubstitutionTemplateLiteral(e)) {
    return {
      combinedText: e.getText().slice(1, -1),
      resolvedSpans: []
    };
  }
  var r = e.template.getText().slice(1, -1);
  if (exports.ts.isNoSubstitutionTemplateLiteral(e.template) || 0 === e.template.templateSpans.length) {
    return {
      combinedText: r,
      resolvedSpans: []
    };
  }
  var s = 0;
  var a = e.template.templateSpans.map((e => {
    if (exports.ts.isIdentifier(e.expression)) {
      var a = i.languageService.getDefinitionAtPosition(t, e.expression.getStart());
      if (!a || !a.length) {
        return;
      }
      var n = a[0];
      var o = getSource(i, n.fileName);
      if (!o) {
        return;
      }
      var l = findNode(o, n.textSpan.start);
      if (!l || !l.parent) {
        return;
      }
      var u = l.parent;
      if (exports.ts.isVariableDeclaration(u)) {
        var h = e.expression.escapedText;
        var p = e.expression.getStart() - 2;
        var f = {
          start: p,
          length: e.expression.end - p + 1
        };
        if (u.initializer && exports.ts.isTaggedTemplateExpression(u.initializer)) {
          var c = resolveTemplate(u.initializer, n.fileName, i);
          r = r.replace("${" + e.expression.escapedText + "}", c.combinedText);
          var d = {
            lines: c.combinedText.split("\n").length,
            identifier: h,
            original: f,
            new: {
              start: f.start + s,
              length: c.combinedText.length
            }
          };
          s += c.combinedText.length - f.length;
          return d;
        } else if (u.initializer && exports.ts.isAsExpression(u.initializer) && exports.ts.isTaggedTemplateExpression(u.initializer.expression)) {
          var v = resolveTemplate(u.initializer.expression, n.fileName, i);
          r = r.replace("${" + e.expression.escapedText + "}", v.combinedText);
          var g = {
            lines: v.combinedText.split("\n").length,
            identifier: h,
            original: f,
            new: {
              start: f.start + s,
              length: v.combinedText.length
            }
          };
          s += v.combinedText.length - f.length;
          return g;
        } else if (u.initializer && exports.ts.isAsExpression(u.initializer) && exports.ts.isAsExpression(u.initializer.expression) && exports.ts.isObjectLiteralExpression(u.initializer.expression.expression)) {
          var m = print(JSON.parse(u.initializer.expression.expression.getText()));
          r = r.replace("${" + e.expression.escapedText + "}", m);
          var x = {
            lines: m.split("\n").length,
            identifier: h,
            original: f,
            new: {
              start: f.start + s,
              length: m.length
            }
          };
          s += m.length - f.length;
          return x;
        }
        return;
      }
    }
    return;
  })).filter(Boolean);
  return {
    combinedText: r,
    resolvedSpans: a
  };
}

var w = "object" == typeof performance && performance && "function" == typeof performance.now ? performance : Date;

var D = new Set;

var k = "object" == typeof process && process ? process : {};

var emitWarning = (e, t, i, r) => {
  "function" == typeof k.emitWarning ? k.emitWarning(e, t, i, r) : console.error(`[${i}] ${t}: ${e}`);
};

var N = globalThis.AbortController;

var _ = globalThis.AbortSignal;

if (void 0 === N) {
  _ = class AbortSignal {
    _onabort=[];
    aborted=!1;
    addEventListener(e, t) {
      this._onabort.push(t);
    }
  };
  N = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal=new _;
    abort(e) {
      if (this.signal.aborted) {
        return;
      }
      this.signal.reason = e;
      this.signal.aborted = !0;
      for (var t of this.signal._onabort) {
        t(e);
      }
      this.signal.onabort?.(e);
    }
  };
  var F = "1" !== k.env?.LRU_CACHE_IGNORE_AC_WARNING;
  var warnACPolyfill = () => {
    if (!F) {
      return;
    }
    F = !1;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}

var isPosInt = e => e && e === Math.floor(e) && e > 0 && isFinite(e);

var getUintArray = e => !isPosInt(e) ? null : e <= Math.pow(2, 8) ? Uint8Array : e <= Math.pow(2, 16) ? Uint16Array : e <= Math.pow(2, 32) ? Uint32Array : e <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(e) {
    super(e);
    this.fill(0);
  }
}

class Stack {
  static #e=!1;
  static create(e) {
    var t = getUintArray(e);
    if (!t) {
      return [];
    }
    Stack.#e = !0;
    var i = new Stack(e, t);
    Stack.#e = !1;
    return i;
  }
  constructor(e, t) {
    if (!Stack.#e) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new t(e);
    this.length = 0;
  }
  push(e) {
    this.heap[this.length++] = e;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #t;
  #i;
  #r;
  #s;
  #a;
  #n;
  #o;
  #l;
  #u;
  #h;
  #p;
  #f;
  #c;
  #d;
  #v;
  #g;
  #m;
  #x;
  #S;
  #y;
  #T;
  #E;
  static unsafeExposeInternals(e) {
    return {
      starts: e.#x,
      ttls: e.#S,
      sizes: e.#m,
      keyMap: e.#l,
      keyList: e.#u,
      valList: e.#h,
      next: e.#p,
      prev: e.#f,
      get head() {
        return e.#c;
      },
      get tail() {
        return e.#d;
      },
      free: e.#v,
      isBackgroundFetch: t => e.#b(t),
      backgroundFetch: (t, i, r, s) => e.#A(t, i, r, s),
      moveToTail: t => e.#w(t),
      indexes: t => e.#D(t),
      rindexes: t => e.#k(t),
      isStale: t => e.#N(t)
    };
  }
  get max() {
    return this.#t;
  }
  get maxSize() {
    return this.#i;
  }
  get calculatedSize() {
    return this.#o;
  }
  get size() {
    return this.#n;
  }
  get fetchMethod() {
    return this.#a;
  }
  get dispose() {
    return this.#r;
  }
  get disposeAfter() {
    return this.#s;
  }
  constructor(e) {
    var {max: t = 0, ttl: i, ttlResolution: r = 1, ttlAutopurge: s, updateAgeOnGet: a, updateAgeOnHas: n, allowStale: o, dispose: l, disposeAfter: u, noDisposeOnSet: h, noUpdateTTL: p, maxSize: f = 0, maxEntrySize: c = 0, sizeCalculation: d, fetchMethod: v, noDeleteOnFetchRejection: g, noDeleteOnStaleGet: m, allowStaleOnFetchRejection: x, allowStaleOnFetchAbort: S, ignoreFetchAbort: y} = e;
    if (0 !== t && !isPosInt(t)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    var T = t ? getUintArray(t) : Array;
    if (!T) {
      throw new Error("invalid max value: " + t);
    }
    this.#t = t;
    this.#i = f;
    this.maxEntrySize = c || this.#i;
    this.sizeCalculation = d;
    if (this.sizeCalculation) {
      if (!this.#i && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if ("function" != typeof this.sizeCalculation) {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (void 0 !== v && "function" != typeof v) {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#a = v;
    this.#T = !!v;
    this.#l = new Map;
    this.#u = new Array(t).fill(void 0);
    this.#h = new Array(t).fill(void 0);
    this.#p = new T(t);
    this.#f = new T(t);
    this.#c = 0;
    this.#d = 0;
    this.#v = Stack.create(t);
    this.#n = 0;
    this.#o = 0;
    if ("function" == typeof l) {
      this.#r = l;
    }
    if ("function" == typeof u) {
      this.#s = u;
      this.#g = [];
    } else {
      this.#s = void 0;
      this.#g = void 0;
    }
    this.#y = !!this.#r;
    this.#E = !!this.#s;
    this.noDisposeOnSet = !!h;
    this.noUpdateTTL = !!p;
    this.noDeleteOnFetchRejection = !!g;
    this.allowStaleOnFetchRejection = !!x;
    this.allowStaleOnFetchAbort = !!S;
    this.ignoreFetchAbort = !!y;
    if (0 !== this.maxEntrySize) {
      if (0 !== this.#i) {
        if (!isPosInt(this.#i)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#_();
    }
    this.allowStale = !!o;
    this.noDeleteOnStaleGet = !!m;
    this.updateAgeOnGet = !!a;
    this.updateAgeOnHas = !!n;
    this.ttlResolution = isPosInt(r) || 0 === r ? r : 1;
    this.ttlAutopurge = !!s;
    this.ttl = i || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#F();
    }
    if (0 === this.#t && 0 === this.ttl && 0 === this.#i) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#t && !this.#i) {
      var E = "LRU_CACHE_UNBOUNDED";
      if ((e => !D.has(e))(E)) {
        D.add(E);
        emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", E, LRUCache);
      }
    }
  }
  getRemainingTTL(e) {
    return this.#l.has(e) ? 1 / 0 : 0;
  }
  #F() {
    var e = new ZeroArray(this.#t);
    var t = new ZeroArray(this.#t);
    this.#S = e;
    this.#x = t;
    this.#L = (i, r, s = w.now()) => {
      t[i] = 0 !== r ? s : 0;
      e[i] = r;
      if (0 !== r && this.ttlAutopurge) {
        var a = setTimeout((() => {
          if (this.#N(i)) {
            this.delete(this.#u[i]);
          }
        }), r + 1);
        if (a.unref) {
          a.unref();
        }
      }
    };
    this.#C = i => {
      t[i] = 0 !== e[i] ? w.now() : 0;
    };
    this.#z = (r, s) => {
      if (e[s]) {
        var a = e[s];
        var n = t[s];
        r.ttl = a;
        r.start = n;
        r.now = i || getNow();
        r.remainingTTL = a - (r.now - n);
      }
    };
    var i = 0;
    var getNow = () => {
      var e = w.now();
      if (this.ttlResolution > 0) {
        i = e;
        var t = setTimeout((() => i = 0), this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return e;
    };
    this.getRemainingTTL = r => {
      var s = this.#l.get(r);
      if (void 0 === s) {
        return 0;
      }
      var a = e[s];
      var n = t[s];
      if (0 === a || 0 === n) {
        return 1 / 0;
      }
      return a - ((i || getNow()) - n);
    };
    this.#N = r => 0 !== e[r] && 0 !== t[r] && (i || getNow()) - t[r] > e[r];
  }
  #C=() => {};
  #z=() => {};
  #L=() => {};
  #N=() => !1;
  #_() {
    var e = new ZeroArray(this.#t);
    this.#o = 0;
    this.#m = e;
    this.#I = t => {
      this.#o -= e[t];
      e[t] = 0;
    };
    this.#O = (e, t, i, r) => {
      if (this.#b(t)) {
        return 0;
      }
      if (!isPosInt(i)) {
        if (r) {
          if ("function" != typeof r) {
            throw new TypeError("sizeCalculation must be a function");
          }
          i = r(t, e);
          if (!isPosInt(i)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return i;
    };
    this.#R = (t, i, r) => {
      e[t] = i;
      if (this.#i) {
        var s = this.#i - e[t];
        while (this.#o > s) {
          this.#$(!0);
        }
      }
      this.#o += e[t];
      if (r) {
        r.entrySize = i;
        r.totalCalculatedSize = this.#o;
      }
    };
  }
  #I=e => {};
  #R=(e, t, i) => {};
  #O=(e, t, i, r) => {
    if (i || r) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  * #D({allowStale: e = this.allowStale} = {}) {
    if (this.#n) {
      for (var t = this.#d; 1; ) {
        if (!this.#V(t)) {
          break;
        }
        if (e || !this.#N(t)) {
          yield t;
        }
        if (t === this.#c) {
          break;
        } else {
          t = this.#f[t];
        }
      }
    }
  }
  * #k({allowStale: e = this.allowStale} = {}) {
    if (this.#n) {
      for (var t = this.#c; 1; ) {
        if (!this.#V(t)) {
          break;
        }
        if (e || !this.#N(t)) {
          yield t;
        }
        if (t === this.#d) {
          break;
        } else {
          t = this.#p[t];
        }
      }
    }
  }
  #V(e) {
    return void 0 !== e && this.#l.get(this.#u[e]) === e;
  }
  * entries() {
    for (var e of this.#D()) {
      if (void 0 !== this.#h[e] && void 0 !== this.#u[e] && !this.#b(this.#h[e])) {
        yield [ this.#u[e], this.#h[e] ];
      }
    }
  }
  * rentries() {
    for (var e of this.#k()) {
      if (void 0 !== this.#h[e] && void 0 !== this.#u[e] && !this.#b(this.#h[e])) {
        yield [ this.#u[e], this.#h[e] ];
      }
    }
  }
  * keys() {
    for (var e of this.#D()) {
      var t = this.#u[e];
      if (void 0 !== t && !this.#b(this.#h[e])) {
        yield t;
      }
    }
  }
  * rkeys() {
    for (var e of this.#k()) {
      var t = this.#u[e];
      if (void 0 !== t && !this.#b(this.#h[e])) {
        yield t;
      }
    }
  }
  * values() {
    for (var e of this.#D()) {
      if (void 0 !== this.#h[e] && !this.#b(this.#h[e])) {
        yield this.#h[e];
      }
    }
  }
  * rvalues() {
    for (var e of this.#k()) {
      if (void 0 !== this.#h[e] && !this.#b(this.#h[e])) {
        yield this.#h[e];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(e, t = {}) {
    for (var i of this.#D()) {
      var r = this.#h[i];
      var s = this.#b(r) ? r.__staleWhileFetching : r;
      if (void 0 === s) {
        continue;
      }
      if (e(s, this.#u[i], this)) {
        return this.get(this.#u[i], t);
      }
    }
  }
  forEach(e, t = this) {
    for (var i of this.#D()) {
      var r = this.#h[i];
      var s = this.#b(r) ? r.__staleWhileFetching : r;
      if (void 0 === s) {
        continue;
      }
      e.call(t, s, this.#u[i], this);
    }
  }
  rforEach(e, t = this) {
    for (var i of this.#k()) {
      var r = this.#h[i];
      var s = this.#b(r) ? r.__staleWhileFetching : r;
      if (void 0 === s) {
        continue;
      }
      e.call(t, s, this.#u[i], this);
    }
  }
  purgeStale() {
    var e = !1;
    for (var t of this.#k({
      allowStale: !0
    })) {
      if (this.#N(t)) {
        this.delete(this.#u[t]);
        e = !0;
      }
    }
    return e;
  }
  dump() {
    var e = [];
    for (var t of this.#D({
      allowStale: !0
    })) {
      var i = this.#u[t];
      var r = this.#h[t];
      var s = this.#b(r) ? r.__staleWhileFetching : r;
      if (void 0 === s || void 0 === i) {
        continue;
      }
      var a = {
        value: s
      };
      if (this.#S && this.#x) {
        a.ttl = this.#S[t];
        var n = w.now() - this.#x[t];
        a.start = Math.floor(Date.now() - n);
      }
      if (this.#m) {
        a.size = this.#m[t];
      }
      e.unshift([ i, a ]);
    }
    return e;
  }
  load(e) {
    this.clear();
    for (var [t, i] of e) {
      if (i.start) {
        var r = Date.now() - i.start;
        i.start = w.now() - r;
      }
      this.set(t, i.value, i);
    }
  }
  set(e, t, i = {}) {
    if (void 0 === t) {
      this.delete(e);
      return this;
    }
    var {ttl: r = this.ttl, start: s, noDisposeOnSet: a = this.noDisposeOnSet, sizeCalculation: n = this.sizeCalculation, status: o} = i;
    var {noUpdateTTL: l = this.noUpdateTTL} = i;
    var u = this.#O(e, t, i.size || 0, n);
    if (this.maxEntrySize && u > this.maxEntrySize) {
      if (o) {
        o.set = "miss";
        o.maxEntrySizeExceeded = !0;
      }
      this.delete(e);
      return this;
    }
    var h = 0 === this.#n ? void 0 : this.#l.get(e);
    if (void 0 === h) {
      h = 0 === this.#n ? this.#d : 0 !== this.#v.length ? this.#v.pop() : this.#n === this.#t ? this.#$(!1) : this.#n;
      this.#u[h] = e;
      this.#h[h] = t;
      this.#l.set(e, h);
      this.#p[this.#d] = h;
      this.#f[h] = this.#d;
      this.#d = h;
      this.#n++;
      this.#R(h, u, o);
      if (o) {
        o.set = "add";
      }
      l = !1;
    } else {
      this.#w(h);
      var p = this.#h[h];
      if (t !== p) {
        if (this.#T && this.#b(p)) {
          p.__abortController.abort(new Error("replaced"));
          var {__staleWhileFetching: f} = p;
          if (void 0 !== f && !a) {
            if (this.#y) {
              this.#r?.(f, e, "set");
            }
            if (this.#E) {
              this.#g?.push([ f, e, "set" ]);
            }
          }
        } else if (!a) {
          if (this.#y) {
            this.#r?.(p, e, "set");
          }
          if (this.#E) {
            this.#g?.push([ p, e, "set" ]);
          }
        }
        this.#I(h);
        this.#R(h, u, o);
        this.#h[h] = t;
        if (o) {
          o.set = "replace";
          var c = p && this.#b(p) ? p.__staleWhileFetching : p;
          if (void 0 !== c) {
            o.oldValue = c;
          }
        }
      } else if (o) {
        o.set = "update";
      }
    }
    if (0 !== r && !this.#S) {
      this.#F();
    }
    if (this.#S) {
      if (!l) {
        this.#L(h, r, s);
      }
      if (o) {
        this.#z(o, h);
      }
    }
    if (!a && this.#E && this.#g) {
      var d = this.#g;
      var v;
      while (v = d?.shift()) {
        this.#s?.(...v);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#n) {
        var e = this.#h[this.#c];
        this.#$(!0);
        if (this.#b(e)) {
          if (e.__staleWhileFetching) {
            return e.__staleWhileFetching;
          }
        } else if (void 0 !== e) {
          return e;
        }
      }
    } finally {
      if (this.#E && this.#g) {
        var t = this.#g;
        var i;
        while (i = t?.shift()) {
          this.#s?.(...i);
        }
      }
    }
  }
  #$(e) {
    var t = this.#c;
    var i = this.#u[t];
    var r = this.#h[t];
    if (this.#T && this.#b(r)) {
      r.__abortController.abort(new Error("evicted"));
    } else if (this.#y || this.#E) {
      if (this.#y) {
        this.#r?.(r, i, "evict");
      }
      if (this.#E) {
        this.#g?.push([ r, i, "evict" ]);
      }
    }
    this.#I(t);
    if (e) {
      this.#u[t] = void 0;
      this.#h[t] = void 0;
      this.#v.push(t);
    }
    if (1 === this.#n) {
      this.#c = this.#d = 0;
      this.#v.length = 0;
    } else {
      this.#c = this.#p[t];
    }
    this.#l.delete(i);
    this.#n--;
    return t;
  }
  has(e, t = {}) {
    var {updateAgeOnHas: i = this.updateAgeOnHas, status: r} = t;
    var s = this.#l.get(e);
    if (void 0 !== s) {
      var a = this.#h[s];
      if (this.#b(a) && void 0 === a.__staleWhileFetching) {
        return !1;
      }
      if (!this.#N(s)) {
        if (i) {
          this.#C(s);
        }
        if (r) {
          r.has = "hit";
          this.#z(r, s);
        }
        return !0;
      } else if (r) {
        r.has = "stale";
        this.#z(r, s);
      }
    } else if (r) {
      r.has = "miss";
    }
    return !1;
  }
  peek(e, t = {}) {
    var {allowStale: i = this.allowStale} = t;
    var r = this.#l.get(e);
    if (void 0 !== r && (i || !this.#N(r))) {
      var s = this.#h[r];
      return this.#b(s) ? s.__staleWhileFetching : s;
    }
  }
  #A(e, t, i, r) {
    var s = void 0 === t ? void 0 : this.#h[t];
    if (this.#b(s)) {
      return s;
    }
    var a = new N;
    var {signal: n} = i;
    n?.addEventListener("abort", (() => a.abort(n.reason)), {
      signal: a.signal
    });
    var o = {
      signal: a.signal,
      options: i,
      context: r
    };
    var cb = (r, s = !1) => {
      var {aborted: n} = a.signal;
      var u = i.ignoreFetchAbort && void 0 !== r;
      if (i.status) {
        if (n && !s) {
          i.status.fetchAborted = !0;
          i.status.fetchError = a.signal.reason;
          if (u) {
            i.status.fetchAbortIgnored = !0;
          }
        } else {
          i.status.fetchResolved = !0;
        }
      }
      if (n && !u && !s) {
        return fetchFail(a.signal.reason);
      }
      if (this.#h[t] === l) {
        if (void 0 === r) {
          if (l.__staleWhileFetching) {
            this.#h[t] = l.__staleWhileFetching;
          } else {
            this.delete(e);
          }
        } else {
          if (i.status) {
            i.status.fetchUpdated = !0;
          }
          this.set(e, r, o.options);
        }
      }
      return r;
    };
    var fetchFail = r => {
      var {aborted: s} = a.signal;
      var n = s && i.allowStaleOnFetchAbort;
      var o = n || i.allowStaleOnFetchRejection;
      var u = l;
      if (this.#h[t] === l) {
        if (!(o || i.noDeleteOnFetchRejection) || void 0 === u.__staleWhileFetching) {
          this.delete(e);
        } else if (!n) {
          this.#h[t] = u.__staleWhileFetching;
        }
      }
      if (o) {
        if (i.status && void 0 !== u.__staleWhileFetching) {
          i.status.returnedStale = !0;
        }
        return u.__staleWhileFetching;
      } else if (u.__returned === u) {
        throw r;
      }
    };
    if (i.status) {
      i.status.fetchDispatched = !0;
    }
    var l = new Promise(((t, r) => {
      var n = this.#a?.(e, s, o);
      if (n && n instanceof Promise) {
        n.then((e => t(void 0 === e ? void 0 : e)), r);
      }
      a.signal.addEventListener("abort", (() => {
        if (!i.ignoreFetchAbort || i.allowStaleOnFetchAbort) {
          t(void 0);
          if (i.allowStaleOnFetchAbort) {
            t = e => cb(e, !0);
          }
        }
      }));
    })).then(cb, (e => {
      if (i.status) {
        i.status.fetchRejected = !0;
        i.status.fetchError = e;
      }
      return fetchFail(e);
    }));
    var u = Object.assign(l, {
      __abortController: a,
      __staleWhileFetching: s,
      __returned: void 0
    });
    if (void 0 === t) {
      this.set(e, u, {
        ...o.options,
        status: void 0
      });
      t = this.#l.get(e);
    } else {
      this.#h[t] = u;
    }
    return u;
  }
  #b(e) {
    if (!this.#T) {
      return !1;
    }
    var t = e;
    return !!t && t instanceof Promise && t.hasOwnProperty("__staleWhileFetching") && t.__abortController instanceof N;
  }
  async fetch(e, t = {}) {
    var {allowStale: i = this.allowStale, updateAgeOnGet: r = this.updateAgeOnGet, noDeleteOnStaleGet: s = this.noDeleteOnStaleGet, ttl: a = this.ttl, noDisposeOnSet: n = this.noDisposeOnSet, size: o = 0, sizeCalculation: l = this.sizeCalculation, noUpdateTTL: u = this.noUpdateTTL, noDeleteOnFetchRejection: h = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: p = this.allowStaleOnFetchRejection, ignoreFetchAbort: f = this.ignoreFetchAbort, allowStaleOnFetchAbort: c = this.allowStaleOnFetchAbort, context: d, forceRefresh: v = !1, status: g, signal: m} = t;
    if (!this.#T) {
      if (g) {
        g.fetch = "get";
      }
      return this.get(e, {
        allowStale: i,
        updateAgeOnGet: r,
        noDeleteOnStaleGet: s,
        status: g
      });
    }
    var x = {
      allowStale: i,
      updateAgeOnGet: r,
      noDeleteOnStaleGet: s,
      ttl: a,
      noDisposeOnSet: n,
      size: o,
      sizeCalculation: l,
      noUpdateTTL: u,
      noDeleteOnFetchRejection: h,
      allowStaleOnFetchRejection: p,
      allowStaleOnFetchAbort: c,
      ignoreFetchAbort: f,
      status: g,
      signal: m
    };
    var S = this.#l.get(e);
    if (void 0 === S) {
      if (g) {
        g.fetch = "miss";
      }
      var y = this.#A(e, S, x, d);
      return y.__returned = y;
    } else {
      var T = this.#h[S];
      if (this.#b(T)) {
        var E = i && void 0 !== T.__staleWhileFetching;
        if (g) {
          g.fetch = "inflight";
          if (E) {
            g.returnedStale = !0;
          }
        }
        return E ? T.__staleWhileFetching : T.__returned = T;
      }
      var b = this.#N(S);
      if (!v && !b) {
        if (g) {
          g.fetch = "hit";
        }
        this.#w(S);
        if (r) {
          this.#C(S);
        }
        if (g) {
          this.#z(g, S);
        }
        return T;
      }
      var A = this.#A(e, S, x, d);
      var w = void 0 !== A.__staleWhileFetching && i;
      if (g) {
        g.fetch = b ? "stale" : "refresh";
        if (w && b) {
          g.returnedStale = !0;
        }
      }
      return w ? A.__staleWhileFetching : A.__returned = A;
    }
  }
  get(e, t = {}) {
    var {allowStale: i = this.allowStale, updateAgeOnGet: r = this.updateAgeOnGet, noDeleteOnStaleGet: s = this.noDeleteOnStaleGet, status: a} = t;
    var n = this.#l.get(e);
    if (void 0 !== n) {
      var o = this.#h[n];
      var l = this.#b(o);
      if (a) {
        this.#z(a, n);
      }
      if (this.#N(n)) {
        if (a) {
          a.get = "stale";
        }
        if (!l) {
          if (!s) {
            this.delete(e);
          }
          if (a && i) {
            a.returnedStale = !0;
          }
          return i ? o : void 0;
        } else {
          if (a && i && void 0 !== o.__staleWhileFetching) {
            a.returnedStale = !0;
          }
          return i ? o.__staleWhileFetching : void 0;
        }
      } else {
        if (a) {
          a.get = "hit";
        }
        if (l) {
          return o.__staleWhileFetching;
        }
        this.#w(n);
        if (r) {
          this.#C(n);
        }
        return o;
      }
    } else if (a) {
      a.get = "miss";
    }
  }
  #P(e, t) {
    this.#f[t] = e;
    this.#p[e] = t;
  }
  #w(e) {
    if (e !== this.#d) {
      if (e === this.#c) {
        this.#c = this.#p[e];
      } else {
        this.#P(this.#f[e], this.#p[e]);
      }
      this.#P(this.#d, e);
      this.#d = e;
    }
  }
  delete(e) {
    var t = !1;
    if (0 !== this.#n) {
      var i = this.#l.get(e);
      if (void 0 !== i) {
        t = !0;
        if (1 === this.#n) {
          this.clear();
        } else {
          this.#I(i);
          var r = this.#h[i];
          if (this.#b(r)) {
            r.__abortController.abort(new Error("deleted"));
          } else if (this.#y || this.#E) {
            if (this.#y) {
              this.#r?.(r, e, "delete");
            }
            if (this.#E) {
              this.#g?.push([ r, e, "delete" ]);
            }
          }
          this.#l.delete(e);
          this.#u[i] = void 0;
          this.#h[i] = void 0;
          if (i === this.#d) {
            this.#d = this.#f[i];
          } else if (i === this.#c) {
            this.#c = this.#p[i];
          } else {
            this.#p[this.#f[i]] = this.#p[i];
            this.#f[this.#p[i]] = this.#f[i];
          }
          this.#n--;
          this.#v.push(i);
        }
      }
    }
    if (this.#E && this.#g?.length) {
      var s = this.#g;
      var a;
      while (a = s?.shift()) {
        this.#s?.(...a);
      }
    }
    return t;
  }
  clear() {
    for (var e of this.#k({
      allowStale: !0
    })) {
      var t = this.#h[e];
      if (this.#b(t)) {
        t.__abortController.abort(new Error("deleted"));
      } else {
        var i = this.#u[e];
        if (this.#y) {
          this.#r?.(t, i, "delete");
        }
        if (this.#E) {
          this.#g?.push([ t, i, "delete" ]);
        }
      }
    }
    this.#l.clear();
    this.#h.fill(void 0);
    this.#u.fill(void 0);
    if (this.#S && this.#x) {
      this.#S.fill(0);
      this.#x.fill(0);
    }
    if (this.#m) {
      this.#m.fill(0);
    }
    this.#c = 0;
    this.#d = 0;
    this.#v.length = 0;
    this.#o = 0;
    this.#n = 0;
    if (this.#E && this.#g) {
      var r = this.#g;
      var s;
      while (s = r?.shift()) {
        this.#s?.(...s);
      }
    }
  }
}

var L = {
  exports: {}
};

var C = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};

var z = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};

L.exports = function fnv1a(e) {
  var t = Number(z[32]);
  var i = !1;
  for (var r = 0; r < e.length; r++) {
    var s = e.charCodeAt(r);
    if (s > 127 && !i) {
      s = (e = unescape(encodeURIComponent(e))).charCodeAt(r);
      i = !0;
    }
    t ^= s;
    t += (t << 1) + (t << 4) + (t << 7) + (t << 8) + (t << 24);
  }
  return t >>> 0;
};

L.exports.bigInt = function bigInt(e, {size: t = 32} = {}) {
  if (!C[t]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  var i = z[t];
  var r = C[t];
  var s = !1;
  for (var a = 0; a < e.length; a++) {
    var n = e.charCodeAt(a);
    if (n > 127 && !s) {
      n = (e = unescape(encodeURIComponent(e))).charCodeAt(a);
      s = !0;
    }
    i ^= BigInt(n);
    i = BigInt.asUintN(t, i * r);
  }
  return i;
};

var I = getDefaultExportFromCjs(L.exports);

var unwrapAbstractType = e => e.isUnionOrIntersection() ? e.types.find((e => e.flags & exports.ts.TypeFlags.Object)) || e : e;

var getVariableDeclaration = e => {
  var t = e;
  var i = new Set;
  while (t.parent && !i.has(t)) {
    i.add(t);
    if (exports.ts.isBlock(t)) {
      return;
    } else if (exports.ts.isVariableDeclaration(t = t.parent)) {
      return t;
    }
  }
};

var traverseArrayDestructuring = (e, t, i, r, s) => e.elements.flatMap((e => {
  if (exports.ts.isOmittedExpression(e)) {
    return [];
  }
  var a = [ ...t ];
  return exports.ts.isIdentifier(e.name) ? crawlScope(e.name, a, i, r, s, !1) : exports.ts.isObjectBindingPattern(e.name) ? traverseDestructuring(e.name, a, i, r, s) : traverseArrayDestructuring(e.name, a, i, r, s);
}));

var traverseDestructuring = (e, t, i, r, s) => {
  var a = [];
  var _loop = function() {
    if (exports.ts.isObjectBindingPattern(n.name)) {
      var e = [ ...t ];
      if (n.propertyName && !t.includes(n.propertyName.getText())) {
        var o = [ ...e, n.propertyName.getText() ].join(".");
        if (i.find((e => e.startsWith(o)))) {
          e.push(n.propertyName.getText());
        }
      }
      var l = traverseDestructuring(n.name, e, i, r, s);
      a.push(...l);
    } else if (exports.ts.isIdentifier(n.name)) {
      var u = [ ...t ];
      if (n.propertyName && !t.includes(n.propertyName.getText())) {
        var h = [ ...u, n.propertyName.getText() ].join(".");
        if (i.find((e => e.startsWith(h)))) {
          u.push(n.propertyName.getText());
        }
      } else {
        var p = [ ...u, n.name.getText() ].join(".");
        if (i.find((e => e.startsWith(p)))) {
          u.push(n.name.getText());
        }
      }
      var f = crawlScope(n.name, u, i, r, s, !1);
      a.push(...f);
    }
  };
  for (var n of e.elements) {
    _loop();
  }
  return a;
};

var O = new Set([ "map", "filter", "forEach", "reduce", "every", "some", "find", "flatMap", "sort" ]);

var crawlScope = (e, t, i, r, s, a) => {
  if (exports.ts.isObjectBindingPattern(e)) {
    return traverseDestructuring(e, t, i, r, s);
  } else if (exports.ts.isArrayBindingPattern(e)) {
    return traverseArrayDestructuring(e, t, i, r, s);
  }
  var n = [];
  var o = s.languageService.getReferencesAtPosition(r.fileName, e.getStart());
  if (!o) {
    return n;
  }
  return n = o.flatMap((n => {
    if (n.fileName !== r.fileName) {
      return [];
    }
    if (e.getStart() <= n.textSpan.start && e.getEnd() >= n.textSpan.start + n.textSpan.length) {
      return [];
    }
    var o = findNode(r, n.textSpan.start);
    if (!o) {
      return [];
    }
    var l = [ ...t ];
    var u, _loop2 = function() {
      if (!a && (exports.ts.isReturnStatement(o) || exports.ts.isArrowFunction(o))) {
        var e = l.join(".");
        return {
          v: i.filter((t => t.startsWith(e + ".")))
        };
      } else if (exports.ts.isVariableDeclaration(o)) {
        return {
          v: crawlScope(o.name, l, i, r, s, !1)
        };
      } else if (exports.ts.isIdentifier(o) && !l.includes(o.text)) {
        var t = [ ...l, o.text ].join(".");
        if (i.find((e => e.startsWith(t + ".")))) {
          l.push(o.text);
        }
      } else if (exports.ts.isPropertyAccessExpression(o) && "at" === o.name.text && exports.ts.isCallExpression(o.parent)) {
        o = o.parent;
      } else if (exports.ts.isPropertyAccessExpression(o) && O.has(o.name.text) && exports.ts.isCallExpression(o.parent)) {
        var n = "reduce" === o.name.text;
        var u = "every" === o.name.text || "some" === o.name.text;
        var h = o.parent;
        var p = h.arguments[0];
        if (exports.ts.isIdentifier(p)) {
          var f = s.languageService.getProgram().getTypeChecker();
          var c = f.getSymbolAtLocation(p)?.valueDeclaration;
          if (c && exports.ts.isFunctionDeclaration(c)) {
            p = c;
          } else if (c && exports.ts.isVariableDeclaration(c) && c.initializer) {
            p = c.initializer;
          }
        }
        if (exports.ts.isFunctionDeclaration(p) || exports.ts.isFunctionExpression(p) || exports.ts.isArrowFunction(p)) {
          var d = crawlScope(p.parameters[n ? 1 : 0].name, l, i, r, s, !0);
          if (exports.ts.isVariableDeclaration(h.parent) && !u) {
            var v = crawlScope(h.parent.name, l, i, r, s, !0);
            d.push(...v);
          }
          return {
            v: d
          };
        }
      } else if (exports.ts.isPropertyAccessExpression(o) && !l.includes(o.name.text)) {
        var g = [ ...l, o.name.text ].join(".");
        if (i.find((e => e.startsWith(g)))) {
          l.push(o.name.text);
        }
      } else if (exports.ts.isElementAccessExpression(o) && exports.ts.isStringLiteral(o.argumentExpression) && !l.includes(o.argumentExpression.text)) {
        var m = [ ...l, o.argumentExpression.text ].join(".");
        if (i.find((e => e.startsWith(m)))) {
          l.push(o.argumentExpression.text);
        }
      }
      if (exports.ts.isNonNullExpression(o.parent)) {
        o = o.parent.parent;
      } else {
        o = o.parent;
      }
    };
    while (exports.ts.isIdentifier(o) || exports.ts.isPropertyAccessExpression(o) || exports.ts.isElementAccessExpression(o) || exports.ts.isVariableDeclaration(o) || exports.ts.isBinaryExpression(o) || exports.ts.isReturnStatement(o) || exports.ts.isArrowFunction(o)) {
      if (u = _loop2()) {
        return u.v;
      }
    }
    return l.join(".");
  }));
};

var getColocatedFragmentNames = (e, t) => {
  var i = function findAllImports(e) {
    return e.statements.filter(exports.ts.isImportDeclaration);
  }(e);
  var r = t.languageService.getProgram()?.getTypeChecker();
  var s = {};
  if (!r) {
    return s;
  }
  if (i.length) {
    i.forEach((i => {
      if (!i.importClause) {
        return;
      }
      if (i.importClause.name) {
        var a = t.languageService.getDefinitionAtPosition(e.fileName, i.importClause.name.getStart());
        if (a && a.length) {
          var [n] = a;
          if (n.fileName.includes("node_modules")) {
            return;
          }
          var o = getSource(t, n.fileName);
          if (!o) {
            return;
          }
          var l = getFragmentsInSource(o, r, t).map((e => e.name.value));
          if (l.length && !s[i.moduleSpecifier.getText()]) {
            s[i.moduleSpecifier.getText()] = {
              start: i.moduleSpecifier.getStart(),
              length: i.moduleSpecifier.getText().length,
              fragments: l
            };
          } else if (l.length) {
            s[i.moduleSpecifier.getText()].fragments = s[i.moduleSpecifier.getText()].fragments.concat(l);
          }
        }
      }
      if (i.importClause.namedBindings && exports.ts.isNamespaceImport(i.importClause.namedBindings)) {
        var u = t.languageService.getDefinitionAtPosition(e.fileName, i.importClause.namedBindings.getStart());
        if (u && u.length) {
          var [h] = u;
          if (h.fileName.includes("node_modules")) {
            return;
          }
          var p = getSource(t, h.fileName);
          if (!p) {
            return;
          }
          var f = getFragmentsInSource(p, r, t).map((e => e.name.value));
          if (f.length && !s[i.moduleSpecifier.getText()]) {
            s[i.moduleSpecifier.getText()] = {
              start: i.moduleSpecifier.getStart(),
              length: i.moduleSpecifier.getText().length,
              fragments: f
            };
          } else if (f.length) {
            s[i.moduleSpecifier.getText()].fragments = s[i.moduleSpecifier.getText()].fragments.concat(f);
          }
        }
      } else if (i.importClause.namedBindings && exports.ts.isNamedImportBindings(i.importClause.namedBindings)) {
        i.importClause.namedBindings.elements.forEach((a => {
          var n = t.languageService.getDefinitionAtPosition(e.fileName, a.getStart());
          if (n && n.length) {
            var [o] = n;
            if (o.fileName.includes("node_modules")) {
              return;
            }
            var l = getSource(t, o.fileName);
            if (!l) {
              return;
            }
            var u = getFragmentsInSource(l, r, t).map((e => e.name.value));
            if (u.length && !s[i.moduleSpecifier.getText()]) {
              s[i.moduleSpecifier.getText()] = {
                start: i.moduleSpecifier.getStart(),
                length: i.moduleSpecifier.getText().length,
                fragments: u
              };
            } else if (u.length) {
              s[i.moduleSpecifier.getText()].fragments = s[i.moduleSpecifier.getText()].fragments.concat(u);
            }
          }
        }));
      }
    }));
  }
  return s;
};

function getFragmentsInSource(t, i, r) {
  var s = [];
  var a = findAllCallExpressions(t, r, !1);
  var n = i.getSymbolAtLocation(t);
  if (!n) {
    return [];
  }
  var o = i.getExportsOfModule(n).map((e => e.name));
  a.nodes.filter((e => {
    var t = e.parent;
    while (t && !exports.ts.isSourceFile(t) && !exports.ts.isVariableDeclaration(t)) {
      t = t.parent;
    }
    if (exports.ts.isVariableDeclaration(t)) {
      return o.includes(t.name.getText());
    } else {
      return !1;
    }
  })).forEach((i => {
    var a = resolveTemplate(i, t.fileName, r).combinedText;
    try {
      var n = e.parse(a, {
        noLocation: !0
      });
      if (n.definitions.every((t => t.kind === e.Kind.FRAGMENT_DEFINITION))) {
        s = s.concat(n.definitions);
      }
    } catch (e) {
      return;
    }
  }));
  return s;
}

var getDocumentReferenceFromTypeQuery = (e, t, i) => {
  var r = i.languageService.getReferencesAtPosition(t, e.exprName.getStart());
  if (!r) {
    return {
      node: null,
      filename: t
    };
  }
  var s = null;
  var a = t;
  r.forEach((e => {
    if (s) {
      return;
    }
    var t = getSource(i, e.fileName);
    if (!t) {
      return;
    }
    var r = findNode(t, e.textSpan.start);
    if (!r) {
      return;
    }
    if (exports.ts.isVariableDeclaration(r.parent) && r.parent.initializer && exports.ts.isCallExpression(r.parent.initializer) && A.has(r.parent.initializer.expression.getText())) {
      s = r.parent.initializer;
      a = e.fileName;
    }
  }));
  return {
    node: s,
    filename: a
  };
};

var getDocumentReferenceFromDocumentNode = (e, t, i) => {
  if (exports.ts.isIdentifier(e)) {
    var r = i.languageService.getReferencesAtPosition(t, e.getStart());
    if (!r) {
      return {
        node: null,
        filename: t
      };
    }
    var s = null;
    var a = t;
    r.forEach((e => {
      if (s) {
        return;
      }
      var t = getSource(i, e.fileName);
      if (!t) {
        return;
      }
      var r = findNode(t, e.textSpan.start);
      if (!r) {
        return;
      }
      if (exports.ts.isVariableDeclaration(r.parent) && r.parent.initializer && exports.ts.isCallExpression(r.parent.initializer) && A.has(r.parent.initializer.expression.getText())) {
        s = r.parent.initializer;
        a = e.fileName;
      }
    }));
    return {
      node: s,
      filename: a
    };
  } else {
    return {
      node: e,
      filename: t
    };
  }
};

var R = new Set([ "populate", "client", "_unmask", "_optional", "_relayPagination", "_simplePagination", "_required", "optional", "required", "arguments", "argumentDefinitions", "connection", "refetchable", "relay", "required", "inline" ]);

var $ = 520100;

var V = 520101;

var P = 520102;

var j = [ 52001, 52002, 52004, 52003, 52005, $, V, P ];

var M = new LRUCache({
  ttl: 9e5,
  max: 5e3
});

var runDiagnostics = (t, {nodes: i, fragments: r}, s, a) => {
  var n = t.fileName;
  var o = a.config.templateIsCallExpression ?? !0;
  var l = i.map((t => {
    var i = t;
    if (!o && (exports.ts.isNoSubstitutionTemplateLiteral(i) || exports.ts.isTemplateExpression(i))) {
      if (exports.ts.isTaggedTemplateExpression(i.parent)) {
        i = i.parent;
      } else {
        return;
      }
    }
    var {combinedText: l, resolvedSpans: u} = resolveTemplate(i, n, a);
    var h = l.split("\n");
    var p = !1;
    if (exports.ts.isAsExpression(i.parent)) {
      if (exports.ts.isExpressionStatement(i.parent.parent)) {
        p = !0;
      }
    } else if (exports.ts.isExpressionStatement(i.parent)) {
      p = !0;
    }
    var f = i.getStart() + (o ? 0 : i.tag.getText().length + (p ? 2 : 0));
    var c = f + i.getText().length;
    var d = [ ...r ];
    if (o) {
      try {
        var v = e.parse(l, {
          noLocation: !0
        }).definitions.filter((t => t.kind === e.Kind.FRAGMENT_DEFINITION));
        d = d.filter((t => !v.some((i => i.kind === e.Kind.FRAGMENT_DEFINITION && i.name.value === t.name.value))));
      } catch (e) {}
    }
    var g = getDiagnostics(l, s.current, void 0, void 0, d).filter((e => {
      if (!e.message.includes("Unknown directive")) {
        return !0;
      }
      var [t] = e.message.split("(");
      var i = /Unknown directive "@([^)]+)"/g.exec(t);
      if (!i) {
        return !0;
      }
      return !R.has(i[1]);
    })).map((e => {
      var {start: t, end: i} = e.range;
      var r = f + t.line;
      for (var s = 0; s <= t.line; s++) {
        if (s === t.line) {
          r += t.character;
        } else if (h[s]) {
          r += h[s].length;
        }
      }
      var a = f + i.line;
      for (var n = 0; n <= i.line; n++) {
        if (n === i.line) {
          a += i.character;
        } else if (h[n]) {
          a += h[n].length;
        }
      }
      var o = u.find((e => r >= e.new.start && a <= e.new.start + e.new.length));
      if (o) {
        return {
          ...e,
          start: o.original.start,
          length: o.original.length
        };
      } else if (r > c) {
        var l = u.filter((e => e.new.start + e.new.length < r)).reduce(((e, t) => e + (t.new.length - t.original.length)), 0);
        r -= l;
        a -= l;
        return {
          ...e,
          start: r + 1,
          length: a - r
        };
      } else {
        return {
          ...e,
          start: r + 1,
          length: a - r
        };
      }
    })).filter((e => e.start + e.length <= c));
    try {
      var m = e.parse(l, {
        noLocation: !0
      });
      if (m.definitions.some((t => t.kind === e.Kind.OPERATION_DEFINITION))) {
        if (!m.definitions.find((t => t.kind === e.Kind.OPERATION_DEFINITION)).name) {
          g.push({
            message: "Operation should contain a name.",
            start: i.getStart(),
            code: 52002,
            length: t.getText().length,
            range: {},
            severity: 2
          });
        }
      }
    } catch (e) {}
    return g;
  })).flat().filter(Boolean);
  var u = l.map((e => ({
    file: t,
    length: e.length,
    start: e.start,
    category: 2 === e.severity ? exports.ts.DiagnosticCategory.Warning : exports.ts.DiagnosticCategory.Error,
    code: "number" == typeof e.code ? e.code : 2 === e.severity ? 52004 : 52001,
    messageText: e.message.split("\n")[0]
  })));
  if (o) {
    var h = ((t, i, r) => {
      var s = [];
      if (!(r.config.trackFieldUsage ?? 1)) {
        return s;
      }
      var a = new Set([ "id", "_id", "__typename", ...r.config.reservedKeys ?? [] ]);
      var n = r.languageService.getProgram()?.getTypeChecker();
      if (!n) {
        return;
      }
      try {
        i.forEach((i => {
          var o = i.getText();
          if (o.includes("mutation") || o.includes("subscription")) {
            return;
          }
          var l = getVariableDeclaration(i);
          if (!l) {
            return;
          }
          var u;
          var h = n.getTypeAtLocation(i.parent);
          if ("target" in h) {
            var p = h.resolvedTypeArguments;
            u = p.length > 1 ? p[0] : void 0;
          }
          if (!u) {
            var f = h.getProperty("__apiType");
            if (f) {
              var c = n.getTypeOfSymbol(f);
              var d = h.getCallSignatures()[0];
              if (c.isUnionOrIntersection()) {
                for (var v of c.types) {
                  if (d = v.getCallSignatures()[0]) {
                    u = d.getReturnType();
                    break;
                  }
                }
              }
              u = d && d.getReturnType();
            }
          }
          var g = r.languageService.getReferencesAtPosition(t.fileName, l.name.getStart());
          if (!g) {
            return;
          }
          var m = [];
          var x = [];
          var S = [];
          var y = new Map;
          e.visit(e.parse(i.getText().slice(1, -1)), {
            Field: {
              enter(e) {
                var t = e.alias ? e.alias.value : e.name.value;
                var i = x.length ? `${x.join(".")}.${t}` : t;
                if (!e.selectionSet && !a.has(e.name.value)) {
                  S.push(i);
                  y.set(i, {
                    start: e.name.loc.start,
                    length: e.name.loc.end - e.name.loc.start
                  });
                } else if (e.selectionSet) {
                  x.push(t);
                  y.set(i, {
                    start: e.name.loc.start,
                    length: e.name.loc.end - e.name.loc.start
                  });
                }
              },
              leave(e) {
                if (e.selectionSet) {
                  x.pop();
                }
              }
            }
          });
          g.forEach((e => {
            if (e.fileName !== t.fileName) {
              return;
            }
            var i = findNode(t, e.textSpan.start);
            if (!i) {
              return;
            }
            if (i.parent === l) {
              return;
            }
            var s = n.getSymbolsInScope(i, exports.ts.SymbolFlags.BlockScopedVariable);
            var a;
            for (var o of s) {
              if (!o.valueDeclaration) {
                continue;
              }
              var h = unwrapAbstractType(n.getTypeOfSymbol(o));
              if (u === h) {
                a = o;
                break;
              }
              if (h.flags & exports.ts.TypeFlags.Object) {
                var p = h.getProperty("0");
                if (p) {
                  h = n.getTypeOfSymbol(p);
                  if (u === h) {
                    a = o;
                    break;
                  }
                }
                var f = h.getProperty("data");
                if (f) {
                  h = unwrapAbstractType(n.getTypeOfSymbol(f));
                  if (u === h) {
                    a = o;
                    break;
                  }
                }
              }
            }
            var c = a?.valueDeclaration;
            var d;
            if (c && "name" in c && c.name && (exports.ts.isIdentifier(c.name) || exports.ts.isBindingName(c.name))) {
              d = c.name;
            } else {
              var v = getVariableDeclaration(i);
              if (v) {
                d = v.name;
              }
            }
            if (d) {
              var g = crawlScope(d, [], S, t, r, !1);
              m.push(...g);
            }
          }));
          if (!m.length) {
            return;
          }
          var T = S.filter((e => !m.includes(e)));
          var E = new Set;
          var b = {};
          T.forEach((e => {
            var t = e.split(".");
            t.pop();
            var i = t.join(".");
            if (!y.get(i)) {
              return;
            }
            E.add(i);
            if (b[i]) {
              b[i].add(e);
            } else {
              b[i] = new Set([ e ]);
            }
          }));
          E.forEach((e => {
            var r = y.get(e);
            var a = b[e];
            s.push({
              file: t,
              length: r.length,
              start: i.getStart() + r.start + 1,
              category: exports.ts.DiagnosticCategory.Warning,
              code: 52005,
              messageText: `Field(s) ${[ ...a ].map((e => `'${e}'`)).join(", ")} are not used.`
            });
          }));
        }));
      } catch (e) {
        console.error("[GraphQLSP]: ", e.message, e.stack);
      }
      return s;
    })(t, i, a) || [];
    if (!h) {
      return u;
    }
    return [ ...u, ...h ];
  } else {
    return u;
  }
};

exports.ALL_DIAGNOSTICS = j;

exports.CharacterStream = CharacterStream;

exports.bubbleUpCallExpression = function bubbleUpCallExpression(e) {
  while (exports.ts.isNoSubstitutionTemplateLiteral(e) || exports.ts.isToken(e) || exports.ts.isTemplateExpression(e) || exports.ts.isTemplateSpan(e)) {
    e = e.parent;
  }
  return e;
};

exports.bubbleUpTemplate = function bubbleUpTemplate(e) {
  while (exports.ts.isNoSubstitutionTemplateLiteral(e) || exports.ts.isToken(e) || exports.ts.isTemplateExpression(e) || exports.ts.isTemplateSpan(e)) {
    e = e.parent;
  }
  return e;
};

exports.findAllPersistedCallExpressions = findAllPersistedCallExpressions;

exports.findNode = findNode;

exports.getAllFragments = getAllFragments;

exports.getDocumentReferenceFromDocumentNode = getDocumentReferenceFromDocumentNode;

exports.getDocumentReferenceFromTypeQuery = getDocumentReferenceFromTypeQuery;

exports.getGraphQLDiagnostics = function getGraphQLDiagnostics(t, i, r) {
  var s = r.config.templateIsCallExpression ?? !0;
  var a = getSource(r, t);
  if (!a) {
    return;
  }
  var n, o = [];
  if (s) {
    var l = findAllCallExpressions(a, r);
    o = l.fragments;
    n = l.nodes;
  } else {
    n = function findAllTaggedTemplateNodes(e) {
      var t = [];
      !function find(e) {
        if (exports.ts.isTaggedTemplateExpression(e) && A.has(e.tag.getText()) || exports.ts.isNoSubstitutionTemplateLiteral(e) && exports.ts.isTaggedTemplateExpression(e.parent) && A.has(e.parent.tag.getText())) {
          t.push(e);
          return;
        } else {
          exports.ts.forEachChild(e, find);
        }
      }(e);
      return t;
    }(a);
  }
  var u = n.map((e => {
    if ((exports.ts.isNoSubstitutionTemplateLiteral(e) || exports.ts.isTemplateExpression(e)) && !s) {
      if (exports.ts.isTaggedTemplateExpression(e.parent)) {
        e = e.parent;
      } else {
        return;
      }
    }
    return resolveTemplate(e, t, r).combinedText;
  }));
  var h = I(s ? a.getText() + o.map((e => print(e))).join("-") + i.version : u.join("-") + i.version);
  var p;
  if (M.has(h)) {
    p = M.get(h);
  } else {
    p = runDiagnostics(a, {
      nodes: n,
      fragments: o
    }, i, r);
    M.set(h, p);
  }
  var f = r.config.shouldCheckForColocatedFragments ?? !0;
  var c = [];
  if (s) {
    var d = findAllPersistedCallExpressions(a).map((e => {
      if (!e.typeArguments && !e.arguments[1]) {
        return {
          category: exports.ts.DiagnosticCategory.Warning,
          code: $,
          file: a,
          messageText: "Missing generic pointing at the GraphQL document.",
          start: e.getStart(),
          length: e.getEnd() - e.getStart()
        };
      }
      var i, s, n, o;
      if (e.typeArguments) {
        var [l] = e.typeArguments;
        n = l.getStart();
        o = l.getEnd() - l.getStart();
        if (!exports.ts.isTypeQueryNode(l)) {
          return {
            category: exports.ts.DiagnosticCategory.Warning,
            code: $,
            file: a,
            messageText: "Provided generic should be a typeQueryNode in the shape of graphql.persisted<typeof document>.",
            start: n,
            length: o
          };
        }
        var {node: u} = getDocumentReferenceFromTypeQuery(l, t, r);
        i = u;
        s = l.getText();
      } else if (e.arguments[1]) {
        n = e.arguments[1].getStart();
        o = e.arguments[1].getEnd() - e.arguments[1].getStart();
        if (!exports.ts.isIdentifier(e.arguments[1]) && !exports.ts.isCallExpression(e.arguments[1])) {
          return {
            category: exports.ts.DiagnosticCategory.Warning,
            code: $,
            file: a,
            messageText: 'Provided argument should be an identifier or invocation of "graphql" in the shape of graphql.persisted(hash, document).',
            start: n,
            length: o
          };
        }
        var {node: h} = getDocumentReferenceFromDocumentNode(e.arguments[1], t, r);
        i = h;
        s = e.arguments[1].getText();
      }
      if (!i) {
        return {
          category: exports.ts.DiagnosticCategory.Warning,
          code: P,
          file: a,
          messageText: `Can't find reference to "${s}".`,
          start: n,
          length: o
        };
      }
      var p = i;
      if (!p || !exports.ts.isCallExpression(p) || !exports.ts.isNoSubstitutionTemplateLiteral(p.arguments[0])) {
        return {
          category: exports.ts.DiagnosticCategory.Warning,
          code: P,
          file: a,
          messageText: `Referenced type "${s}" is not a GraphQL document.`,
          start: n,
          length: o
        };
      }
      if (!e.arguments[0]) {
        return {
          category: exports.ts.DiagnosticCategory.Warning,
          code: V,
          file: a,
          messageText: "The call-expression is missing a hash for the persisted argument.",
          start: e.arguments.pos,
          length: e.arguments.end - e.arguments.pos
        };
      }
      return null;
    })).filter(Boolean);
    p.push(...d);
  }
  if (s && f) {
    var v = getColocatedFragmentNames(a, r);
    var g = new Set;
    n.forEach((t => {
      try {
        var i = e.parse(t.getText().slice(1, -1), {
          noLocation: !0
        });
        e.visit(i, {
          FragmentSpread: e => {
            g.add(e.name.value);
          }
        });
      } catch (e) {}
    }));
    Object.keys(v).forEach((e => {
      var {fragments: t, start: i, length: r} = v[e];
      var s = Array.from(new Set(t.filter((e => !g.has(e)))));
      if (s.length) {
        c.push({
          file: a,
          length: r,
          start: i,
          category: exports.ts.DiagnosticCategory.Warning,
          code: 52003,
          messageText: `Unused co-located fragment definition(s) "${s.join(", ")}" in ${e}`
        });
      }
    }));
    return [ ...p, ...c ];
  } else {
    return p;
  }
};

exports.getPersistedCodeFixAtPosition = function getPersistedCodeFixAtPosition(e, i, r) {
  if (!(r.config.templateIsCallExpression ?? !0)) {
    return;
  }
  var s = getSource(r, e);
  if (!s) {
    return;
  }
  var a = findNode(s, i);
  if (!a) {
    return;
  }
  var n = a;
  if (exports.ts.isVariableStatement(n)) {
    n = n.declarationList.declarations.find((e => exports.ts.isVariableDeclaration(e) && e.initializer && exports.ts.isCallExpression(e.initializer))) || a;
  } else if (exports.ts.isVariableDeclarationList(n)) {
    n = n.declarations.find((e => exports.ts.isVariableDeclaration(e) && e.initializer && exports.ts.isCallExpression(e.initializer))) || a;
  } else if (exports.ts.isVariableDeclaration(n) && n.initializer && exports.ts.isCallExpression(n.initializer)) {
    n = n.initializer;
  } else {
    while (n && !exports.ts.isCallExpression(n)) {
      n = n.parent;
    }
  }
  if (!exports.ts.isCallExpression(n) || !(e => {
    var t = e.getText();
    var [i, r] = t.split(".");
    return A.has(i) && "persisted" === r;
  })(n.expression) || !n.typeArguments && !n.arguments[1]) {
    return;
  }
  var u, h = e;
  if (n.typeArguments) {
    var [p] = n.typeArguments;
    if (!exports.ts.isTypeQueryNode(p)) {
      return;
    }
    var {node: f, filename: c} = getDocumentReferenceFromTypeQuery(p, e, r);
    u = f;
    h = c;
  } else if (n.arguments[1]) {
    if (!exports.ts.isIdentifier(n.arguments[1]) && !exports.ts.isCallExpression(n.arguments[1])) {
      return;
    }
    var {node: d, filename: v} = getDocumentReferenceFromDocumentNode(n.arguments[1], e, r);
    u = d;
    h = v;
  }
  if (!u) {
    return;
  }
  var g = u;
  if (!g || !exports.ts.isCallExpression(g) || !exports.ts.isNoSubstitutionTemplateLiteral(g.arguments[0])) {
    return;
  }
  var m = getSource(r, h);
  var {fragments: x} = findAllCallExpressions(m, r);
  var S = resolveTemplate(g.arguments[0], h, r).combinedText;
  var y = function parse(e, t) {
    o = "string" == typeof e.body ? e.body : e;
    l = 0;
    return function document() {
      var e;
      ignored();
      var t = [];
      while (e = fragmentDefinition() || operationDefinition()) {
        t.push(e);
      }
      return {
        kind: "Document",
        definitions: t
      };
    }();
  }(S);
  var T = new Set;
  !function visit(e, t) {
    var i = [];
    var r = [];
    try {
      var s = function traverse(e, s, a) {
        var n = !1;
        var o = t[e.kind] && t[e.kind].enter || t[e.kind] || t.enter;
        var l = o && o.call(t, e, s, a, r, i);
        if (!1 === l) {
          return e;
        } else if (null === l) {
          return null;
        } else if (l === E) {
          throw E;
        } else if (l && "string" == typeof l.kind) {
          n = l !== e;
          e = l;
        }
        if (a) {
          i.push(a);
        }
        var u;
        var h = {
          ...e
        };
        for (var p in e) {
          r.push(p);
          var f = e[p];
          if (Array.isArray(f)) {
            var c = [];
            for (var d = 0; d < f.length; d++) {
              if (null != f[d] && "string" == typeof f[d].kind) {
                i.push(e);
                r.push(d);
                u = traverse(f[d], d, f);
                r.pop();
                i.pop();
                if (null == u) {
                  n = !0;
                } else {
                  n = n || u !== f[d];
                  c.push(u);
                }
              }
            }
            f = c;
          } else if (null != f && "string" == typeof f.kind) {
            if (void 0 !== (u = traverse(f, p, e))) {
              n = n || f !== u;
              f = u;
            }
          }
          r.pop();
          if (n) {
            h[p] = f;
          }
        }
        if (a) {
          i.pop();
        }
        var v = t[e.kind] && t[e.kind].leave || t.leave;
        var g = v && v.call(t, e, s, a, r, i);
        if (g === E) {
          throw E;
        } else if (void 0 !== g) {
          return g;
        } else if (void 0 !== l) {
          return n ? h : l;
        } else {
          return n ? h : e;
        }
      }(e);
      return void 0 !== s && !1 !== s ? s : e;
    } catch (t) {
      if (t !== E) {
        throw t;
      }
      return e;
    }
  }(y, {
    FragmentSpread: e => {
      T.add(e.name.value);
    }
  });
  var b = S;
  [ ...T ].forEach((e => {
    var t = x.find((t => t.name.value === e));
    if (!t) {
      console.warn(`[GraphQLSP] could not find fragment for spread ${e}!`);
      return;
    }
    b = `${b}\n\n${print(t)}`;
  }));
  var w = t.createHash("sha256").update(S).digest("hex");
  var D = n.arguments[0];
  if (!D) {
    return {
      span: {
        start: n.arguments.pos,
        length: 1
      },
      replacement: `"sha256:${w}")`
    };
  } else if (exports.ts.isStringLiteral(D) && D.getText() !== `"sha256:${w}"`) {
    return {
      span: {
        start: D.getStart(),
        length: D.end - D.getStart()
      },
      replacement: `"sha256:${w}"`
    };
  } else if (exports.ts.isIdentifier(D)) {
    return {
      span: {
        start: D.getStart(),
        length: D.end - D.getStart()
      },
      replacement: `"sha256:${w}"`
    };
  } else {
    return;
  }
};

exports.getSource = getSource;

exports.init = function init(e) {
  exports.ts = e.typescript;
};

exports.onlineParser = onlineParser;

exports.print = print;

exports.resolveTemplate = resolveTemplate;

exports.templates = A;

exports.unrollTadaFragments = function unrollTadaFragments(e, t, i) {
  e.elements.forEach((e => {
    if (exports.ts.isIdentifier(e)) {
      t.push(...unrollFragment(e, i));
    } else if (exports.ts.isPropertyAccessExpression(e)) {
      var r = e;
      while (exports.ts.isPropertyAccessExpression(r.expression)) {
        r = r.expression;
      }
      if (exports.ts.isIdentifier(r.name)) {
        t.push(...unrollFragment(r.name, i));
      }
    }
  }));
  return t;
};
//# sourceMappingURL=api-chunk.js.map
