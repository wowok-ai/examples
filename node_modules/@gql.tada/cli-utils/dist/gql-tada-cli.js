Object.defineProperty(exports, "__esModule", {
  value: !0
});

var e = require("node:path");

var t = require("@gql.tada/internal");

var r = require("node:fs/promises");

var n = require("node:readline");

var i = require("graphql");

var a = require("node:process");

var s = require("node:tty");

var D = require("node:buffer");

var c = require("node:child_process");

var l = require("fs");

var d = require("path");

var f = require("child_process");

var p = require("node:url");

var h = require("node:os");

var m = require("node:fs");

var g = require("node:timers/promises");

var E = require("stream");

var w = require("node:util");

function _interopNamespaceDefault(e) {
  var t = Object.create(null);
  if (e) {
    Object.keys(e).forEach((function(r) {
      if ("default" !== r) {
        var n = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, n.get ? n : {
          enumerable: !0,
          get: function() {
            return e[r];
          }
        });
      }
    }));
  }
  t.default = e;
  return t;
}

var b = _interopNamespaceDefault(e);

var B = _interopNamespaceDefault(r);

var S = _interopNamespaceDefault(n);

var O;

!function(e) {
  e.StartOfInput = "\0";
  e.EndOfInput = "";
  e.EndOfPartialInput = "";
}(O || (O = {}));

var k;

!function(e) {
  e[e.InitialNode = 0] = "InitialNode";
  e[e.SuccessNode = 1] = "SuccessNode";
  e[e.ErrorNode = 2] = "ErrorNode";
  e[e.CustomNode = 3] = "CustomNode";
}(k || (k = {}));

var I = -1;

var M = /^(-h|--help)(?:=([0-9]+))?$/;

var U = /^(--[a-z]+(?:-[a-z]+)*|-[a-zA-Z]+)$/;

var _ = /^-[a-zA-Z]{2,}$/;

var G = /^([^=]+)=([\s\S]*)$/;

var V = "1" === process.env.DEBUG_CLI;

class UsageError extends Error {
  constructor(e) {
    super(e);
    this.clipanion = {
      type: "usage"
    };
    this.name = "UsageError";
  }
}

class UnknownSyntaxError extends Error {
  constructor(e, t) {
    super();
    this.input = e;
    this.candidates = t;
    this.clipanion = {
      type: "none"
    };
    this.name = "UnknownSyntaxError";
    if (0 === this.candidates.length) {
      this.message = "Command not found, but we're not sure what's the alternative.";
    } else if (this.candidates.every((e => null !== e.reason && e.reason === t[0].reason))) {
      var [{reason: r}] = this.candidates;
      this.message = `${r}\n\n${this.candidates.map((({usage: e}) => `$ ${e}`)).join("\n")}`;
    } else if (1 === this.candidates.length) {
      var [{usage: n}] = this.candidates;
      this.message = `Command not found; did you mean:\n\n$ ${n}\n${whileRunning(e)}`;
    } else {
      this.message = `Command not found; did you mean one of:\n\n${this.candidates.map((({usage: e}, t) => `${`${t}.`.padStart(4)} ${e}`)).join("\n")}\n\n${whileRunning(e)}`;
    }
  }
}

class AmbiguousSyntaxError extends Error {
  constructor(e, t) {
    super();
    this.input = e;
    this.usages = t;
    this.clipanion = {
      type: "none"
    };
    this.name = "AmbiguousSyntaxError";
    this.message = `Cannot find which to pick amongst the following alternatives:\n\n${this.usages.map(((e, t) => `${`${t}.`.padStart(4)} ${e}`)).join("\n")}\n\n${whileRunning(e)}`;
  }
}

var whileRunning = e => `While running ${e.filter((e => e !== O.EndOfInput && e !== O.EndOfPartialInput)).map((e => {
  var t = JSON.stringify(e);
  if (e.match(/\s/) || 0 === e.length || t !== `"${e}"`) {
    return t;
  } else {
    return e;
  }
})).join(" ")}`;

var H = Array(80).fill("‚îÅ");

for (var K = 0; K <= 24; ++K) {
  H[H.length - K] = `[38;5;${232 + K}m‚îÅ`;
}

var Y = {
  header: e => `[1m‚îÅ‚îÅ‚îÅ ${e}${e.length < 75 ? ` ${H.slice(e.length + 5).join("")}` : ":"}[0m`,
  bold: e => `[1m${e}[22m`,
  error: e => `[31m[1m${e}[22m[39m`,
  code: e => `[36m${e}[39m`
};

var z = {
  header: e => e,
  bold: e => e,
  error: e => e,
  code: e => e
};

function formatMarkdownish(e, {format: t, paragraphs: r}) {
  e = function dedent(e) {
    var t = e.split("\n");
    var r = t.filter((e => e.match(/\S/)));
    var n = r.length > 0 ? r.reduce(((e, t) => Math.min(e, t.length - t.trimStart().length)), Number.MAX_VALUE) : 0;
    return t.map((e => e.slice(n).trimRight())).join("\n");
  }(e = e.replace(/\r\n?/g, "\n"));
  e = (e = (e = e.replace(/^\n+|\n+$/g, "")).replace(/^(\s*)-([^\n]*?)\n+/gm, "$1-$2\n\n")).replace(/\n(\n)?\n*/g, ((e, t) => t ? t : " "));
  if (r) {
    e = e.split(/\n/).map((e => {
      var t = e.match(/^\s*[*-][\t ]+(.*)/);
      if (!t) {
        return e.match(/(.{1,80})(?: |$)/g).join("\n");
      }
      var r = e.length - e.trimStart().length;
      return t[1].match(new RegExp(`(.{1,${78 - r}})(?: |$)`, "g")).map(((e, t) => " ".repeat(r) + (0 === t ? "- " : "  ") + e)).join("\n");
    })).join("\n\n");
  }
  return (e = (e = e.replace(/(`+)((?:.|[\n])*?)\1/g, ((e, r, n) => t.code(r + n + r)))).replace(/(\*\*)((?:.|[\n])*?)\1/g, ((e, r, n) => t.bold(r + n + r)))) ? `${e}\n` : "";
}

var J = Symbol("clipanion/isOption");

function makeCommandOption(e) {
  return {
    ...e,
    [J]: !0
  };
}

function rerouteArguments(e, t) {
  if (void 0 === e) {
    return [ e, t ];
  }
  if ("object" == typeof e && null !== e && !Array.isArray(e)) {
    return [ void 0, e ];
  } else {
    return [ e, t ];
  }
}

function cleanValidationError(e, {mergeName: t = !1} = {}) {
  var r = e.match(/^([^:]+): (.*)$/m);
  if (!r) {
    return "validation failed";
  }
  var [, n, i] = r;
  if (t) {
    i = i[0].toLowerCase() + i.slice(1);
  }
  return i = "." !== n || !t ? `${n.replace(/^\.(\[|$)/, "$1")}: ${i}` : `: ${i}`;
}

function formatError(e, t) {
  if (1 === t.length) {
    return new UsageError(`${e}${cleanValidationError(t[0], {
      mergeName: !0
    })}`);
  } else {
    return new UsageError(`${e}:\n${t.map((e => `\n- ${cleanValidationError(e)}`)).join("")}`);
  }
}

function applyValidator(e, t, r) {
  if (void 0 === r) {
    return t;
  }
  var n = [];
  var i = [];
  var coercion = e => {
    var r = t;
    t = e;
    return coercion.bind(null, r);
  };
  if (!r(t, {
    errors: n,
    coercions: i,
    coercion
  })) {
    throw formatError(`Invalid value for ${e}`, n);
  }
  for (var [, a] of i) {
    a();
  }
  return t;
}

class Command {
  constructor() {
    this.help = !1;
  }
  static Usage(e) {
    return e;
  }
  async catch(e) {
    throw e;
  }
  async validateAndExecute() {
    var e = this.constructor.schema;
    if (Array.isArray(e)) {
      var {isDict: t, isUnknown: r, applyCascade: n} = await Promise.resolve().then((function() {
        return be;
      }));
      var i = [];
      var a = [];
      if (!n(t(r()), e)(this, {
        errors: i,
        coercions: a
      })) {
        throw formatError("Invalid option schema", i);
      }
      for (var [, s] of a) {
        s();
      }
    } else if (null != e) {
      throw new Error("Invalid command schema");
    }
    var D = await this.execute();
    if (void 0 !== D) {
      return D;
    } else {
      return 0;
    }
  }
}

Command.isOption = J;

Command.Default = [];

function debug(e) {
  if (V) {
    console.log(e);
  }
}

var Z = {
  candidateUsage: null,
  requiredOptions: [],
  errorMessage: null,
  ignoreOptions: !1,
  path: [],
  positionals: [],
  options: [],
  remainder: null,
  selectedIndex: I,
  tokens: []
};

function makeStateMachine() {
  var e = {
    nodes: []
  };
  for (var t = 0; t < k.CustomNode; ++t) {
    e.nodes.push({
      dynamics: [],
      shortcuts: [],
      statics: {}
    });
  }
  return e;
}

function injectNode(e, t) {
  e.nodes.push(t);
  return e.nodes.length - 1;
}

function runMachineInternal(e, t, r = !1) {
  debug(`Running a vm on ${JSON.stringify(t)}`);
  var n = [ {
    node: k.InitialNode,
    state: {
      candidateUsage: null,
      requiredOptions: [],
      errorMessage: null,
      ignoreOptions: !1,
      options: [],
      path: [],
      positionals: [],
      remainder: null,
      selectedIndex: null,
      tokens: []
    }
  } ];
  !function debugMachine(e, {prefix: t = ""} = {}) {
    if (V) {
      debug(`${t}Nodes are:`);
      for (var r = 0; r < e.nodes.length; ++r) {
        debug(`${t}  ${r}: ${JSON.stringify(e.nodes[r])}`);
      }
    }
  }(e, {
    prefix: "  "
  });
  var i = [ O.StartOfInput, ...t ];
  for (var a = 0; a < i.length; ++a) {
    var s = i[a];
    var D = s === O.EndOfInput || s === O.EndOfPartialInput;
    var c = a - 1;
    debug(`  Processing ${JSON.stringify(s)}`);
    var l = [];
    for (var {node: d, state: f} of n) {
      debug(`    Current node is ${d}`);
      var p = e.nodes[d];
      if (d === k.ErrorNode) {
        l.push({
          node: d,
          state: f
        });
        continue;
      }
      console.assert(0 === p.shortcuts.length, "Shortcuts should have been eliminated by now");
      var h = Object.prototype.hasOwnProperty.call(p.statics, s);
      if (!r || a < i.length - 1 || h) {
        if (h) {
          var m = p.statics[s];
          for (var {to: g, reducer: E} of m) {
            l.push({
              node: g,
              state: void 0 !== E ? execute(Q, E, f, s, c) : f
            });
            debug(`      Static transition to ${g} found`);
          }
        } else {
          debug("      No static transition found");
        }
      } else {
        var w = !1;
        for (var b of Object.keys(p.statics)) {
          if (!b.startsWith(s)) {
            continue;
          }
          if (s === b) {
            for (var {to: B, reducer: S} of p.statics[b]) {
              l.push({
                node: B,
                state: void 0 !== S ? execute(Q, S, f, s, c) : f
              });
              debug(`      Static transition to ${B} found`);
            }
          } else {
            for (var {to: I} of p.statics[b]) {
              l.push({
                node: I,
                state: {
                  ...f,
                  remainder: b.slice(s.length)
                }
              });
              debug(`      Static transition to ${I} found (partial match)`);
            }
          }
          w = !0;
        }
        if (!w) {
          debug("      No partial static transition found");
        }
      }
      if (!D) {
        for (var [M, {to: U, reducer: _}] of p.dynamics) {
          if (execute(X, M, f, s, c)) {
            l.push({
              node: U,
              state: void 0 !== _ ? execute(Q, _, f, s, c) : f
            });
            debug(`      Dynamic transition to ${U} found (via ${M})`);
          }
        }
      }
    }
    if (0 === l.length && D && 1 === t.length) {
      return [ {
        node: k.InitialNode,
        state: Z
      } ];
    }
    if (0 === l.length) {
      throw new UnknownSyntaxError(t, n.filter((({node: e}) => e !== k.ErrorNode)).map((({state: e}) => ({
        usage: e.candidateUsage,
        reason: null
      }))));
    }
    if (l.every((({node: e}) => e === k.ErrorNode))) {
      throw new UnknownSyntaxError(t, l.map((({state: e}) => ({
        usage: e.candidateUsage,
        reason: e.errorMessage
      }))));
    }
    n = trimSmallerBranches(l);
  }
  if (n.length > 0) {
    debug("  Results:");
    for (var G of n) {
      debug(`    - ${G.node} -> ${JSON.stringify(G.state)}`);
    }
  } else {
    debug("  No results");
  }
  return n;
}

function runMachine(e, t, {endToken: r = O.EndOfInput} = {}) {
  return function selectBestState(e, t) {
    var r = t.filter((e => null !== e.selectedIndex));
    if (0 === r.length) {
      throw new Error;
    }
    var n = r.filter((e => e.selectedIndex === I || e.requiredOptions.every((t => t.some((t => e.options.find((e => e.name === t))))))));
    if (0 === n.length) {
      throw new UnknownSyntaxError(e, r.map((e => ({
        usage: e.candidateUsage,
        reason: null
      }))));
    }
    var i = 0;
    for (var a of n) {
      if (a.path.length > i) {
        i = a.path.length;
      }
    }
    var s = n.filter((e => e.path.length === i));
    var getPositionalCount = e => e.positionals.filter((({extra: e}) => !e)).length + e.options.length;
    var D = s.map((e => ({
      state: e,
      positionalCount: getPositionalCount(e)
    })));
    var c = 0;
    for (var {positionalCount: l} of D) {
      if (l > c) {
        c = l;
      }
    }
    var d = function aggregateHelpStates(e) {
      var t = [];
      var r = [];
      for (var n of e) {
        if (n.selectedIndex === I) {
          r.push(n);
        } else {
          t.push(n);
        }
      }
      if (r.length > 0) {
        t.push({
          ...Z,
          path: findCommonPrefix(...r.map((e => e.path))),
          options: r.reduce(((e, t) => e.concat(t.options)), [])
        });
      }
      return t;
    }(D.filter((({positionalCount: e}) => e === c)).map((({state: e}) => e)));
    if (d.length > 1) {
      throw new AmbiguousSyntaxError(e, d.map((e => e.candidateUsage)));
    }
    return d[0];
  }(t, runMachineInternal(e, [ ...t, r ]).map((({state: e}) => e)));
}

function trimSmallerBranches(e) {
  var t = 0;
  for (var {state: r} of e) {
    if (r.path.length > t) {
      t = r.path.length;
    }
  }
  return e.filter((({state: e}) => e.path.length === t));
}

function findCommonPrefix(e, t, ...r) {
  if (void 0 === t) {
    return Array.from(e);
  }
  return findCommonPrefix(e.filter(((e, r) => e === t[r])), ...r);
}

function isTerminalNode(e) {
  return e === k.SuccessNode || e === k.ErrorNode;
}

function cloneTransition(e, t = 0) {
  return {
    to: !isTerminalNode(e.to) ? e.to >= k.CustomNode ? e.to + t - k.CustomNode + 1 : e.to + t : e.to,
    reducer: e.reducer
  };
}

function cloneNode(e, t = 0) {
  var r = {
    dynamics: [],
    shortcuts: [],
    statics: {}
  };
  for (var [n, i] of e.dynamics) {
    r.dynamics.push([ n, cloneTransition(i, t) ]);
  }
  for (var a of e.shortcuts) {
    r.shortcuts.push(cloneTransition(a, t));
  }
  for (var [s, D] of Object.entries(e.statics)) {
    r.statics[s] = D.map((e => cloneTransition(e, t)));
  }
  return r;
}

function registerDynamic(e, t, r, n, i) {
  e.nodes[t].dynamics.push([ r, {
    to: n,
    reducer: i
  } ]);
}

function registerShortcut(e, t, r, n) {
  e.nodes[t].shortcuts.push({
    to: r,
    reducer: n
  });
}

function registerStatic(e, t, r, n, i) {
  (!Object.prototype.hasOwnProperty.call(e.nodes[t].statics, r) ? e.nodes[t].statics[r] = [] : e.nodes[t].statics[r]).push({
    to: n,
    reducer: i
  });
}

function execute(e, t, r, n, i) {
  if (Array.isArray(t)) {
    var [a, ...s] = t;
    return e[a](r, n, i, ...s);
  } else {
    return e[t](r, n, i);
  }
}

var X = {
  always: () => !0,
  isOptionLike: (e, t) => !e.ignoreOptions && "-" !== t && t.startsWith("-"),
  isNotOptionLike: (e, t) => e.ignoreOptions || "-" === t || !t.startsWith("-"),
  isOption: (e, t, r, n) => !e.ignoreOptions && t === n,
  isBatchOption: (e, t, r, n) => !e.ignoreOptions && _.test(t) && [ ...t.slice(1) ].every((e => n.has(`-${e}`))),
  isBoundOption: (e, t, r, n, i) => {
    var a = t.match(G);
    return !e.ignoreOptions && !!a && U.test(a[1]) && n.has(a[1]) && i.filter((e => e.nameSet.includes(a[1]))).every((e => e.allowBinding));
  },
  isNegatedOption: (e, t, r, n) => !e.ignoreOptions && t === `--no-${n.slice(2)}`,
  isHelp: (e, t) => !e.ignoreOptions && M.test(t),
  isUnsupportedOption: (e, t, r, n) => !e.ignoreOptions && t.startsWith("-") && U.test(t) && !n.has(t),
  isInvalidOption: (e, t) => !e.ignoreOptions && t.startsWith("-") && !U.test(t)
};

var Q = {
  setCandidateState: (e, t, r, n) => ({
    ...e,
    ...n
  }),
  setSelectedIndex: (e, t, r, n) => ({
    ...e,
    selectedIndex: n
  }),
  pushBatch: (e, t, r, n) => {
    var i = e.options.slice();
    var a = e.tokens.slice();
    for (var s = 1; s < t.length; ++s) {
      var D = n.get(`-${t[s]}`);
      var c = 1 === s ? [ 0, 2 ] : [ s, s + 1 ];
      i.push({
        name: D,
        value: !0
      });
      a.push({
        segmentIndex: r,
        type: "option",
        option: D,
        slice: c
      });
    }
    return {
      ...e,
      options: i,
      tokens: a
    };
  },
  pushBound: (e, t, r) => {
    var [, n, i] = t.match(G);
    var a = e.options.concat({
      name: n,
      value: i
    });
    var s = e.tokens.concat([ {
      segmentIndex: r,
      type: "option",
      slice: [ 0, n.length ],
      option: n
    }, {
      segmentIndex: r,
      type: "assign",
      slice: [ n.length, n.length + 1 ]
    }, {
      segmentIndex: r,
      type: "value",
      slice: [ n.length + 1, n.length + i.length + 1 ]
    } ]);
    return {
      ...e,
      options: a,
      tokens: s
    };
  },
  pushPath: (e, t, r) => {
    var n = e.path.concat(t);
    var i = e.tokens.concat({
      segmentIndex: r,
      type: "path"
    });
    return {
      ...e,
      path: n,
      tokens: i
    };
  },
  pushPositional: (e, t, r) => {
    var n = e.positionals.concat({
      value: t,
      extra: !1
    });
    var i = e.tokens.concat({
      segmentIndex: r,
      type: "positional"
    });
    return {
      ...e,
      positionals: n,
      tokens: i
    };
  },
  pushExtra: (e, t, r) => {
    var n = e.positionals.concat({
      value: t,
      extra: !0
    });
    var i = e.tokens.concat({
      segmentIndex: r,
      type: "positional"
    });
    return {
      ...e,
      positionals: n,
      tokens: i
    };
  },
  pushExtraNoLimits: (e, t, r) => {
    var n = e.positionals.concat({
      value: t,
      extra: ee
    });
    var i = e.tokens.concat({
      segmentIndex: r,
      type: "positional"
    });
    return {
      ...e,
      positionals: n,
      tokens: i
    };
  },
  pushTrue: (e, t, r, n) => {
    var i = e.options.concat({
      name: n,
      value: !0
    });
    var a = e.tokens.concat({
      segmentIndex: r,
      type: "option",
      option: n
    });
    return {
      ...e,
      options: i,
      tokens: a
    };
  },
  pushFalse: (e, t, r, n) => {
    var i = e.options.concat({
      name: n,
      value: !1
    });
    var a = e.tokens.concat({
      segmentIndex: r,
      type: "option",
      option: n
    });
    return {
      ...e,
      options: i,
      tokens: a
    };
  },
  pushUndefined: (e, t, r, n) => {
    var i = e.options.concat({
      name: t,
      value: void 0
    });
    var a = e.tokens.concat({
      segmentIndex: r,
      type: "option",
      option: t
    });
    return {
      ...e,
      options: i,
      tokens: a
    };
  },
  pushStringValue: (e, t, r) => {
    var n;
    var i = e.options[e.options.length - 1];
    var a = e.options.slice();
    var s = e.tokens.concat({
      segmentIndex: r,
      type: "value"
    });
    i.value = (null !== (n = i.value) && void 0 !== n ? n : []).concat([ t ]);
    return {
      ...e,
      options: a,
      tokens: s
    };
  },
  setStringValue: (e, t, r) => {
    var n = e.options[e.options.length - 1];
    var i = e.options.slice();
    var a = e.tokens.concat({
      segmentIndex: r,
      type: "value"
    });
    n.value = t;
    return {
      ...e,
      options: i,
      tokens: a
    };
  },
  inhibateOptions: e => ({
    ...e,
    ignoreOptions: !0
  }),
  useHelp: (e, t, r, n) => {
    var [, , i] = t.match(M);
    if (void 0 !== i) {
      return {
        ...e,
        options: [ {
          name: "-c",
          value: String(n)
        }, {
          name: "-i",
          value: i
        } ]
      };
    } else {
      return {
        ...e,
        options: [ {
          name: "-c",
          value: String(n)
        } ]
      };
    }
  },
  setError: (e, t, r, n) => {
    if (t === O.EndOfInput || t === O.EndOfPartialInput) {
      return {
        ...e,
        errorMessage: `${n}.`
      };
    } else {
      return {
        ...e,
        errorMessage: `${n} ("${t}").`
      };
    }
  },
  setOptionArityError: (e, t) => {
    var r = e.options[e.options.length - 1];
    return {
      ...e,
      errorMessage: `Not enough arguments to option ${r.name}.`
    };
  }
};

var ee = Symbol();

class CommandBuilder {
  constructor(e, t) {
    this.allOptionNames = new Map;
    this.arity = {
      leading: [],
      trailing: [],
      extra: [],
      proxy: !1
    };
    this.options = [];
    this.paths = [];
    this.cliIndex = e;
    this.cliOpts = t;
  }
  addPath(e) {
    this.paths.push(e);
  }
  setArity({leading: e = this.arity.leading, trailing: t = this.arity.trailing, extra: r = this.arity.extra, proxy: n = this.arity.proxy}) {
    Object.assign(this.arity, {
      leading: e,
      trailing: t,
      extra: r,
      proxy: n
    });
  }
  addPositional({name: e = "arg", required: t = !0} = {}) {
    if (!t && this.arity.extra === ee) {
      throw new Error("Optional parameters cannot be declared when using .rest() or .proxy()");
    }
    if (!t && this.arity.trailing.length > 0) {
      throw new Error("Optional parameters cannot be declared after the required trailing positional arguments");
    }
    if (!t && this.arity.extra !== ee) {
      this.arity.extra.push(e);
    } else if (this.arity.extra !== ee && 0 === this.arity.extra.length) {
      this.arity.leading.push(e);
    } else {
      this.arity.trailing.push(e);
    }
  }
  addRest({name: e = "arg", required: t = 0} = {}) {
    if (this.arity.extra === ee) {
      throw new Error("Infinite lists cannot be declared multiple times in the same command");
    }
    if (this.arity.trailing.length > 0) {
      throw new Error("Infinite lists cannot be declared after the required trailing positional arguments");
    }
    for (var r = 0; r < t; ++r) {
      this.addPositional({
        name: e
      });
    }
    this.arity.extra = ee;
  }
  addProxy({required: e = 0} = {}) {
    this.addRest({
      required: e
    });
    this.arity.proxy = !0;
  }
  addOption({names: e, description: t, arity: r = 0, hidden: n = !1, required: i = !1, allowBinding: a = !0}) {
    if (!a && r > 1) {
      throw new Error("The arity cannot be higher than 1 when the option only supports the --arg=value syntax");
    }
    if (!Number.isInteger(r)) {
      throw new Error(`The arity must be an integer, got ${r}`);
    }
    if (r < 0) {
      throw new Error(`The arity must be positive, got ${r}`);
    }
    var s = e.reduce(((e, t) => t.length > e.length ? t : e), "");
    for (var D of e) {
      this.allOptionNames.set(D, s);
    }
    this.options.push({
      preferredName: s,
      nameSet: e,
      description: t,
      arity: r,
      hidden: n,
      required: i,
      allowBinding: a
    });
  }
  setContext(e) {
    this.context = e;
  }
  usage({detailed: e = !0, inlineOptions: t = !0} = {}) {
    var r = [ this.cliOpts.binaryName ];
    var n = [];
    if (this.paths.length > 0) {
      r.push(...this.paths[0]);
    }
    if (e) {
      for (var {preferredName: i, nameSet: a, arity: s, hidden: D, description: c, required: l} of this.options) {
        if (D) {
          continue;
        }
        var d = [];
        for (var f = 0; f < s; ++f) {
          d.push(` #${f}`);
        }
        var p = `${a.join(",")}${d.join("")}`;
        if (!t && c) {
          n.push({
            preferredName: i,
            nameSet: a,
            definition: p,
            description: c,
            required: l
          });
        } else {
          r.push(l ? `<${p}>` : `[${p}]`);
        }
      }
      r.push(...this.arity.leading.map((e => `<${e}>`)));
      if (this.arity.extra === ee) {
        r.push("...");
      } else {
        r.push(...this.arity.extra.map((e => `[${e}]`)));
      }
      r.push(...this.arity.trailing.map((e => `<${e}>`)));
    }
    return {
      usage: r.join(" "),
      options: n
    };
  }
  compile() {
    if (void 0 === this.context) {
      throw new Error("Assertion failed: No context attached");
    }
    var e = makeStateMachine();
    var t;
    var r = this.usage().usage;
    var n = this.options.filter((e => e.required)).map((e => e.nameSet));
    t = injectNode(e, {
      dynamics: [],
      shortcuts: [],
      statics: {}
    });
    registerStatic(e, k.InitialNode, O.StartOfInput, t, [ "setCandidateState", {
      candidateUsage: r,
      requiredOptions: n
    } ]);
    var i = this.arity.proxy ? "always" : "isNotOptionLike";
    var a = this.paths.length > 0 ? this.paths : [ [] ];
    for (var s of a) {
      var D = t;
      if (s.length > 0) {
        var c = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        registerShortcut(e, D, c);
        this.registerOptions(e, c);
        D = c;
      }
      for (var l = 0; l < s.length; ++l) {
        var d = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        registerStatic(e, D, s[l], d, "pushPath");
        D = d;
        if (l + 1 < s.length) {
          var f = injectNode(e, {
            dynamics: [],
            shortcuts: [],
            statics: {}
          });
          registerDynamic(e, D, "isHelp", f, [ "useHelp", this.cliIndex ]);
          registerStatic(e, f, O.EndOfInput, k.SuccessNode, [ "setSelectedIndex", I ]);
        }
      }
      if (this.arity.leading.length > 0 || !this.arity.proxy) {
        var p = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        registerDynamic(e, D, "isHelp", p, [ "useHelp", this.cliIndex ]);
        registerDynamic(e, p, "always", p, "pushExtra");
        registerStatic(e, p, O.EndOfInput, k.SuccessNode, [ "setSelectedIndex", I ]);
        this.registerOptions(e, D);
      }
      if (this.arity.leading.length > 0) {
        registerStatic(e, D, O.EndOfInput, k.ErrorNode, [ "setError", "Not enough positional arguments" ]);
        registerStatic(e, D, O.EndOfPartialInput, k.SuccessNode, [ "setSelectedIndex", this.cliIndex ]);
      }
      var h = D;
      for (var m = 0; m < this.arity.leading.length; ++m) {
        var g = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        if (!this.arity.proxy || m + 1 !== this.arity.leading.length) {
          this.registerOptions(e, g);
        }
        if (this.arity.trailing.length > 0 || m + 1 !== this.arity.leading.length) {
          registerStatic(e, g, O.EndOfInput, k.ErrorNode, [ "setError", "Not enough positional arguments" ]);
          registerStatic(e, g, O.EndOfPartialInput, k.SuccessNode, [ "setSelectedIndex", this.cliIndex ]);
        }
        registerDynamic(e, h, "isNotOptionLike", g, "pushPositional");
        h = g;
      }
      var E = h;
      if (this.arity.extra === ee || this.arity.extra.length > 0) {
        var w = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        registerShortcut(e, h, w);
        if (this.arity.extra === ee) {
          var b = injectNode(e, {
            dynamics: [],
            shortcuts: [],
            statics: {}
          });
          if (!this.arity.proxy) {
            this.registerOptions(e, b);
          }
          registerDynamic(e, h, i, b, "pushExtraNoLimits");
          registerDynamic(e, b, i, b, "pushExtraNoLimits");
          registerShortcut(e, b, w);
        } else {
          for (var B = 0; B < this.arity.extra.length; ++B) {
            var S = injectNode(e, {
              dynamics: [],
              shortcuts: [],
              statics: {}
            });
            if (!this.arity.proxy || B > 0) {
              this.registerOptions(e, S);
            }
            registerDynamic(e, E, i, S, "pushExtra");
            registerShortcut(e, S, w);
            E = S;
          }
        }
        E = w;
      }
      if (this.arity.trailing.length > 0) {
        registerStatic(e, E, O.EndOfInput, k.ErrorNode, [ "setError", "Not enough positional arguments" ]);
        registerStatic(e, E, O.EndOfPartialInput, k.SuccessNode, [ "setSelectedIndex", this.cliIndex ]);
      }
      var M = E;
      for (var U = 0; U < this.arity.trailing.length; ++U) {
        var _ = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        if (!this.arity.proxy) {
          this.registerOptions(e, _);
        }
        if (U + 1 < this.arity.trailing.length) {
          registerStatic(e, _, O.EndOfInput, k.ErrorNode, [ "setError", "Not enough positional arguments" ]);
          registerStatic(e, _, O.EndOfPartialInput, k.SuccessNode, [ "setSelectedIndex", this.cliIndex ]);
        }
        registerDynamic(e, M, "isNotOptionLike", _, "pushPositional");
        M = _;
      }
      registerDynamic(e, M, i, k.ErrorNode, [ "setError", "Extraneous positional argument" ]);
      registerStatic(e, M, O.EndOfInput, k.SuccessNode, [ "setSelectedIndex", this.cliIndex ]);
      registerStatic(e, M, O.EndOfPartialInput, k.SuccessNode, [ "setSelectedIndex", this.cliIndex ]);
    }
    return {
      machine: e,
      context: this.context
    };
  }
  registerOptions(e, t) {
    registerDynamic(e, t, [ "isOption", "--" ], t, "inhibateOptions");
    registerDynamic(e, t, [ "isBatchOption", this.allOptionNames ], t, [ "pushBatch", this.allOptionNames ]);
    registerDynamic(e, t, [ "isBoundOption", this.allOptionNames, this.options ], t, "pushBound");
    registerDynamic(e, t, [ "isUnsupportedOption", this.allOptionNames ], k.ErrorNode, [ "setError", "Unsupported option name" ]);
    registerDynamic(e, t, [ "isInvalidOption" ], k.ErrorNode, [ "setError", "Invalid option name" ]);
    for (var r of this.options) {
      if (0 === r.arity) {
        for (var n of r.nameSet) {
          registerDynamic(e, t, [ "isOption", n ], t, [ "pushTrue", r.preferredName ]);
          if (n.startsWith("--") && !n.startsWith("--no-")) {
            registerDynamic(e, t, [ "isNegatedOption", n ], t, [ "pushFalse", r.preferredName ]);
          }
        }
      } else {
        var i = injectNode(e, {
          dynamics: [],
          shortcuts: [],
          statics: {}
        });
        for (var a of r.nameSet) {
          registerDynamic(e, t, [ "isOption", a ], i, [ "pushUndefined", r.preferredName ]);
        }
        for (var s = 0; s < r.arity; ++s) {
          var D = injectNode(e, {
            dynamics: [],
            shortcuts: [],
            statics: {}
          });
          registerStatic(e, i, O.EndOfInput, k.ErrorNode, "setOptionArityError");
          registerStatic(e, i, O.EndOfPartialInput, k.ErrorNode, "setOptionArityError");
          registerDynamic(e, i, "isOptionLike", k.ErrorNode, "setOptionArityError");
          registerDynamic(e, i, "isNotOptionLike", D, 1 === r.arity ? "setStringValue" : "pushStringValue");
          i = D;
        }
        registerShortcut(e, i, t);
      }
    }
  }
}

class CliBuilder {
  constructor({binaryName: e = "..."} = {}) {
    this.builders = [];
    this.opts = {
      binaryName: e
    };
  }
  static build(e, t = {}) {
    return new CliBuilder(t).commands(e).compile();
  }
  getBuilderByIndex(e) {
    if (!(e >= 0 && e < this.builders.length)) {
      throw new Error(`Assertion failed: Out-of-bound command index (${e})`);
    }
    return this.builders[e];
  }
  commands(e) {
    for (var t of e) {
      t(this.command());
    }
    return this;
  }
  command() {
    var e = new CommandBuilder(this.builders.length, this.opts);
    this.builders.push(e);
    return e;
  }
  compile() {
    var e = [];
    var t = [];
    for (var r of this.builders) {
      var {machine: n, context: i} = r.compile();
      e.push(n);
      t.push(i);
    }
    var a = function makeAnyOfMachine(e) {
      var t = makeStateMachine();
      var r = [];
      var n = t.nodes.length;
      for (var i of e) {
        r.push(n);
        for (var a = 0; a < i.nodes.length; ++a) {
          if (!isTerminalNode(a)) {
            t.nodes.push(cloneNode(i.nodes[a], n));
          }
        }
        n += i.nodes.length - k.CustomNode + 1;
      }
      for (var s of r) {
        registerShortcut(t, k.InitialNode, s);
      }
      return t;
    }(e);
    !function simplifyMachine(e) {
      var t = new Set;
      var process = r => {
        if (t.has(r)) {
          return;
        }
        t.add(r);
        var n = e.nodes[r];
        for (var i of Object.values(n.statics)) {
          for (var {to: a} of i) {
            process(a);
          }
        }
        for (var [, {to: s}] of n.dynamics) {
          process(s);
        }
        for (var {to: D} of n.shortcuts) {
          process(D);
        }
        var c = new Set(n.shortcuts.map((({to: e}) => e)));
        while (n.shortcuts.length > 0) {
          var {to: l} = n.shortcuts.shift();
          var d = e.nodes[l];
          for (var [f, p] of Object.entries(d.statics)) {
            var h = !Object.prototype.hasOwnProperty.call(n.statics, f) ? n.statics[f] = [] : n.statics[f];
            var _loop = function(e) {
              if (!h.some((({to: t}) => e.to === t))) {
                h.push(e);
              }
            };
            for (var m of p) {
              _loop(m);
            }
          }
          var _loop2 = function(e, t) {
            if (!n.dynamics.some((([r, {to: n}]) => e === r && t.to === n))) {
              n.dynamics.push([ e, t ]);
            }
          };
          for (var [g, E] of d.dynamics) {
            _loop2(g, E);
          }
          for (var w of d.shortcuts) {
            if (!c.has(w.to)) {
              n.shortcuts.push(w);
              c.add(w.to);
            }
          }
        }
      };
      process(k.InitialNode);
    }(a);
    return {
      machine: a,
      contexts: t,
      process: (e, {partial: t} = {}) => runMachine(a, e, {
        endToken: t ? O.EndOfPartialInput : O.EndOfInput
      })
    };
  }
}

class HelpCommand extends Command {
  constructor(e) {
    super();
    this.contexts = e;
    this.commands = [];
  }
  static from(e, t) {
    var r = new HelpCommand(t);
    r.path = e.path;
    for (var n of e.options) {
      switch (n.name) {
       case "-c":
        r.commands.push(Number(n.value));
        break;

       case "-i":
        r.index = Number(n.value);
      }
    }
    return r;
  }
  async execute() {
    var e = this.commands;
    if (void 0 !== this.index && this.index >= 0 && this.index < e.length) {
      e = [ e[this.index] ];
    }
    if (0 === e.length) {
      this.context.stdout.write(this.cli.usage());
    } else if (1 === e.length) {
      this.context.stdout.write(this.cli.usage(this.contexts[e[0]].commandClass, {
        detailed: !0
      }));
    } else if (e.length > 1) {
      this.context.stdout.write("Multiple commands match your selection:\n");
      this.context.stdout.write("\n");
      var t = 0;
      for (var r of this.commands) {
        this.context.stdout.write(this.cli.usage(this.contexts[r].commandClass, {
          prefix: (t++ + ". ").padStart(5)
        }));
      }
      this.context.stdout.write("\n");
      this.context.stdout.write("Run again with -h=<index> to see the longer details of any of those commands.\n");
    }
  }
}

var re = Symbol("clipanion/errorCommand");

class Cli {
  constructor({binaryLabel: e, binaryName: t = "...", binaryVersion: r, enableCapture: n = !1, enableColors: i} = {}) {
    this.registrations = new Map;
    this.builder = new CliBuilder({
      binaryName: t
    });
    this.binaryLabel = e;
    this.binaryName = t;
    this.binaryVersion = r;
    this.enableCapture = n;
    this.enableColors = i;
  }
  static from(e, t = {}) {
    var r = new Cli(t);
    var n = Array.isArray(e) ? e : [ e ];
    for (var i of n) {
      r.register(i);
    }
    return r;
  }
  register(e) {
    var t;
    var r = new Map;
    var n = new e;
    for (var i in n) {
      var a = n[i];
      if ("object" == typeof a && null !== a && a[Command.isOption]) {
        r.set(i, a);
      }
    }
    var s = this.builder.command();
    var D = s.cliIndex;
    var c = null !== (t = e.paths) && void 0 !== t ? t : n.paths;
    if (void 0 !== c) {
      for (var l of c) {
        s.addPath(l);
      }
    }
    this.registrations.set(e, {
      specs: r,
      builder: s,
      index: D
    });
    for (var [d, {definition: f}] of r.entries()) {
      f(s, d);
    }
    s.setContext({
      commandClass: e
    });
  }
  process(e, t) {
    var {input: r, context: n, partial: i} = "object" == typeof e && Array.isArray(e) ? {
      input: e,
      context: t
    } : e;
    var {contexts: a, process: s} = this.builder.compile();
    var D = s(r, {
      partial: i
    });
    var c = {
      ...Cli.defaultContext,
      ...n
    };
    if (D.selectedIndex === I) {
      var l = HelpCommand.from(D, a);
      l.context = c;
      l.tokens = D.tokens;
      return l;
    } else {
      var {commandClass: d} = a[D.selectedIndex];
      var f = this.registrations.get(d);
      if (void 0 === f) {
        throw new Error("Assertion failed: Expected the command class to have been registered.");
      }
      var p = new d;
      p.context = c;
      p.tokens = D.tokens;
      p.path = D.path;
      try {
        for (var [h, {transformer: m}] of f.specs.entries()) {
          p[h] = m(f.builder, h, D, c);
        }
        return p;
      } catch (e) {
        e[re] = p;
        throw e;
      }
    }
  }
  async run(e, t) {
    var r, n;
    var i;
    var a = {
      ...Cli.defaultContext,
      ...t
    };
    var s = null !== (r = this.enableColors) && void 0 !== r ? r : a.colorDepth > 1;
    if (!Array.isArray(e)) {
      i = e;
    } else {
      try {
        i = this.process(e, a);
      } catch (e) {
        a.stdout.write(this.error(e, {
          colored: s
        }));
        return 1;
      }
    }
    if (i.help) {
      a.stdout.write(this.usage(i, {
        colored: s,
        detailed: !0
      }));
      return 0;
    }
    i.context = a;
    i.cli = {
      binaryLabel: this.binaryLabel,
      binaryName: this.binaryName,
      binaryVersion: this.binaryVersion,
      enableCapture: this.enableCapture,
      enableColors: this.enableColors,
      definitions: () => this.definitions(),
      definition: e => this.definition(e),
      error: (e, t) => this.error(e, t),
      format: e => this.format(e),
      process: (e, t) => this.process(e, {
        ...a,
        ...t
      }),
      run: (e, t) => this.run(e, {
        ...a,
        ...t
      }),
      usage: (e, t) => this.usage(e, t)
    };
    var D = this.enableCapture ? null !== (n = function getCaptureActivator() {
      throw new Error("The enableCapture option cannot be used from within a browser environment");
    }()) && void 0 !== n ? n : noopCaptureActivator : noopCaptureActivator;
    var c;
    try {
      c = await D((() => i.validateAndExecute().catch((e => i.catch(e).then((() => 0))))));
    } catch (e) {
      a.stdout.write(this.error(e, {
        colored: s,
        command: i
      }));
      return 1;
    }
    return c;
  }
  async runExit(e, t) {
    process.exitCode = await this.run(e, t);
  }
  definition(e, {colored: t = !1} = {}) {
    if (!e.usage) {
      return null;
    }
    var {usage: r} = this.getUsageByRegistration(e, {
      detailed: !1
    });
    var {usage: n, options: i} = this.getUsageByRegistration(e, {
      detailed: !0,
      inlineOptions: !1
    });
    return {
      path: r,
      usage: n,
      category: void 0 !== e.usage.category ? formatMarkdownish(e.usage.category, {
        format: this.format(t),
        paragraphs: !1
      }) : void 0,
      description: void 0 !== e.usage.description ? formatMarkdownish(e.usage.description, {
        format: this.format(t),
        paragraphs: !1
      }) : void 0,
      details: void 0 !== e.usage.details ? formatMarkdownish(e.usage.details, {
        format: this.format(t),
        paragraphs: !0
      }) : void 0,
      examples: void 0 !== e.usage.examples ? e.usage.examples.map((([e, r]) => [ formatMarkdownish(e, {
        format: this.format(t),
        paragraphs: !1
      }), r.replace(/\$0/g, this.binaryName) ])) : void 0,
      options: i
    };
  }
  definitions({colored: e = !1} = {}) {
    var t = [];
    for (var r of this.registrations.keys()) {
      var n = this.definition(r, {
        colored: e
      });
      if (!n) {
        continue;
      }
      t.push(n);
    }
    return t;
  }
  usage(e = null, {colored: t, detailed: r = !1, prefix: n = "$ "} = {}) {
    var i;
    if (null === e) {
      for (var a of this.registrations.keys()) {
        var s = a.paths;
        var D = void 0 !== a.usage;
        var c = !s || 0 === s.length || 1 === s.length && 0 === s[0].length || (null !== (i = null == s ? void 0 : s.some((e => 0 === e.length))) && void 0 !== i ? i : !1);
        if (c) {
          if (e) {
            e = null;
            break;
          } else {
            e = a;
          }
        } else if (D) {
          e = null;
          continue;
        }
      }
      if (e) {
        r = !0;
      }
    }
    var l = null !== e && e instanceof Command ? e.constructor : e;
    var d = "";
    if (!l) {
      var f = new Map;
      for (var [p, {index: h}] of this.registrations.entries()) {
        if (void 0 === p.usage) {
          continue;
        }
        var m = void 0 !== p.usage.category ? formatMarkdownish(p.usage.category, {
          format: this.format(t),
          paragraphs: !1
        }) : null;
        var g = f.get(m);
        if (void 0 === g) {
          f.set(m, g = []);
        }
        var {usage: E} = this.getUsageByIndex(h);
        g.push({
          commandClass: p,
          usage: E
        });
      }
      var w = Array.from(f.keys()).sort(((e, t) => {
        if (null === e) {
          return -1;
        }
        if (null === t) {
          return 1;
        }
        return e.localeCompare(t, "en", {
          usage: "sort",
          caseFirst: "upper"
        });
      }));
      var b = void 0 !== this.binaryLabel;
      var B = void 0 !== this.binaryVersion;
      if (b || B) {
        if (b && B) {
          d += `${this.format(t).header(`${this.binaryLabel} - ${this.binaryVersion}`)}\n\n`;
        } else if (b) {
          d += `${this.format(t).header(`${this.binaryLabel}`)}\n`;
        } else {
          d += `${this.format(t).header(`${this.binaryVersion}`)}\n`;
        }
        d += `  ${this.format(t).bold(n)}${this.binaryName} <command>\n`;
      } else {
        d += `${this.format(t).bold(n)}${this.binaryName} <command>\n`;
      }
      for (var S of w) {
        var O = f.get(S).slice().sort(((e, t) => e.usage.localeCompare(t.usage, "en", {
          usage: "sort",
          caseFirst: "upper"
        })));
        var k = null !== S ? S.trim() : "General commands";
        d += "\n";
        d += `${this.format(t).header(`${k}`)}\n`;
        for (var {commandClass: I, usage: M} of O) {
          var U = I.usage.description || "undocumented";
          d += "\n";
          d += `  ${this.format(t).bold(M)}\n`;
          d += `    ${formatMarkdownish(U, {
            format: this.format(t),
            paragraphs: !1
          })}`;
        }
      }
      d += "\n";
      d += formatMarkdownish("You can also print more details about any of these commands by calling them with the `-h,--help` flag right after the command name.", {
        format: this.format(t),
        paragraphs: !0
      });
    } else if (!r) {
      var {usage: _} = this.getUsageByRegistration(l);
      d += `${this.format(t).bold(n)}${_}\n`;
    } else {
      var {description: G = "", details: V = "", examples: H = []} = l.usage || {};
      if ("" !== G) {
        d += formatMarkdownish(G, {
          format: this.format(t),
          paragraphs: !1
        }).replace(/^./, (e => e.toUpperCase()));
        d += "\n";
      }
      if ("" !== V || H.length > 0) {
        d += `${this.format(t).header("Usage")}\n`;
        d += "\n";
      }
      var {usage: K, options: Y} = this.getUsageByRegistration(l, {
        inlineOptions: !1
      });
      d += `${this.format(t).bold(n)}${K}\n`;
      if (Y.length > 0) {
        d += "\n";
        d += `${this.format(t).header("Options")}\n`;
        var z = Y.reduce(((e, t) => Math.max(e, t.definition.length)), 0);
        d += "\n";
        for (var {definition: J, description: Z} of Y) {
          d += `  ${this.format(t).bold(J.padEnd(z))}    ${formatMarkdownish(Z, {
            format: this.format(t),
            paragraphs: !1
          })}`;
        }
      }
      if ("" !== V) {
        d += "\n";
        d += `${this.format(t).header("Details")}\n`;
        d += "\n";
        d += formatMarkdownish(V, {
          format: this.format(t),
          paragraphs: !0
        });
      }
      if (H.length > 0) {
        d += "\n";
        d += `${this.format(t).header("Examples")}\n`;
        for (var [X, Q] of H) {
          d += "\n";
          d += formatMarkdownish(X, {
            format: this.format(t),
            paragraphs: !1
          });
          d += `${Q.replace(/^/m, `  ${this.format(t).bold(n)}`).replace(/\$0/g, this.binaryName)}\n`;
        }
      }
    }
    return d;
  }
  error(e, t) {
    var r;
    var {colored: n, command: i = (null !== (r = e[re]) && void 0 !== r ? r : null)} = void 0 === t ? {} : t;
    if (!e || "object" != typeof e || !("stack" in e)) {
      e = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(e)})`);
    }
    var a = "";
    var s = e.name.replace(/([a-z])([A-Z])/g, "$1 $2");
    if ("Error" === s) {
      s = "Internal Error";
    }
    a += `${this.format(n).error(s)}: ${e.message}\n`;
    var D = e.clipanion;
    if (void 0 !== D) {
      if ("usage" === D.type) {
        a += "\n";
        a += this.usage(i);
      }
    } else if (e.stack) {
      a += `${e.stack.replace(/^.*\n/, "")}\n`;
    }
    return a;
  }
  format(e) {
    var t;
    return (null !== (t = null != e ? e : this.enableColors) && void 0 !== t ? t : Cli.defaultContext.colorDepth > 1) ? Y : z;
  }
  getUsageByRegistration(e, t) {
    var r = this.registrations.get(e);
    if (void 0 === r) {
      throw new Error("Assertion failed: Unregistered command");
    }
    return this.getUsageByIndex(r.index, t);
  }
  getUsageByIndex(e, t) {
    return this.builder.getBuilderByIndex(e).usage(t);
  }
}

Cli.defaultContext = {
  env: process.env,
  stdin: process.stdin,
  stdout: process.stdout,
  stderr: process.stderr,
  colorDepth: 1
};

function noopCaptureActivator(e) {
  return e();
}

function Boolean$1(e, t, r) {
  var [n, i] = rerouteArguments(t, null != r ? r : {});
  var a = e.split(",");
  var s = new Set(a);
  return makeCommandOption({
    definition(e) {
      e.addOption({
        names: a,
        allowBinding: !1,
        arity: 0,
        hidden: i.hidden,
        description: i.description,
        required: i.required
      });
    },
    transformer(e, t, r) {
      var i = n;
      for (var {name: a, value: D} of r.options) {
        if (!s.has(a)) {
          continue;
        }
        i = D;
      }
      return i;
    }
  });
}

function String$1(e, ...t) {
  if ("string" == typeof e) {
    return function StringOption(e, t, r) {
      var [n, i] = rerouteArguments(t, null != r ? r : {});
      var {arity: a = 1} = i;
      var s = e.split(",");
      var D = new Set(s);
      return makeCommandOption({
        definition(e) {
          e.addOption({
            names: s,
            arity: i.tolerateBoolean ? 0 : a,
            hidden: i.hidden,
            description: i.description,
            required: i.required
          });
        },
        transformer(e, t, r, a) {
          var s;
          var c = n;
          if (void 0 !== i.env && a.env[i.env]) {
            s = i.env;
            c = a.env[i.env];
          }
          for (var {name: l, value: d} of r.options) {
            if (!D.has(l)) {
              continue;
            }
            s = l;
            c = d;
          }
          if ("string" == typeof c) {
            return applyValidator(null != s ? s : t, c, i.validator);
          } else {
            return c;
          }
        }
      });
    }(e, ...t);
  } else {
    return function StringPositional(e = {}) {
      var {required: t = !0} = e;
      return makeCommandOption({
        definition(t, r) {
          var n;
          t.addPositional({
            name: null !== (n = e.name) && void 0 !== n ? n : r,
            required: e.required
          });
        },
        transformer(r, n, i) {
          var a;
          for (var s = 0; s < i.positionals.length; ++s) {
            if (i.positionals[s].extra === ee) {
              continue;
            }
            if (t && !0 === i.positionals[s].extra) {
              continue;
            }
            if (!t && !1 === i.positionals[s].extra) {
              continue;
            }
            var [D] = i.positionals.splice(s, 1);
            return applyValidator(null !== (a = e.name) && void 0 !== a ? a : n, D.value, e.validator);
          }
          return;
        }
      });
    }(e);
  }
}

var e$1 = () => {};

function start(e) {
  return {
    tag: 0,
    0: e
  };
}

function push(e) {
  return {
    tag: 1,
    0: e
  };
}

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

var identity$1 = e => e;

function concatMap(e) {
  return t => r => {
    var n = [];
    var i = e$1;
    var a = e$1;
    var s = !1;
    var D = !1;
    var c = !1;
    var l = !1;
    function applyInnerSource(t) {
      c = !0;
      t((t => {
        if (0 === t) {
          if (c) {
            c = !1;
            if (n.length) {
              applyInnerSource(e(n.shift()));
            } else if (l) {
              r(0);
            } else if (!s) {
              s = !0;
              i(0);
            }
          }
        } else if (0 === t.tag) {
          D = !1;
          (a = t[0])(0);
        } else if (c) {
          r(t);
          if (D) {
            D = !1;
          } else {
            a(0);
          }
        }
      }));
    }
    t((t => {
      if (l) {} else if (0 === t) {
        l = !0;
        if (!c && !n.length) {
          r(0);
        }
      } else if (0 === t.tag) {
        i = t[0];
      } else {
        s = !1;
        if (c) {
          n.push(t[0]);
        } else {
          applyInnerSource(e(t[0]));
        }
      }
    }));
    r(start((e => {
      if (1 === e) {
        if (!l) {
          l = !0;
          i(1);
        }
        if (c) {
          c = !1;
          a(1);
        }
      } else {
        if (!l && !s) {
          s = !0;
          i(0);
        }
        if (c && !D) {
          D = !0;
          a(0);
        }
      }
    })));
  };
}

function concat(e) {
  return function concatAll(e) {
    return concatMap(identity$1)(e);
  }(ne(e));
}

function filter(e) {
  return t => r => {
    var n = e$1;
    t((t => {
      if (0 === t) {
        r(0);
      } else if (0 === t.tag) {
        n = t[0];
        r(t);
      } else if (!e(t[0])) {
        n(0);
      } else {
        r(t);
      }
    }));
  };
}

function map(e) {
  return t => r => t((t => {
    if (0 === t || 0 === t.tag) {
      r(t);
    } else {
      r(push(e(t[0])));
    }
  }));
}

function mergeAll(e) {
  return function mergeMap(e) {
    return t => r => {
      var n = [];
      var i = e$1;
      var a = !1;
      var s = !1;
      t((t => {
        if (s) {} else if (0 === t) {
          s = !0;
          if (!n.length) {
            r(0);
          }
        } else if (0 === t.tag) {
          i = t[0];
        } else {
          a = !1;
          !function applyInnerSource(e) {
            var t = e$1;
            e((e => {
              if (0 === e) {
                if (n.length) {
                  var D = n.indexOf(t);
                  if (D > -1) {
                    (n = n.slice()).splice(D, 1);
                  }
                  if (!n.length) {
                    if (s) {
                      r(0);
                    } else if (!a) {
                      a = !0;
                      i(0);
                    }
                  }
                }
              } else if (0 === e.tag) {
                n.push(t = e[0]);
                t(0);
              } else if (n.length) {
                r(e);
                t(0);
              }
            }));
          }(e(t[0]));
          if (!a) {
            a = !0;
            i(0);
          }
        }
      }));
      r(start((e => {
        if (1 === e) {
          if (!s) {
            s = !0;
            i(1);
          }
          for (var t = 0, r = n, D = n.length; t < D; t++) {
            r[t](1);
          }
          n.length = 0;
        } else {
          if (!s && !a) {
            a = !0;
            i(0);
          } else {
            a = !1;
          }
          for (var c = 0, l = n, d = n.length; c < d; c++) {
            l[c](0);
          }
        }
      })));
    };
  }(identity$1)(e);
}

function merge(e) {
  return mergeAll(ne(e));
}

function onEnd(e) {
  return t => r => {
    var n = !1;
    t((t => {
      if (n) {} else if (0 === t) {
        n = !0;
        r(0);
        e();
      } else if (0 === t.tag) {
        var i = t[0];
        r(start((t => {
          if (1 === t) {
            n = !0;
            i(1);
            e();
          } else {
            i(t);
          }
        })));
      } else {
        r(t);
      }
    }));
  };
}

function onPush(e) {
  return t => r => {
    var n = !1;
    t((t => {
      if (n) {} else if (0 === t) {
        n = !0;
        r(0);
      } else if (0 === t.tag) {
        var i = t[0];
        r(start((e => {
          if (1 === e) {
            n = !0;
          }
          i(e);
        })));
      } else {
        e(t[0]);
        r(t);
      }
    }));
  };
}

function share(e) {
  var t = [];
  var r = e$1;
  var n = !1;
  return i => {
    t.push(i);
    if (1 === t.length) {
      e((e => {
        if (0 === e) {
          for (var i = 0, a = t, s = t.length; i < s; i++) {
            a[i](0);
          }
          t.length = 0;
        } else if (0 === e.tag) {
          r = e[0];
        } else {
          n = !1;
          for (var D = 0, c = t, l = t.length; D < l; D++) {
            c[D](e);
          }
        }
      }));
    }
    i(start((e => {
      if (1 === e) {
        var a = t.indexOf(i);
        if (a > -1) {
          (t = t.slice()).splice(a, 1);
        }
        if (!t.length) {
          r(1);
        }
      } else if (!n) {
        n = !0;
        r(0);
      }
    })));
  };
}

function takeLast(e) {
  return t => r => {
    var n = [];
    var i = e$1;
    t((t => {
      if (0 === t) {
        ne(n)(r);
      } else if (0 === t.tag) {
        if (e <= 0) {
          t[0](1);
          ne(n)(r);
        } else {
          (i = t[0])(0);
        }
      } else {
        if (n.length >= e && e) {
          n.shift();
        }
        n.push(t[0]);
        i(0);
      }
    }));
  };
}

function takeUntil(e) {
  return t => r => {
    var n = e$1;
    var i = e$1;
    var a = !1;
    t((t => {
      if (a) {} else if (0 === t) {
        a = !0;
        i(1);
        r(0);
      } else if (0 === t.tag) {
        n = t[0];
        e((e => {
          if (0 === e) {} else if (0 === e.tag) {
            (i = e[0])(0);
          } else {
            a = !0;
            i(1);
            n(1);
            r(0);
          }
        }));
      } else {
        r(t);
      }
    }));
    r(start((e => {
      if (1 === e && !a) {
        a = !0;
        n(1);
        i(1);
      } else if (!a) {
        n(0);
      }
    })));
  };
}

function fromAsyncIterable(e) {
  return t => {
    var r = e[asyncIteratorSymbol()] && e[asyncIteratorSymbol()]() || e;
    var n = !1;
    var i = !1;
    var a = !1;
    var s;
    t(start((async e => {
      if (1 === e) {
        n = !0;
        if (r.return) {
          r.return();
        }
      } else if (i) {
        a = !0;
      } else {
        for (a = i = !0; a && !n; ) {
          if ((s = await r.next()).done) {
            n = !0;
            if (r.return) {
              await r.return();
            }
            t(0);
          } else {
            try {
              a = !1;
              t(push(s.value));
            } catch (e) {
              if (r.throw) {
                if (n = !!(await r.throw(e)).done) {
                  t(0);
                }
              } else {
                throw e;
              }
            }
          }
        }
        i = !1;
      }
    })));
  };
}

var ne = function fromIterable(e) {
  if (e[Symbol.asyncIterator]) {
    return fromAsyncIterable(e);
  }
  return t => {
    var r = e[Symbol.iterator]();
    var n = !1;
    var i = !1;
    var a = !1;
    var s;
    t(start((e => {
      if (1 === e) {
        n = !0;
        if (r.return) {
          r.return();
        }
      } else if (i) {
        a = !0;
      } else {
        for (a = i = !0; a && !n; ) {
          if ((s = r.next()).done) {
            n = !0;
            if (r.return) {
              r.return();
            }
            t(0);
          } else {
            try {
              a = !1;
              t(push(s.value));
            } catch (e) {
              if (r.throw) {
                if (n = !!r.throw(e).done) {
                  t(0);
                }
              } else {
                throw e;
              }
            }
          }
        }
        i = !1;
      }
    })));
  };
};

function fromValue(e) {
  return t => {
    var r = !1;
    t(start((n => {
      if (1 === n) {
        r = !0;
      } else if (!r) {
        r = !0;
        t(push(e));
        t(0);
      }
    })));
  };
}

function make(e) {
  return t => {
    var r = !1;
    var n = e({
      next(e) {
        if (!r) {
          t(push(e));
        }
      },
      complete() {
        if (!r) {
          r = !0;
          t(0);
        }
      }
    });
    t(start((e => {
      if (1 === e && !r) {
        r = !0;
        n();
      }
    })));
  };
}

var never = e => {
  e(start(e$1));
};

function interval(e) {
  return make((t => {
    var r = 0;
    var n = setInterval((() => t.next(r++)), e);
    return () => clearInterval(n);
  }));
}

function toPromise(e) {
  return new Promise((t => {
    var r = e$1;
    var n;
    e((e => {
      if (0 === e) {
        Promise.resolve(n).then(t);
      } else if (0 === e.tag) {
        (r = e[0])(0);
      } else {
        n = e[0];
        r(0);
      }
    }));
  }));
}

var pipe = (...e) => {
  var t = e[0];
  for (var r = 1, n = e.length; r < n; r++) {
    t = e[r](t);
  }
  return t;
};

var ie = !1;

function _setColor(e) {
  ie = e;
}

var ae = function(e) {
  e.InsertChars = "@";
  e.ScrollLeft = "SP@";
  e.Up = "A";
  e.ScrollRight = "SPA";
  e.Down = "B";
  e.Forward = "C";
  e.Backward = "D";
  e.NextLine = "E";
  e.PrevLine = "F";
  e.ToColumn = "G";
  e.ToPosition = "H";
  e.Tab = "I";
  e.Erase = "J";
  e.EraseLine = "K";
  e.InsertLines = "L";
  e.DeleteLines = "M";
  e.DeleteChars = "P";
  e.ScrollUp = "S";
  e.ScrollDown = "T";
  e.EraseChars = "X";
  e.TabBackwards = "Z";
  e.RepeatChar = "b";
  e.ToRow = "d";
  e.DownLine = "e";
  e.TabClear = "g";
  e.SetMode = "h";
  e.UnsetMode = "l";
  e.SetPrivateMode = "?h";
  e.UnsetPrivateMode = "?l";
  e.ResetPrivateMode = "?r";
  e.Style = "m";
  e.Reset = "!p";
  e.Protect = '"q';
  e.Cursor = "SPq";
  e.SetMargin = "r";
  e.SaveCursor = "s";
  e.RestoreCursor = "u";
  e.InsertColumns = "'}";
  e.DeleteColumns = "'~";
  return e;
}(ae || {});

var oe = function(e) {
  e[e.Forward = 0] = "Forward";
  e[e.Backward = 1] = "Backward";
  e[e.All = 2] = "All";
  return e;
}(oe || {});

var De = function(e) {
  e[e.Insert = 4] = "Insert";
  e[e.AutomaticNewline = 20] = "AutomaticNewline";
  return e;
}(De || {});

var ce = function(e) {
  e[e.AppCursorKeys = 1] = "AppCursorKeys";
  e[e.USASCII = 2] = "USASCII";
  e[e.Column132 = 3] = "Column132";
  e[e.OriginMode = 6] = "OriginMode";
  e[e.AutoWrap = 7] = "AutoWrap";
  e[e.AutoRepeat = 8] = "AutoRepeat";
  e[e.X10Mouse = 9] = "X10Mouse";
  e[e.BlinkCursor = 12] = "BlinkCursor";
  e[e.ShowCursor = 25] = "ShowCursor";
  e[e.ReverseWrapAround = 45] = "ReverseWrapAround";
  e[e.AlternativeScreenBuffer = 47] = "AlternativeScreenBuffer";
  e[e.AppKeypad = 66] = "AppKeypad";
  e[e.X11Mouse = 1e3] = "X11Mouse";
  e[e.CellMotionMouseTracking = 1002] = "CellMotionMouseTracking";
  e[e.AllMotionMouseTracking = 1003] = "AllMotionMouseTracking";
  e[e.FocusEvents = 1004] = "FocusEvents";
  e[e.Utf8Mouse = 1005] = "Utf8Mouse";
  e[e.SGRMouse = 1006] = "SGRMouse";
  e[e.UrxvtMouse = 1015] = "UrxvtMouse";
  e[e.SGRPixelsMouse = 1016] = "SGRPixelsMouse";
  e[e.SaveCursor = 1048] = "SaveCursor";
  e[e.BracketedPaste = 2004] = "BracketedPaste";
  return e;
}(ce || {});

var le = function(e) {
  e[e.Reset = 0] = "Reset";
  e[e.Bold = 1] = "Bold";
  e[e.Faint = 2] = "Faint";
  e[e.Italic = 3] = "Italic";
  e[e.Underline = 4] = "Underline";
  e[e.Blink = 5] = "Blink";
  e[e.RapidBlink = 6] = "RapidBlink";
  e[e.Invert = 7] = "Invert";
  e[e.Invisible = 8] = "Invisible";
  e[e.Strikethrough = 9] = "Strikethrough";
  e[e.DoubleUnderlined = 21] = "DoubleUnderlined";
  e[e.Normal = 22] = "Normal";
  e[e.NoItalic = 23] = "NoItalic";
  e[e.NoUnderline = 24] = "NoUnderline";
  e[e.NoBlink = 25] = "NoBlink";
  e[e.NoInvert = 27] = "NoInvert";
  e[e.Visible = 28] = "Visible";
  e[e.NoStrikethrough = 29] = "NoStrikethrough";
  e[e.Black = 30] = "Black";
  e[e.Red = 31] = "Red";
  e[e.Green = 32] = "Green";
  e[e.Yellow = 33] = "Yellow";
  e[e.Blue = 34] = "Blue";
  e[e.Magenta = 35] = "Magenta";
  e[e.Cyan = 36] = "Cyan";
  e[e.White = 37] = "White";
  e[e.Foreground = 39] = "Foreground";
  e[e.OnBlack = 40] = "OnBlack";
  e[e.OnRed = 41] = "OnRed";
  e[e.OnGreen = 42] = "OnGreen";
  e[e.OnYellow = 43] = "OnYellow";
  e[e.OnBlue = 44] = "OnBlue";
  e[e.OnMagenta = 45] = "OnMagenta";
  e[e.OnCyan = 46] = "OnCyan";
  e[e.OnWhite = 47] = "OnWhite";
  e[e.OnBackground = 49] = "OnBackground";
  e[e.BrightBlack = 90] = "BrightBlack";
  e[e.BrightRed = 91] = "BrightRed";
  e[e.BrightGreen = 92] = "BrightGreen";
  e[e.BrightYellow = 93] = "BrightYellow";
  e[e.BrightBlue = 94] = "BrightBlue";
  e[e.BrightMagenta = 95] = "BrightMagenta";
  e[e.BrightCyan = 96] = "BrightCyan";
  e[e.BrightWhite = 97] = "BrightWhite";
  e[e.OnBrightBlack = 100] = "OnBrightBlack";
  e[e.OnBrightRed = 101] = "OnBrightRed";
  e[e.OnBrightGreen = 102] = "OnBrightGreen";
  e[e.OnBrightYellow = 103] = "OnBrightYellow";
  e[e.OnBrightBlue = 104] = "OnBrightBlue";
  e[e.OnBrightMagenta = 105] = "OnBrightMagenta";
  e[e.OnBrightCyan = 106] = "OnBrightCyan";
  e[e.OnBrightWhite = 107] = "OnBrightWhite";
  e.DoubleUnderline = "4:2";
  e.CurlyUnderline = "4:3";
  e.DottedUnderline = "4:4";
  e.DashedUnderline = "4:5";
  return e;
}(le || {});

var de = "[";

function cmd(e, t, r) {
  if (!ie && e === ae.Style) {
    return "";
  }
  var n = de;
  if (e === ae.SetPrivateMode) {
    n += "?";
    e = ae.SetMode;
  } else if (e === ae.UnsetPrivateMode) {
    n += "?";
    e = ae.UnsetMode;
  }
  if (Array.isArray(t)) {
    n += t.join(";");
  } else if (null != t) {
    n += `${t}`;
    if (null != r) {
      n += `;${r}`;
    }
  }
  return n += e;
}

var fe = /([\x1B\x9B][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><])/g;

var stripAnsi = e => e.replace(fe, "");

class CLIError extends Error {
  constructor(e, t) {
    super(stripAnsi(e));
    this.output = e;
    this.exit = null != t ? t : 1;
  }
  toString() {
    return this.output;
  }
}

function text(e, ...t) {
  var r = "";
  if (Array.isArray(e)) {
    var n = 0;
    for (var i = 0; i < e.length; i++) {
      r += e[i];
      if (n < t.length) {
        r += t[n++];
      }
    }
  } else if ("string" == typeof e) {
    r += e;
    for (var a of t) {
      r += a;
    }
  }
  return r;
}

function error(e, ...t) {
  return "number" == typeof e ? new CLIError(text(...t), e) : new CLIError(text(e, ...t));
}

function compose(e) {
  var t = cmd(ae.Style, [ le.Reset, le.NoInvert ]);
  var r = pipe(fromAsyncIterable(async function* convertError(e) {
    try {
      yield* e;
    } catch (e) {
      yield e instanceof CLIError ? e : "" + e;
    }
  }(e)), concatMap((e => "object" == typeof e && !(e instanceof CLIError) ? compose(e) : fromValue(e))), filter((e => null != e)), share);
  return pipe(r, concatMap((e => {
    var n = pipe("string" == typeof e || e instanceof CLIError ? fromValue(e) : merge([ e, never ]), takeUntil(r), share);
    return pipe(merge([ pipe(n, takeLast(1), map((e => "string" == typeof e && !e.endsWith("\n") ? "" : e))), n ]), function scan(e, t) {
      return r => n => {
        var i = t;
        r((t => {
          if (0 === t) {
            n(0);
          } else if (0 === t.tag) {
            n(t);
          } else {
            n(push(i = e(i, t[0])));
          }
        }));
      };
    }(((e, r) => "string" == typeof r ? function clear(e) {
      var t = 0;
      for (var r = 0; r < e.length; r++) {
        if (10 === e.charCodeAt(r)) {
          t++;
        }
      }
      if (t) {
        return cmd(ae.PrevLine, t) + cmd(ae.DeleteLines, t + 1);
      } else if (stripAnsi(e)) {
        return cmd(ae.EraseLine, oe.Backward) + cmd(ae.ToColumn, 1);
      } else {
        return "";
      }
    }("string" == typeof e ? e : "") + r + t : r), ""));
  })), takeUntil(pipe(r, takeLast(1))));
}

var pe = function(e) {
  e.Bell = "";
  e.Newline = "\n";
  e.Tab = "\t";
  e.Space = " ";
  e.Ellipsis = "‚Ä¶";
  return e;
}({});

var he = function(e) {
  e.TopLeft = "‚îè";
  e.TopRight = "‚îì";
  e.BottomLeft = "‚îó";
  e.BottomRight = "‚îõ";
  e.Vertical = "‚îÉ";
  e.VerticalRight = "‚î£";
  e.VerticalLeft = "‚î´";
  e.Horizontal = "‚îÅ";
  e.HorizontalDown = "‚î≥";
  e.HorizontalUp = "‚îª";
  e.Cross = "‚ïã";
  return e;
}({});

var ve = function(e) {
  e.Tick = "‚úì";
  e.TickSwoosh = "‚úî";
  e.Cross = "‚úñ";
  e.CrossSwoosh = "‚úò";
  e.Home = "‚åÇ";
  e.Note = "‚ô™";
  e.Warning = "‚ö†";
  e.Info = "‚Ñπ";
  e.Star = "‚òÖ";
  return e;
}({});

var me = [ "‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è" ];

var ge = [ "‚óê", "‚óì", "‚óë", "‚óí" ];

var Ce = !!process.env.GITHUB_ACTIONS;

var toCommandValue = e => "string" == typeof e || null == e ? e ? "" + e : "" : JSON.stringify(e);

var escapeData = e => toCommandValue(e).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");

var escapeProperty = e => toCommandValue(e).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");

function githubAnnotation(e, t, r) {
  if (Ce) {
    var n = `::${e}`;
    var i = "";
    if (r) {
      for (var a in r) {
        if (r) {
          i += ",";
        }
        if (r[a]) {
          i += `${a}=${escapeProperty(r[a])}`;
        }
      }
    }
    if (i) {
      n += ` ${i}`;
    }
    n += `::${escapeData(t)}\n`;
    process.stdout.write(n);
  }
}

function initTTY(e = {}) {
  var t = "dumb" !== process.env.TERM && !process.env.CI && !e.disableTTY;
  var r = null;
  var i = process.stdout;
  if (Ce) {
    if (!(i = process.stderr).isTTY) {
      r = process.stdout;
    }
  } else if (!i.isTTY && process.stderr.isTTY) {
    i = process.stderr;
    r = process.stdout;
  } else {
    t = i.isTTY;
  }
  var a = process.argv.includes("--color");
  var s = "FORCE_COLOR" in process.env || !process.env.NO_COLOR && !process.env.CI;
  _setColor(t && s || a || Ce);
  var D = pipe(function fromReadStream(e) {
    return make((t => {
      function onKeypress(e, r) {
        switch (r.name) {
         case "c":
         case "d":
         case "x":
          if (r.ctrl) {
            cleanup();
          }

         case "escape":
          cleanup();

         default:
          t.next({
            ...r,
            data: e
          });
        }
      }
      function cleanup() {
        if (e.isTTY) {
          e.setRawMode(!1);
        }
        t.complete();
        e.removeListener("keypress", onKeypress);
        e.unref();
      }
      if (e.isTTY) {
        e.setRawMode(!0);
      }
      n.emitKeypressEvents(e);
      e.setEncoding("utf8");
      e.resume();
      e.addListener("keypress", onKeypress);
      return cleanup;
    }));
  }(process.stdin), function onStart(e) {
    return t => r => t((t => {
      if (0 === t) {
        r(0);
      } else if (0 === t.tag) {
        r(t);
        e();
      } else {
        r(t);
      }
    }));
  }((function _start() {
    _setColor(t && s || a);
    if (t) {
      i.write(cmd(ae.UnsetPrivateMode, ce.ShowCursor));
    }
  })), onEnd((function _end() {
    if (t) {
      i.write(cmd(ae.Reset) + cmd(ae.ResetPrivateMode) + cmd(ae.SetPrivateMode, ce.ShowCursor) + "\n");
    }
  })), share);
  var c = pipe(concat([ pipe(D, filter((() => !1))), fromValue(null) ]), share);
  return {
    isInteractive: t,
    output: i,
    pipeTo: r,
    inputSource: D,
    cancelSource: c,
    write: function write(...e) {
      i.write(text(...e));
    },
    start: function start(t) {
      var write = e => i.write("" + e);
      if (e.disableTTY) {
        return pipe(compose(t), onPush(write), toPromise);
      } else {
        return pipe(compose(t), onPush(write), takeUntil(c), toPromise);
      }
    },
    mode: function mode(...e) {
      if (t) {
        var r = [];
        var n = [];
        for (var a of e) {
          if (a === De.Insert || a === De.AutomaticNewline) {
            r.push(a);
          } else {
            n.push(a);
          }
        }
        if (r.length) {
          i.write(cmd(ae.SetMode, r));
        }
        if (n.length) {
          i.write(cmd(ae.SetPrivateMode, n));
        }
      }
    },
    modeOff: function modeOff(...e) {
      if (t) {
        var r = [];
        var n = [];
        for (var a of e) {
          if (a === De.Insert || a === De.AutomaticNewline) {
            r.push(a);
          } else {
            n.push(a);
          }
        }
        if (r.length) {
          i.write(cmd(ae.UnsetMode, r));
        }
        if (n.length) {
          i.write(cmd(ae.UnsetPrivateMode, n));
        }
      }
    }
  };
}

function indent(e, t) {
  if (e.includes("\n")) {
    var r = e.trim().split("\n").join(text([ pe.Newline, t ]));
    return e.endsWith("\n") ? r + "\n" : r;
  } else {
    return e;
  }
}

function code(e) {
  return text`${cmd(ae.Style, le.Underline)}${e}${cmd(ae.Style, le.NoUnderline)}`;
}

function bold(e) {
  return text`${cmd(ae.Style, le.Bold)}${e}${cmd(ae.Style, le.Normal)}`;
}

function hint(e) {
  return text([ cmd(ae.Style, le.BrightBlack), `${he.BottomLeft} `, cmd(ae.Style, le.BrightBlue), `${ve.Info} `, cmd(ae.Style, le.Blue), indent(e, "    ") ]);
}

function errorMessage$1(e) {
  return error([ "\n", cmd(ae.Style, [ le.Red, le.Invert ]), ` ${ve.Warning} Error `, cmd(ae.Style, le.NoInvert), `\n${e.trim()}\n` ]);
}

function externalError(e, t) {
  var r;
  var n;
  if (t && "object" == typeof t) {
    if ("name" in t && ("TSError" === t.name || "TadaError" === t.name || "code" in t)) {
      r = "code" in t ? "System Error" : "Error";
      n = t.message.trim();
    } else if ("message" in t && "string" == typeof t.message) {
      r = "Unexpected Error";
      n = `${t.message}`;
    } else {
      r = "Unexpected Error";
      n = `${t}`;
    }
  } else {
    r = "Unexpected Error";
    n = `${t}`;
  }
  return error([ "\n", cmd(ae.Style, [ le.Red, le.Invert ]), ` ${ve.Warning} ${r} `, cmd(ae.Style, le.NoInvert), `\n${e.trim()}\n`, cmd(ae.Style, le.BrightBlack), `${he.BottomLeft} `, indent(n, "  ") ]);
}

var writeOutput = async (e, t) => {
  if (e && "object" == typeof e && "writable" in e) {
    return await new Promise(((r, n) => {
      e.write(t, (e => {
        if (e) {
          n(e);
        } else {
          r();
        }
      }));
    }));
  } else if (!await (n = e, B.stat(n).then((e => e.isFile())).catch((() => !1)))) {
    await B.writeFile(e, t);
  } else {
    var r = e + ".tmp";
    await B.writeFile(r, t);
    try {
      await B.rename(r, e);
    } catch (e) {
      await B.unlink(r);
      throw e;
    } finally {
      await (async e => {
        try {
          var t = new Date;
          await B.utimes(e, t, t);
        } catch (e) {}
      })(e);
    }
  }
  var n;
};

async function* run$6(e, r) {
  var n;
  var i;
  try {
    n = await t.loadConfig(r.tsconfig);
    i = t.parseConfig(n.pluginConfig);
  } catch (e) {
    throw externalError("Failed to load configuration.", e);
  }
  var a = t.load({
    origin: i.schema,
    rootPath: b.dirname(n.configPath)
  });
  var s;
  try {
    s = (await a.load()).introspection;
  } catch (e) {
    throw externalError("Failed to load introspection.", e);
  }
  var D;
  if (!r.output && e.pipeTo) {
    D = e.pipeTo;
  } else if (r.output) {
    D = b.resolve(process.cwd(), r.output);
  } else if (i.tadaOutputLocation) {
    D = b.resolve(b.dirname(n.configPath), i.tadaOutputLocation);
  } else {
    throw errorMessage$1("No output path was specified to write the output file to.\n" + hint(`You have to either set ${code('"tadaOutputLocation"')} in your configuration,\npass an ${code("--output")} argument to this command,\nor pipe this command to an output file.`));
  }
  var c;
  try {
    c = t.outputIntrospectionFile(t.minifyIntrospection(s), {
      fileType: D && "string" == typeof D ? D : r.forceTSFormat ? ".ts" : ".d.ts",
      shouldPreprocess: !r.disablePreprocessing
    });
  } catch (e) {
    throw externalError("Could not generate introspection output", e);
  }
  try {
    await writeOutput(D, c);
  } catch (e) {
    throw externalError("Something went wrong while writing the introspection file", e);
  }
  yield function summary$1(e) {
    var t = text([ cmd(ae.Style, le.BrightGreen), `${ve.Tick} Introspection output was generated successfully\n` ]);
    if (e) {
      t += hint(`The pipe output was generated in the ${code(".d.ts")} format.\nFor the ${code(".ts")} format, pass the ${code("--force-ts-format")} argument.\n`);
    }
    return t;
  }(!r.forceTSFormat && "string" != typeof D);
}

class GenerateOutputCommand extends Command {
  static paths=[ [ "generate-output" ], [ "generate", "output" ] ];
  forceTSFormat=Boolean$1("--force-ts-format", !1, {
    description: "Forces the `.ts` output format when the output is piped",
    hidden: !0
  });
  disablePreprocessing=Boolean$1("--disable-preprocessing", !1, {
    description: "Disables pre-processing, which is an internal introspection format generated ahead of time"
  });
  tsconfig=String$1("--tsconfig,-c", {
    description: "Specify the `tsconfig.json` used to read, unless `--output` is passed."
  });
  output=String$1("--output,-o", {
    description: "Specifies where to output the file to.\tDefault: The `tadaOutputLocation` configuration option"
  });
  async execute() {
    var e = initTTY();
    var t = await e.start(run$6(e, {
      forceTSFormat: this.forceTSFormat,
      disablePreprocessing: this.disablePreprocessing,
      output: this.output,
      tsconfig: this.tsconfig
    }));
    return process.exitCode || ("object" == typeof t ? t.exit : 0);
  }
}

async function generateOutput(e) {
  var t = initTTY({
    disableTTY: !0
  });
  var r = await t.start(run$6(t, e));
  if (r instanceof Error) {
    throw r;
  }
}

var Fe = process.cwd();

var Ee = "  ";

function warningFile$1(e) {
  var t = b.relative(Fe, e);
  if (!t.startsWith("..")) {
    e = t;
  }
  return text([ cmd(ae.Style, le.Underline), e, cmd(ae.Style, le.NoUnderline), "\n" ]);
}

function warningGithub$1(e) {
  githubAnnotation("warning", e.message, {
    file: e.file,
    line: e.line,
    col: e.col
  });
}

function runningPersisted(e, t) {
  var r = e ? t ? `(${e}/${t})` : `(${e})` : "";
  return pipe(interval(150), map((e => text([ cmd(ae.Style, le.Magenta), me[e % me.length], " ", cmd(ae.Style, le.Foreground), `Scanning files${pe.Ellipsis} `, cmd(ae.Style, le.BrightBlack), r ]))));
}

async function* run$5(e, r) {
  var {runPersisted: n} = await Promise.resolve().then((function() {
    return require("./chunks/thread-chunk.js");
  }));
  var i;
  var a;
  try {
    i = await t.loadConfig(r.tsconfig);
    a = t.parseConfig(i.pluginConfig);
  } catch (e) {
    throw externalError("Failed to load configuration.", e);
  }
  var s;
  if (!r.output && e.pipeTo) {
    s = e.pipeTo;
  } else if (r.output) {
    s = b.resolve(process.cwd(), r.output);
  } else if (a.tadaPersistedLocation) {
    s = b.resolve(b.dirname(i.configPath), a.tadaPersistedLocation);
  } else {
    throw errorMessage$1("No output path was specified to write the persisted manifest file to.\n" + hint(`You have to either set ${code('"tadaPersistedLocation"')} in your configuration,\npass an ${code("--output")} argument to this command,\nor pipe this command to an output file.`));
  }
  if (e.isInteractive) {
    yield runningPersisted();
  }
  var D = {};
  var c = n({
    rootPath: i.rootPath,
    configPath: i.configPath,
    pluginConfig: a
  });
  var l = 0;
  var d = 0;
  var f = 0;
  try {
    for await (var p of c) {
      if ("FILE_COUNT" === p.kind) {
        d = p.fileCount;
        continue;
      }
      D = Object.assign(D, p.documents);
      if (l += p.warnings.length) {
        var h = warningFile$1(p.filePath);
        for (var m of p.warnings) {
          h += (g = m, text([ Ee, cmd(ae.Style, le.BrightBlack), `${g.line}:${g.col}`, pe.Tab, cmd(ae.Style, le.Foreground), indent(g.message.trim(), text([ Ee, pe.Tab ])), pe.Newline ]));
          warningGithub$1(m);
        }
        yield h + "\n";
      }
      if (e.isInteractive) {
        yield runningPersisted(++f, d);
      }
    }
  } catch (e) {
    throw externalError("Could not generate persisted manifest file", e);
  }
  var g;
  var E = Object.keys(D).length;
  if (l && r.failOnWarn) {
    throw function warningSummary$1(e, t) {
      return error([ cmd(ae.Style, le.Red), `${ve.Cross} ${e} warnings `, cmd(ae.Style, le.BrightBlack), `(${t} documents extracted)\n` ]);
    }(l, E);
  } else {
    if (E) {
      try {
        var w = JSON.stringify(D, null, 2);
        await writeOutput(s, w);
      } catch (e) {
        throw externalError("Something went wrong while writing the introspection file", e);
      }
    }
    yield function infoSummary$2(e, t) {
      var r = "";
      if (e) {
        r += text([ cmd(ae.Style, le.BrightYellow), ve.Warning, ` ${e} warnings\n` ]);
      }
      if (t) {
        r += text([ cmd(ae.Style, le.BrightGreen), `${ve.Tick} Persisted manifest was generated successfully `, cmd(ae.Style, le.BrightBlack), `(${t} documents extracted)\n` ]);
      } else {
        r += text([ cmd(ae.Style, le.Blue), `${ve.Info} No persisted documents were found `, cmd(ae.Style, le.BrightBlack), "(Persisted manifest was not generated)\n" ]);
      }
      return r;
    }(l, E);
  }
}

class GeneratePersisted extends Command {
  static paths=[ [ "generate-persisted" ], [ "generate", "persisted" ] ];
  tsconfig=String$1("--tsconfig,-c", {
    description: "Specify the `tsconfig.json` used to read, unless `--output` is passed."
  });
  failOnWarn=Boolean$1("--fail-on-warn", !1, {
    description: "Triggers an error and a non-zero exit code if any warnings have been reported"
  });
  output=String$1("--output,-o", {
    description: "Specifies where to output the file to.\tDefault: The `tadaPersistedLocation` configuration option"
  });
  async execute() {
    var e = initTTY();
    var t = await e.start(run$5(e, {
      failOnWarn: this.failOnWarn,
      output: this.output,
      tsconfig: this.tsconfig
    }));
    return process.exitCode || ("object" == typeof t ? t.exit : 0);
  }
}

async function generatePersisted(e) {
  var t = initTTY({
    disableTTY: !0
  });
  var r = await t.start(run$5(t, e));
  if (r instanceof Error) {
    throw r;
  }
}

var ye = /^[a-zA-Z_][a-zA-Z0-9_]*$/;

function getPrintable(e) {
  if (null === e) {
    return "null";
  }
  if (void 0 === e) {
    return "undefined";
  }
  if ("" === e) {
    return "an empty string";
  }
  if ("symbol" == typeof e) {
    return `<${e.toString()}>`;
  }
  if (Array.isArray(e)) {
    return "an array";
  }
  return JSON.stringify(e);
}

function computeKey(e, t) {
  var r, n, i;
  if ("number" == typeof t) {
    return `${null !== (r = null == e ? void 0 : e.p) && void 0 !== r ? r : "."}[${t}]`;
  } else if (ye.test(t)) {
    return `${null !== (n = null == e ? void 0 : e.p) && void 0 !== n ? n : ""}.${t}`;
  } else {
    return `${null !== (i = null == e ? void 0 : e.p) && void 0 !== i ? i : "."}[${JSON.stringify(t)}]`;
  }
}

function pushError({errors: e, p: t} = {}, r) {
  null == e || e.push(`${null != t ? t : "."}: ${r}`);
  return !1;
}

function makeCoercionFn(e, t) {
  return r => {
    var n = e[t];
    e[t] = r;
    return makeCoercionFn(e, t).bind(null, n);
  };
}

function isLiteral(e) {
  return makeValidator({
    test: (t, r) => {
      if (t !== e) {
        return pushError(r, `Expected ${getPrintable(e)} (got ${getPrintable(t)})`);
      }
      return !0;
    }
  });
}

function isString() {
  return makeValidator({
    test: (e, t) => {
      if ("string" != typeof e) {
        return pushError(t, `Expected a string (got ${getPrintable(e)})`);
      }
      return !0;
    }
  });
}

function isArray(e, {delimiter: t} = {}) {
  return makeValidator({
    test: (r, n) => {
      var i;
      var a = r;
      if ("string" == typeof r && void 0 !== t) {
        if (void 0 !== (null == n ? void 0 : n.coercions)) {
          if (void 0 === (null == n ? void 0 : n.coercion)) {
            return pushError(n, "Unbound coercion result");
          }
          r = r.split(t);
        }
      }
      if (!Array.isArray(r)) {
        return pushError(n, `Expected an array (got ${getPrintable(r)})`);
      }
      var s = !0;
      for (var D = 0, c = r.length; D < c; ++D) {
        if (!(s = e(r[D], Object.assign(Object.assign({}, n), {
          p: computeKey(n, D),
          coercion: makeCoercionFn(r, D)
        })) && s) && null == (null == n ? void 0 : n.errors)) {
          break;
        }
      }
      if (r !== a) {
        n.coercions.push([ null !== (i = n.p) && void 0 !== i ? i : ".", n.coercion.bind(null, r) ]);
      }
      return s;
    }
  });
}

function isTuple(e, {delimiter: t} = {}) {
  var r = hasExactLength(e.length);
  return makeValidator({
    test: (n, i) => {
      var a;
      if ("string" == typeof n && void 0 !== t) {
        if (void 0 !== (null == i ? void 0 : i.coercions)) {
          if (void 0 === (null == i ? void 0 : i.coercion)) {
            return pushError(i, "Unbound coercion result");
          }
          n = n.split(t);
          i.coercions.push([ null !== (a = i.p) && void 0 !== a ? a : ".", i.coercion.bind(null, n) ]);
        }
      }
      if (!Array.isArray(n)) {
        return pushError(i, `Expected a tuple (got ${getPrintable(n)})`);
      }
      var s = r(n, Object.assign({}, i));
      for (var D = 0, c = n.length; D < c && D < e.length; ++D) {
        if (!(s = e[D](n[D], Object.assign(Object.assign({}, i), {
          p: computeKey(i, D),
          coercion: makeCoercionFn(n, D)
        })) && s) && null == (null == i ? void 0 : i.errors)) {
          break;
        }
      }
      return s;
    }
  });
}

function isRecord(e, {keys: t = null} = {}) {
  var r = isArray(isTuple([ null != t ? t : isString(), e ]));
  return makeValidator({
    test: (n, i) => {
      var a;
      if (Array.isArray(n)) {
        if (void 0 !== (null == i ? void 0 : i.coercions)) {
          if (void 0 === (null == i ? void 0 : i.coercion)) {
            return pushError(i, "Unbound coercion result");
          }
          if (!r(n, Object.assign(Object.assign({}, i), {
            coercion: void 0
          }))) {
            return !1;
          }
          n = Object.fromEntries(n);
          i.coercions.push([ null !== (a = i.p) && void 0 !== a ? a : ".", i.coercion.bind(null, n) ]);
          return !0;
        }
      }
      if ("object" != typeof n || null === n) {
        return pushError(i, `Expected an object (got ${getPrintable(n)})`);
      }
      var s = Object.keys(n);
      var D = !0;
      for (var c = 0, l = s.length; c < l && (D || null != (null == i ? void 0 : i.errors)); ++c) {
        var d = s[c];
        var f = n[d];
        if ("__proto__" === d || "constructor" === d) {
          D = pushError(Object.assign(Object.assign({}, i), {
            p: computeKey(i, d)
          }), "Unsafe property name");
          continue;
        }
        if (null !== t && !t(d, i)) {
          D = !1;
          continue;
        }
        if (!e(f, Object.assign(Object.assign({}, i), {
          p: computeKey(i, d),
          coercion: makeCoercionFn(n, d)
        }))) {
          D = !1;
          continue;
        }
      }
      return D;
    }
  });
}

var isOneOf = (e, {exclusive: t = !1} = {}) => makeValidator({
  test: (r, n) => {
    var i, a, s;
    var D = [];
    var c = void 0 !== (null == n ? void 0 : n.errors) ? [] : void 0;
    for (var l = 0, d = e.length; l < d; ++l) {
      var f = void 0 !== (null == n ? void 0 : n.errors) ? [] : void 0;
      var p = void 0 !== (null == n ? void 0 : n.coercions) ? [] : void 0;
      if (e[l](r, Object.assign(Object.assign({}, n), {
        errors: f,
        coercions: p,
        p: `${null !== (i = null == n ? void 0 : n.p) && void 0 !== i ? i : "."}#${l + 1}`
      }))) {
        D.push([ `#${l + 1}`, p ]);
        if (!t) {
          break;
        }
      } else {
        null == c || c.push(f[0]);
      }
    }
    if (1 === D.length) {
      var [, h] = D[0];
      if (void 0 !== h) {
        null === (a = null == n ? void 0 : n.coercions) || void 0 === a || a.push(...h);
      }
      return !0;
    }
    if (D.length > 1) {
      pushError(n, `Expected to match exactly a single predicate (matched ${D.join(", ")})`);
    } else {
      null === (s = null == n ? void 0 : n.errors) || void 0 === s || s.push(...c);
    }
    return !1;
  }
});

function makeTrait(e) {
  return () => e;
}

function makeValidator({test: e}) {
  return makeTrait(e)();
}

function hasExactLength(e) {
  return makeValidator({
    test: (t, r) => {
      if (t.length !== e) {
        return pushError(r, `Expected to have a length of exactly ${e} elements (got ${t.length})`);
      }
      return !0;
    }
  });
}

function matchesRegExp(e) {
  return makeValidator({
    test: (t, r) => {
      if (!e.test(t)) {
        return pushError(r, `Expected to match the pattern ${e.toString()} (got ${getPrintable(t)})`);
      }
      return !0;
    }
  });
}

function cascade(e, ...t) {
  var r = Array.isArray(t[0]) ? t[0] : t;
  return makeValidator({
    test: (t, n) => {
      var i, a;
      var s = {
        value: t
      };
      var D = void 0 !== (null == n ? void 0 : n.coercions) ? makeCoercionFn(s, "value") : void 0;
      var c = void 0 !== (null == n ? void 0 : n.coercions) ? [] : void 0;
      if (!e(t, Object.assign(Object.assign({}, n), {
        coercion: D,
        coercions: c
      }))) {
        return !1;
      }
      var l = [];
      if (void 0 !== c) {
        for (var [, d] of c) {
          l.push(d());
        }
      }
      try {
        if (void 0 !== (null == n ? void 0 : n.coercions)) {
          if (s.value !== t) {
            if (void 0 === (null == n ? void 0 : n.coercion)) {
              return pushError(n, "Unbound coercion result");
            }
            n.coercions.push([ null !== (i = n.p) && void 0 !== i ? i : ".", n.coercion.bind(null, s.value) ]);
          }
          null === (a = null == n ? void 0 : n.coercions) || void 0 === a || a.push(...c);
        }
        return r.every((e => e(s.value, n)));
      } finally {
        for (var f of l) {
          f();
        }
      }
    }
  });
}

var we;

!function(e) {
  e.Forbids = "Forbids";
  e.Requires = "Requires";
}(we || (we = {}));

var be = {
  __proto__: null,
  get KeyRelationship() {
    return we;
  },
  applyCascade: function applyCascade(e, ...t) {
    return cascade(e, Array.isArray(t[0]) ? t[0] : t);
  },
  cascade,
  hasExactLength,
  isArray,
  isDict: function isDict(e, t = {}) {
    return isRecord(e, t);
  },
  isLiteral,
  isOneOf,
  isRecord,
  isString,
  isTuple,
  isUnknown: function isUnknown() {
    return makeValidator({
      test: (e, t) => !0
    });
  },
  makeTrait,
  makeValidator,
  matchesRegExp
};

async function* run$4(r, n) {
  var a = n.headers ? {
    url: n.input,
    headers: n.headers
  } : n.input;
  var s = t.load({
    rootPath: process.cwd(),
    origin: a
  });
  var D;
  try {
    D = (await s.load()).schema;
  } catch (e) {
    throw externalError("Failed to load schema.", e);
  }
  var c;
  if (!n.output && r.pipeTo) {
    c = r.pipeTo;
  } else if (n.output) {
    c = e.resolve(process.cwd(), n.output);
  } else {
    var l;
    var d;
    try {
      l = await t.loadConfig(n.tsconfig);
      d = t.parseConfig(l.pluginConfig);
    } catch (e) {
      throw externalError("Failed to load configuration.", e);
    }
    if ("string" == typeof d.schema && ".graphql" === e.extname(d.schema)) {
      c = e.resolve(e.dirname(l.configPath), d.schema);
    } else {
      throw errorMessage$1(`No output path was specified but writing to ${code("schema")} is not a file path.\n` + hint(`You have to either set ${code('"schema"')} to a ${code(".graphql")} file in your configuration,\npass an ${code("--output")} argument to this command,\nor pipe this command to an output file.`));
    }
  }
  try {
    await writeOutput(c, i.printSchema(D));
  } catch (e) {
    throw externalError("Something went wrong while writing the introspection file", e);
  }
  yield function summary() {
    return text([ cmd(ae.Style, le.BrightGreen), `${ve.Tick} Introspection output was generated successfully\n` ]);
  }();
}

var Be = isArray(cascade(isString(), matchesRegExp(/^[\w-]+[ ]*:[ ]*.+/i)));

var parseHeaders = e => {
  if (e && e.length) {
    return (e || []).reduce(((e, t) => {
      var r = t.indexOf(":");
      var n = t.slice(0, r);
      var i = t.slice(r + 1);
      e[n.trimEnd()] = i.trimStart();
      return e;
    }), {});
  }
};

class GenerateSchema extends Command {
  static paths=[ [ "generate-schema" ], [ "generate", "schema" ] ];
  input=String$1({
    name: "schema",
    required: !0
  });
  tsconfig=String$1("--tsconfig,-c", {
    description: "Specify the `tsconfig.json` used to read, unless `--output` is passed."
  });
  output=String$1("--output,-o", {
    description: "Specify where to output the file to.\tDefault: The `schema` configuration option, if it's a file path"
  });
  headers=function Array$1(e, t, r) {
    var [n, i] = rerouteArguments(t, null != r ? r : {});
    var {arity: a = 1} = i;
    var s = e.split(",");
    var D = new Set(s);
    return makeCommandOption({
      definition(e) {
        e.addOption({
          names: s,
          arity: a,
          hidden: null == i ? void 0 : i.hidden,
          description: null == i ? void 0 : i.description,
          required: i.required
        });
      },
      transformer(e, t, r) {
        var a;
        var s = void 0 !== n ? [ ...n ] : void 0;
        for (var {name: c, value: l} of r.options) {
          if (!D.has(c)) {
            continue;
          }
          a = c;
          (s = null != s ? s : []).push(l);
        }
        if (void 0 !== s) {
          return applyValidator(null != a ? a : t, s, i.validator);
        } else {
          return s;
        }
      }
    });
  }("--header", {
    description: "Headers to be used when introspection a schema from a remote URL",
    validator: Be
  });
  async execute() {
    var e = initTTY();
    var t = await e.start(run$4(e, {
      input: this.input,
      headers: parseHeaders(this.headers),
      output: this.output,
      tsconfig: this.tsconfig
    }));
    return process.exitCode || ("object" == typeof t ? t.exit : 0);
  }
}

async function generateSchema(e) {
  var t = initTTY({
    disableTTY: !0
  });
  var r = await t.start(run$4(t, e));
  if (r instanceof Error) {
    throw r;
  }
}

var Se = process.cwd();

var xe = "  ";

function warningFile(e) {
  var t = b.relative(Se, e);
  if (!t.startsWith("..")) {
    e = t;
  }
  return text([ cmd(ae.Style, le.Underline), e, cmd(ae.Style, le.NoUnderline), "\n" ]);
}

function warningGithub(e) {
  githubAnnotation("warning", e.message, {
    file: e.file,
    line: e.line,
    col: e.col
  });
}

function runningTurbo(e, t) {
  var r = e ? t ? `(${e}/${t})` : `(${e})` : "";
  return pipe(interval(150), map((e => text([ cmd(ae.Style, le.Magenta), me[e % me.length], " ", cmd(ae.Style, le.Foreground), `Scanning files${pe.Ellipsis} `, cmd(ae.Style, le.BrightBlack), r ]))));
}

var $e = [ "/* eslint-disable */", "/* prettier-ignore */" ].join("\n") + "\n";

async function* run$3(e, r) {
  var {runTurbo: n} = await Promise.resolve().then((function() {
    return require("./chunks/thread-chunk2.js");
  }));
  var i;
  var a;
  try {
    i = await t.loadConfig(r.tsconfig);
    a = t.parseConfig(i.pluginConfig);
  } catch (e) {
    throw externalError("Failed to load configuration.", e);
  }
  var s;
  if (!r.output && e.pipeTo) {
    s = e.pipeTo;
  } else if (r.output) {
    s = b.resolve(process.cwd(), r.output);
  } else if (a.tadaTurboLocation) {
    s = b.resolve(b.dirname(i.configPath), a.tadaTurboLocation);
  } else if (a.tadaOutputLocation) {
    s = b.resolve(b.dirname(i.configPath), a.tadaOutputLocation, "..", "graphql-cache.d.ts");
    yield function hintMessage(e) {
      return error([ cmd(ae.Style, [ le.Yellow, le.Bold ]), `${ve.Warning} Note: `, cmd(ae.Style, le.Reset), `${e.trim()}\n\n` ]);
    }(`No output location was specified.\nThe turbo cache will by default be saved as ${code('"graphql-cache.d.ts"')}.\n` + hint(`To change this, add a ${code('"tadaTurboLocation"')} in your configuration,\npass an ${code("--output")} argument to this command,\nor pipe this command to an output file.`));
  } else {
    throw errorMessage$1("No output path was specified to write the output file to.\n" + hint(`You have to either set ${code('"tadaTurboLocation"')} in your configuration,\npass an ${code("--output")} argument to this command,\nor pipe this command to an output file.`));
  }
  if (e.isInteractive) {
    yield runningTurbo();
  }
  var D = {};
  var c = n({
    rootPath: i.rootPath,
    configPath: i.configPath,
    pluginConfig: a
  });
  var l = 0;
  var d = 0;
  var f = 0;
  try {
    for await (var p of c) {
      if ("FILE_COUNT" === p.kind) {
        d = p.fileCount;
        continue;
      }
      D = Object.assign(D, p.cache);
      l += p.warnings.length;
      if (p.warnings.length) {
        var h = warningFile(p.filePath);
        for (var m of p.warnings) {
          h += (g = m, text([ xe, cmd(ae.Style, le.BrightBlack), `${g.line}:${g.col}`, pe.Tab, cmd(ae.Style, le.Foreground), indent(g.message.trim(), text([ xe, pe.Tab ])), pe.Newline ]));
          warningGithub(m);
        }
        yield h + "\n";
      }
      if (e.isInteractive) {
        yield runningTurbo(++f, d);
      }
    }
  } catch (e) {
    throw externalError("Could not build cache", e);
  }
  var g;
  var E = Object.keys(D).length;
  if (l && r.failOnWarn) {
    throw function warningSummary(e, t) {
      return error([ cmd(ae.Style, le.Red), `${ve.Cross} ${e} warnings `, cmd(ae.Style, le.BrightBlack), `(${t} document types cached)\n` ]);
    }(l, E);
  } else {
    try {
      var w = function createCacheContents(e) {
        var t = "";
        for (var r in e) {
          if (t) {
            t += "\n";
          }
          t += `    ${r}:\n      ${e[r]};`;
        }
        return $e + "import type { TadaDocumentNode, $tada } from 'gql.tada';\n\ndeclare module 'gql.tada' {\n interface setupCache {\n" + t + "\n  }\n}\n";
      }(D);
      await writeOutput(s, w);
    } catch (e) {
      throw externalError("Something went wrong while writing the cache file", e);
    }
    yield function infoSummary$1(e, t) {
      var r = "";
      if (e) {
        r += text([ cmd(ae.Style, le.BrightYellow), ve.Warning, ` ${e} warnings\n` ]);
      }
      if (t) {
        r += text([ cmd(ae.Style, le.BrightGreen), `${ve.Tick} Type cache was generated successfully `, cmd(ae.Style, le.BrightBlack), `(${t} document types cached)\n` ]);
      } else {
        r += text([ cmd(ae.Style, le.Blue), `${ve.Info} No documents were found\n` ]);
      }
      return r;
    }(l, E);
  }
}

class TurboCommand extends Command {
  static paths=[ [ "generate", "turbo" ], [ "turbo" ] ];
  tsconfig=String$1("--tsconfig,-c", {
    description: "Specify the `tsconfig.json` read for configuration."
  });
  failOnWarn=Boolean$1("--fail-on-warn,-w", !1, {
    description: "Triggers an error and a non-zero exit code if any warnings have been reported"
  });
  output=String$1("--output,-o", {
    description: "Specifies where to output the file to.\tDefault: The `tadaTurboLocation` configuration option"
  });
  async execute() {
    var e = initTTY();
    var t = await e.start(run$3(e, {
      failOnWarn: this.failOnWarn,
      output: this.output,
      tsconfig: this.tsconfig
    }));
    return process.exitCode || ("object" == typeof t ? t.exit : 0);
  }
}

async function generateTurbo(e) {
  var t = initTTY({
    disableTTY: !0
  });
  var r = await t.start(run$3(t, e));
  if (r instanceof Error) {
    throw r;
  }
}

var Ae = {
  __proto__: null,
  generateOutput,
  generatePersisted,
  generateSchema,
  generateTurbo
};

var Oe = process.cwd();

var Te = "  ";

function diagnosticFile(e) {
  var t = b.relative(Oe, e);
  if (!t.startsWith("..")) {
    e = t;
  }
  return text([ cmd(ae.Style, le.Underline), e, cmd(ae.Style, le.NoUnderline), "\n" ]);
}

function diagnosticMessage(e) {
  var t = le.Foreground;
  if ("info" === e.severity) {
    t = le.BrightBlue;
  } else if ("warn" === e.severity) {
    t = le.BrightYellow;
  } else if ("error" === e.severity) {
    t = le.BrightRed;
  }
  return text([ Te, cmd(ae.Style, le.BrightBlack), `${e.line}:${e.col}`, pe.Tab, cmd(ae.Style, t), e.severity, pe.Tab, cmd(ae.Style, le.Foreground), indent(e.message.trim(), text([ Te, pe.Tab, pe.Tab ])), pe.Newline ]);
}

function diagnosticMessageGithub(e) {
  githubAnnotation("warn" === e.severity ? "warning" : "error" === e.severity ? "error" : "notice", e.message, {
    file: e.file,
    line: e.line,
    col: e.col,
    endLine: e.endLine,
    endColumn: e.endColumn
  });
}

function runningDiagnostics(e, t) {
  var r = e ? t ? `(${e}/${t})` : `(${e})` : "";
  return pipe(interval(150), map((e => text([ cmd(ae.Style, le.Magenta), me[e % me.length], " ", cmd(ae.Style, le.Foreground), `Checking files${pe.Ellipsis} `, cmd(ae.Style, le.BrightBlack), r ]))));
}

var isMinSeverity = (e, t) => {
  switch (e) {
   case "info":
    return "warn" !== t && "error" !== t;

   case "warn":
    return "error" !== t;

   case "error":
    return !0;
  }
};

async function* run$2(e, r) {
  var {runDiagnostics: n} = await Promise.resolve().then((function() {
    return require("./chunks/thread-chunk3.js");
  }));
  var i;
  var a;
  try {
    i = await t.loadConfig(r.tsconfig);
    a = t.parseConfig(i.pluginConfig);
  } catch (e) {
    throw externalError("Failed to load configuration.", e);
  }
  var s = {
    warn: 0,
    error: 0,
    info: 0
  };
  var D = r.minSeverity;
  var c = n({
    rootPath: i.rootPath,
    configPath: i.configPath,
    pluginConfig: a
  });
  var l = 0;
  var d = 0;
  try {
    for await (var f of c) {
      if ("FILE_COUNT" === f.kind) {
        l = f.fileCount;
        continue;
      }
      var p = "";
      for (var h of f.messages) {
        s[h.severity]++;
        if (isMinSeverity(h.severity, D)) {
          p += diagnosticMessage(h);
          diagnosticMessageGithub(h);
        }
      }
      if (p) {
        yield diagnosticFile(f.filePath) + p + "\n";
      }
      if (e.isInteractive) {
        yield runningDiagnostics(++d, l);
      }
    }
  } catch (e) {
    throw externalError("Could not check files", e);
  }
  if ("info" !== D) {
    s.info = 0;
  }
  if (r.failOnWarn && s.warn || s.error) {
    throw function problemsSummary(e) {
      var {info: t, error: r, warn: n} = e;
      var i = "";
      if (t) {
        i += text([ cmd(ae.Style, le.Blue), ve.Info, ` ${t} notices\n` ]);
      }
      return error(i += text([ cmd(ae.Style, le.Red), ve.Cross, ` ${r + n} problems (${r} errors, ${n} warnings)\n` ]));
    }(s);
  } else {
    yield function infoSummary(e) {
      var {info: t, error: r, warn: n} = e;
      var i = "";
      if (t) {
        i += text([ cmd(ae.Style, le.Blue), ve.Info, ` ${t} notices\n` ]);
      }
      if (r || n) {
        i += text([ cmd(ae.Style, le.BrightYellow), ve.Warning, ` ${r + n} problems (${r} errors, ${n} warnings)\n` ]);
      } else {
        i += text([ cmd(ae.Style, le.BrightGreen), ve.Tick, " No problems found\n" ]);
      }
      return i;
    }(s);
  }
}

class CheckCommand extends Command {
  static paths=[ [ "check" ] ];
  tsconfig=String$1("--tsconfig,-c", {
    description: "Specify the `tsconfig.json` used to read"
  });
  failOnWarn=Boolean$1("--fail-on-warn,-w", !1, {
    description: "Triggers an error and a non-zero exit code if any warnings have been reported"
  });
  minSeverity=String$1("--level,-l", {
    description: "The minimum severity of diagnostics to display (info, warn, error)",
    validator: isOneOf([ isLiteral("info"), isLiteral("warn"), isLiteral("error") ])
  }) || "info";
  async execute() {
    var e = initTTY();
    var t = await e.start(run$2(e, {
      failOnWarn: this.failOnWarn,
      minSeverity: this.minSeverity,
      tsconfig: this.tsconfig
    }));
    return process.exitCode || ("object" == typeof t ? t.exit : 0);
  }
}

var ke = new Intl.Collator(0, {
  numeric: 1
}).compare;

function emptyLine() {
  return text([ cmd(ae.Style, le.BrightBlack), he.Vertical, "\n" ]);
}

function completedTask(e, t = !1) {
  return text([ emptyLine(), cmd(ae.Style, le.BrightBlack), t ? he.BottomLeft : he.VerticalRight, " ", cmd(ae.Style, le.Green), ve.TickSwoosh, " ", cmd(ae.Style, le.Foreground), e, "\n" ]);
}

function failedTask(e) {
  return text([ emptyLine(), cmd(ae.Style, le.BrightBlack), he.BottomLeft, " ", cmd(ae.Style, le.BrightRed), ve.CrossSwoosh, " ", cmd(ae.Style, le.Foreground), e, "\n" ]);
}

function runningTask(e) {
  return pipe(interval(150), map((t => text([ emptyLine(), cmd(ae.Style, le.Magenta), ge[t % ge.length], " ", cmd(ae.Style, le.Foreground), e.trim() ]))));
}

function errorMessage(e) {
  return error([ "\n", cmd(ae.Style, [ le.Red, le.Invert ]), ` ${ve.Warning} Error `, cmd(ae.Style, le.NoInvert), `\n${e.trim()}\n` ]);
}

var delay = (e = 700) => {
  if (process.env.CI) {
    return Promise.resolve();
  } else {
    return new Promise((t => {
      setTimeout(t, e);
    }));
  }
};

var semiverComply = (e, t) => {
  var r = e.match(/\d+\.\d+\.\d+/);
  return r ? function semiver(e, t, r) {
    e = e.split(".");
    t = t.split(".");
    return ke(e[0], t[0]) || ke(e[1], t[1]) || (t[2] = t.slice(2).join("."), (r = /[.-]/.test(e[2] = e.slice(2).join("."))) == /[.-]/.test(t[2]) ? ke(e[2], t[2]) : r ? -1 : 1);
  }(r[0], t) >= 0 : !1;
};

var Ie = function(e) {
  e.TITLE = "Doctor";
  e.DESCRIPTION = "Detects problems with your setup";
  e.CHECK_TS_VERSION = "Checking TypeScript version";
  e.CHECK_DEPENDENCIES = "Checking installed dependencies";
  e.CHECK_TSCONFIG = "Checking tsconfig.json";
  e.CHECK_SCHEMA = "Checking schema";
  return e;
}(Ie || {});

var Ne = "4.1.0", Pe = "1.0.0";

async function* run$1() {
  yield function title(e, t) {
    var r = text([ cmd(ae.Style, le.BrightBlack), he.TopLeft, " ", cmd(ae.Style, [ le.Magenta, le.Invert ]), ` ${e.trim()} `, cmd(ae.Style, [ le.NoInvert ]), "\n" ]);
    if (t) {
      r += text([ cmd(ae.Style, le.BrightBlack), he.Vertical, ` ${t}\n` ]);
    }
    return r;
  }(Ie.TITLE, Ie.DESCRIPTION);
  yield runningTask(Ie.CHECK_TS_VERSION);
  await delay();
  var n = process.cwd();
  var i = e.resolve(n, "package.json");
  var a;
  try {
    var s = e.resolve(i);
    a = JSON.parse(await r.readFile(s, "utf-8"));
  } catch (e) {
    yield failedTask(Ie.CHECK_TS_VERSION);
    throw errorMessage(`A ${code("package.json")} file was not found in the current working directory.\n` + hint("Try running the doctor command in your workspace folder."));
  }
  var D = Object.entries({
    ...a.dependencies,
    ...a.devDependencies
  });
  var c = D.find((e => "typescript" === e[0]));
  if (!c) {
    yield failedTask(Ie.CHECK_TS_VERSION);
    throw errorMessage(`A version of ${code("typescript")} was not found in your dependencies.\n` + hint(`Is ${code("typescript")} installed in this package?`));
  } else if (!semiverComply(c[1], Ne)) {
    yield failedTask(Ie.CHECK_TS_VERSION);
    throw errorMessage(`The version of ${code("typescript")} in your dependencies is out of date.\n` + hint(`${code("gql.tada")} requires at least ${bold(Ne)}`));
  }
  yield completedTask(Ie.CHECK_TS_VERSION);
  yield runningTask(Ie.CHECK_DEPENDENCIES);
  await delay();
  var l = D.find((e => "@0no-co/graphqlsp" === e[0]));
  if (!l) {
    yield failedTask(Ie.CHECK_DEPENDENCIES);
    throw errorMessage(`A version of ${code("@0no-co/graphqlsp")} was not found in your dependencies.\n` + hint(`Is ${code("@0no-co/graphqlsp")} installed?`));
  } else if (!semiverComply(l[1], Pe)) {
    yield failedTask(Ie.CHECK_DEPENDENCIES);
    throw errorMessage(`The version of ${code("@0no-co/graphqlsp")} in your dependencies is out of date.\n` + hint(`${code("gql.tada")} requires at least ${bold(Pe)}`));
  }
  var d = D.find((e => "gql.tada" === e[0]));
  if (!d) {
    yield failedTask(Ie.CHECK_DEPENDENCIES);
    throw errorMessage(`A version of ${code("gql.tada")} was not found in your dependencies.\n` + hint(`Is ${code("gql.tada")} installed?`));
  } else if (!semiverComply(d[1], "1.0.0")) {
    yield failedTask(Ie.CHECK_DEPENDENCIES);
    throw errorMessage(`The version of ${code("gql.tada")} in your dependencies is out of date.\n` + hint(`It's recommended to upgrade ${code("gql.tada")} to at least ${bold(Pe)}`));
  }
  yield completedTask(Ie.CHECK_DEPENDENCIES);
  yield runningTask(Ie.CHECK_TSCONFIG);
  await delay();
  var f;
  try {
    f = await t.loadConfig();
  } catch (e) {
    yield failedTask(Ie.CHECK_TSCONFIG);
    throw externalError(`A ${code("tsconfig.json")} file was not found in the current working directory.`, e);
  }
  var p;
  try {
    p = t.parseConfig(f.pluginConfig);
  } catch (e) {
    throw externalError(`The plugin configuration for ${code('"@0no-co/graphqlsp"')} seems to be invalid.`, e);
  }
  if (!p.schema) {
    yield failedTask(Ie.CHECK_TSCONFIG);
    throw errorMessage(`No ${code('"schema"')} option was found in your configuration.\n` + hint("Have you specified your SDL file or URL in your configuration yet?"));
  }
  yield completedTask(Ie.CHECK_TSCONFIG);
  yield runningTask(Ie.CHECK_SCHEMA);
  await delay();
  var h = t.load({
    origin: p.schema,
    rootPath: e.dirname(f.configPath)
  });
  try {
    await h.loadIntrospection();
  } catch (e) {
    throw externalError("Failed to load schema.", e);
  }
  yield completedTask(Ie.CHECK_SCHEMA, !0);
  await delay();
  yield function success() {
    return text([ "\n", cmd(ae.Style, [ le.Green, le.Invert ]), " Done ", cmd(ae.Style, le.NoInvert), pe.Space, "You are all set and ready to go.\n" ]);
  }();
}

class DoctorCommand extends Command {
  static paths=[ [ "doctor" ] ];
  async execute() {
    var e = await initTTY().start(run$1());
    return process.exitCode || ("object" == typeof e ? e.exit : 0);
  }
}

function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}

var Me = "[";

var je = {
  to(e, t) {
    if (!t) {
      return `${Me}${e + 1}G`;
    }
    return `${Me}${t + 1};${e + 1}H`;
  },
  move(e, t) {
    var r = "";
    if (e < 0) {
      r += `${Me}${-e}D`;
    } else if (e > 0) {
      r += `${Me}${e}C`;
    }
    if (t < 0) {
      r += `${Me}${-t}A`;
    } else if (t > 0) {
      r += `${Me}${t}B`;
    }
    return r;
  },
  up: (e = 1) => `${Me}${e}A`,
  down: (e = 1) => `${Me}${e}B`,
  forward: (e = 1) => `${Me}${e}C`,
  backward: (e = 1) => `${Me}${e}D`,
  nextLine: (e = 1) => `${Me}E`.repeat(e),
  prevLine: (e = 1) => `${Me}F`.repeat(e),
  left: `${Me}G`,
  hide: `${Me}?25l`,
  show: `${Me}?25h`,
  save: "7",
  restore: "8"
};

var Le = {
  screen: `${Me}2J`,
  up: (e = 1) => `${Me}1J`.repeat(e),
  down: (e = 1) => `${Me}J`.repeat(e),
  line: `${Me}2K`,
  lineEnd: `${Me}K`,
  lineStart: `${Me}1K`,
  lines(e) {
    var t = "";
    for (var r = 0; r < e; r++) {
      t += this.line + (r < e - 1 ? je.up() : "");
    }
    if (e) {
      t += je.left;
    }
    return t;
  }
};

var Re = {
  cursor: je,
  scroll: {
    up: (e = 1) => `${Me}S`.repeat(e),
    down: (e = 1) => `${Me}T`.repeat(e)
  },
  erase: Le,
  beep: ""
};

var Ue = {
  exports: {}
};

var _e = String;

var create = function() {
  return {
    isColorSupported: !1,
    reset: _e,
    bold: _e,
    dim: _e,
    italic: _e,
    underline: _e,
    inverse: _e,
    hidden: _e,
    strikethrough: _e,
    black: _e,
    red: _e,
    green: _e,
    yellow: _e,
    blue: _e,
    magenta: _e,
    cyan: _e,
    white: _e,
    gray: _e,
    bgBlack: _e,
    bgRed: _e,
    bgGreen: _e,
    bgYellow: _e,
    bgBlue: _e,
    bgMagenta: _e,
    bgCyan: _e,
    bgWhite: _e
  };
};

Ue.exports = create();

Ue.exports.createColors = create;

var Ge = getDefaultExportFromCjs(Ue.exports);

function S$1(e) {
  if ("string" != typeof e) {
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  }
  return e.replace(function q$1({onlyFirst: e = !1} = {}) {
    var t = [ "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))" ].join("|");
    return new RegExp(t, e ? void 0 : "g");
  }(), "");
}

function j(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}

var qe = {
  exports: {}
};

!function(e) {
  var t = {};
  qe.exports = t, t.eastAsianWidth = function(e) {
    var t = e.charCodeAt(0), r = 2 == e.length ? e.charCodeAt(1) : 0, n = t;
    return 55296 <= t && t <= 56319 && 56320 <= r && r <= 57343 && (n = (t &= 1023) << 10 | (r &= 1023), 
    n += 65536), 12288 == n || 65281 <= n && n <= 65376 || 65504 <= n && n <= 65510 ? "F" : 8361 == n || 65377 <= n && n <= 65470 || 65474 <= n && n <= 65479 || 65482 <= n && n <= 65487 || 65490 <= n && n <= 65495 || 65498 <= n && n <= 65500 || 65512 <= n && n <= 65518 ? "H" : 4352 <= n && n <= 4447 || 4515 <= n && n <= 4519 || 4602 <= n && n <= 4607 || 9001 <= n && n <= 9002 || 11904 <= n && n <= 11929 || 11931 <= n && n <= 12019 || 12032 <= n && n <= 12245 || 12272 <= n && n <= 12283 || 12289 <= n && n <= 12350 || 12353 <= n && n <= 12438 || 12441 <= n && n <= 12543 || 12549 <= n && n <= 12589 || 12593 <= n && n <= 12686 || 12688 <= n && n <= 12730 || 12736 <= n && n <= 12771 || 12784 <= n && n <= 12830 || 12832 <= n && n <= 12871 || 12880 <= n && n <= 13054 || 13056 <= n && n <= 19903 || 19968 <= n && n <= 42124 || 42128 <= n && n <= 42182 || 43360 <= n && n <= 43388 || 44032 <= n && n <= 55203 || 55216 <= n && n <= 55238 || 55243 <= n && n <= 55291 || 63744 <= n && n <= 64255 || 65040 <= n && n <= 65049 || 65072 <= n && n <= 65106 || 65108 <= n && n <= 65126 || 65128 <= n && n <= 65131 || 110592 <= n && n <= 110593 || 127488 <= n && n <= 127490 || 127504 <= n && n <= 127546 || 127552 <= n && n <= 127560 || 127568 <= n && n <= 127569 || 131072 <= n && n <= 194367 || 177984 <= n && n <= 196605 || 196608 <= n && n <= 262141 ? "W" : 32 <= n && n <= 126 || 162 <= n && n <= 163 || 165 <= n && n <= 166 || 172 == n || 175 == n || 10214 <= n && n <= 10221 || 10629 <= n && n <= 10630 ? "Na" : 161 == n || 164 == n || 167 <= n && n <= 168 || 170 == n || 173 <= n && n <= 174 || 176 <= n && n <= 180 || 182 <= n && n <= 186 || 188 <= n && n <= 191 || 198 == n || 208 == n || 215 <= n && n <= 216 || 222 <= n && n <= 225 || 230 == n || 232 <= n && n <= 234 || 236 <= n && n <= 237 || 240 == n || 242 <= n && n <= 243 || 247 <= n && n <= 250 || 252 == n || 254 == n || 257 == n || 273 == n || 275 == n || 283 == n || 294 <= n && n <= 295 || 299 == n || 305 <= n && n <= 307 || 312 == n || 319 <= n && n <= 322 || 324 == n || 328 <= n && n <= 331 || 333 == n || 338 <= n && n <= 339 || 358 <= n && n <= 359 || 363 == n || 462 == n || 464 == n || 466 == n || 468 == n || 470 == n || 472 == n || 474 == n || 476 == n || 593 == n || 609 == n || 708 == n || 711 == n || 713 <= n && n <= 715 || 717 == n || 720 == n || 728 <= n && n <= 731 || 733 == n || 735 == n || 768 <= n && n <= 879 || 913 <= n && n <= 929 || 931 <= n && n <= 937 || 945 <= n && n <= 961 || 963 <= n && n <= 969 || 1025 == n || 1040 <= n && n <= 1103 || 1105 == n || 8208 == n || 8211 <= n && n <= 8214 || 8216 <= n && n <= 8217 || 8220 <= n && n <= 8221 || 8224 <= n && n <= 8226 || 8228 <= n && n <= 8231 || 8240 == n || 8242 <= n && n <= 8243 || 8245 == n || 8251 == n || 8254 == n || 8308 == n || 8319 == n || 8321 <= n && n <= 8324 || 8364 == n || 8451 == n || 8453 == n || 8457 == n || 8467 == n || 8470 == n || 8481 <= n && n <= 8482 || 8486 == n || 8491 == n || 8531 <= n && n <= 8532 || 8539 <= n && n <= 8542 || 8544 <= n && n <= 8555 || 8560 <= n && n <= 8569 || 8585 == n || 8592 <= n && n <= 8601 || 8632 <= n && n <= 8633 || 8658 == n || 8660 == n || 8679 == n || 8704 == n || 8706 <= n && n <= 8707 || 8711 <= n && n <= 8712 || 8715 == n || 8719 == n || 8721 == n || 8725 == n || 8730 == n || 8733 <= n && n <= 8736 || 8739 == n || 8741 == n || 8743 <= n && n <= 8748 || 8750 == n || 8756 <= n && n <= 8759 || 8764 <= n && n <= 8765 || 8776 == n || 8780 == n || 8786 == n || 8800 <= n && n <= 8801 || 8804 <= n && n <= 8807 || 8810 <= n && n <= 8811 || 8814 <= n && n <= 8815 || 8834 <= n && n <= 8835 || 8838 <= n && n <= 8839 || 8853 == n || 8857 == n || 8869 == n || 8895 == n || 8978 == n || 9312 <= n && n <= 9449 || 9451 <= n && n <= 9547 || 9552 <= n && n <= 9587 || 9600 <= n && n <= 9615 || 9618 <= n && n <= 9621 || 9632 <= n && n <= 9633 || 9635 <= n && n <= 9641 || 9650 <= n && n <= 9651 || 9654 <= n && n <= 9655 || 9660 <= n && n <= 9661 || 9664 <= n && n <= 9665 || 9670 <= n && n <= 9672 || 9675 == n || 9678 <= n && n <= 9681 || 9698 <= n && n <= 9701 || 9711 == n || 9733 <= n && n <= 9734 || 9737 == n || 9742 <= n && n <= 9743 || 9748 <= n && n <= 9749 || 9756 == n || 9758 == n || 9792 == n || 9794 == n || 9824 <= n && n <= 9825 || 9827 <= n && n <= 9829 || 9831 <= n && n <= 9834 || 9836 <= n && n <= 9837 || 9839 == n || 9886 <= n && n <= 9887 || 9918 <= n && n <= 9919 || 9924 <= n && n <= 9933 || 9935 <= n && n <= 9953 || 9955 == n || 9960 <= n && n <= 9983 || 10045 == n || 10071 == n || 10102 <= n && n <= 10111 || 11093 <= n && n <= 11097 || 12872 <= n && n <= 12879 || 57344 <= n && n <= 63743 || 65024 <= n && n <= 65039 || 65533 == n || 127232 <= n && n <= 127242 || 127248 <= n && n <= 127277 || 127280 <= n && n <= 127337 || 127344 <= n && n <= 127386 || 917760 <= n && n <= 917999 || 983040 <= n && n <= 1048573 || 1048576 <= n && n <= 1114109 ? "A" : "N";
  }, t.characterLength = function(e) {
    var t = this.eastAsianWidth(e);
    return "F" == t || "W" == t || "A" == t ? 2 : 1;
  };
  function F(e) {
    return e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  t.length = function(e) {
    for (var t = F(e), r = 0, n = 0; n < t.length; n++) {
      r += this.characterLength(t[n]);
    }
    return r;
  }, t.slice = function(e, r, n) {
    textLen = t.length(e), n = n || 1, (r = r || 0) < 0 && (r = textLen + r), n < 0 && (n = textLen + n);
    for (var i = "", a = 0, s = F(e), D = 0; D < s.length; D++) {
      var c = s[D], l = t.length(c);
      if (a >= r - (2 == l ? 1 : 0)) {
        if (a + l <= n) {
          i += c;
        } else {
          break;
        }
      }
      a += l;
    }
    return i;
  };
}();

var We = j(qe.exports);

var Ve = j((function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
}));

function A(e, t = {}) {
  if ("string" != typeof e || 0 === e.length || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, 0 === (e = S$1(e)).length)) {
    return 0;
  }
  e = e.replace(Ve(), "  ");
  var r = t.ambiguousIsNarrow ? 1 : 2;
  var n = 0;
  for (var i of e) {
    var a = i.codePointAt(0);
    if (a <= 31 || a >= 127 && a <= 159 || a >= 768 && a <= 879) {
      continue;
    }
    switch (We.eastAsianWidth(i)) {
     case "F":
     case "W":
      n += 2;
      break;

     case "A":
      n += r;
      break;

     default:
      n += 1;
    }
  }
  return n;
}

var T = (e = 0) => t => `[${t + e}m`, P = (e = 0) => t => `[${38 + e};5;${t}m`, W = (e = 0) => (t, r, n) => `[${38 + e};2;${t};${r};${n}m`, He = {
  modifier: {
    reset: [ 0, 0 ],
    bold: [ 1, 22 ],
    dim: [ 2, 22 ],
    italic: [ 3, 23 ],
    underline: [ 4, 24 ],
    overline: [ 53, 55 ],
    inverse: [ 7, 27 ],
    hidden: [ 8, 28 ],
    strikethrough: [ 9, 29 ]
  },
  color: {
    black: [ 30, 39 ],
    red: [ 31, 39 ],
    green: [ 32, 39 ],
    yellow: [ 33, 39 ],
    blue: [ 34, 39 ],
    magenta: [ 35, 39 ],
    cyan: [ 36, 39 ],
    white: [ 37, 39 ],
    blackBright: [ 90, 39 ],
    gray: [ 90, 39 ],
    grey: [ 90, 39 ],
    redBright: [ 91, 39 ],
    greenBright: [ 92, 39 ],
    yellowBright: [ 93, 39 ],
    blueBright: [ 94, 39 ],
    magentaBright: [ 95, 39 ],
    cyanBright: [ 96, 39 ],
    whiteBright: [ 97, 39 ]
  },
  bgColor: {
    bgBlack: [ 40, 49 ],
    bgRed: [ 41, 49 ],
    bgGreen: [ 42, 49 ],
    bgYellow: [ 43, 49 ],
    bgBlue: [ 44, 49 ],
    bgMagenta: [ 45, 49 ],
    bgCyan: [ 46, 49 ],
    bgWhite: [ 47, 49 ],
    bgBlackBright: [ 100, 49 ],
    bgGray: [ 100, 49 ],
    bgGrey: [ 100, 49 ],
    bgRedBright: [ 101, 49 ],
    bgGreenBright: [ 102, 49 ],
    bgYellowBright: [ 103, 49 ],
    bgBlueBright: [ 104, 49 ],
    bgMagentaBright: [ 105, 49 ],
    bgCyanBright: [ 106, 49 ],
    bgWhiteBright: [ 107, 49 ]
  }
};

Object.keys(He.modifier);

Object.keys(He.color), Object.keys(He.bgColor);

var Ke = function tD() {
  var e = new Map;
  for (var [t, r] of Object.entries(He)) {
    for (var [n, i] of Object.entries(r)) {
      He[n] = {
        open: `[${i[0]}m`,
        close: `[${i[1]}m`
      }, r[n] = He[n], e.set(i[0], i[1]);
    }
    Object.defineProperty(He, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(He, "codes", {
    value: e,
    enumerable: !1
  }), He.color.close = "[39m", He.bgColor.close = "[49m", He.color.ansi = T(), He.color.ansi256 = P(), 
  He.color.ansi16m = W(), He.bgColor.ansi = T(10), He.bgColor.ansi256 = P(10), He.bgColor.ansi16m = W(10), 
  Object.defineProperties(He, {
    rgbToAnsi256: {
      value: (e, t, r) => e === t && t === r ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(r / 255 * 5),
      enumerable: !1
    },
    hexToRgb: {
      value: e => {
        var t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));
        if (!t) {
          return [ 0, 0, 0 ];
        }
        var [r] = t;
        3 === r.length && (r = [ ...r ].map((e => e + e)).join(""));
        var n = Number.parseInt(r, 16);
        return [ n >> 16 & 255, n >> 8 & 255, 255 & n ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: e => He.rgbToAnsi256(...He.hexToRgb(e)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value: e => {
        if (e < 8) {
          return 30 + e;
        }
        if (e < 16) {
          return e - 8 + 90;
        }
        var t, r, n;
        if (e >= 232) {
          r = t = (10 * (e - 232) + 8) / 255, n = t;
        } else {
          var i = (e -= 16) % 36;
          t = Math.floor(e / 36) / 5, r = Math.floor(i / 6) / 5, n = i % 6 / 5;
        }
        var a = 2 * Math.max(t, r, n);
        if (0 === a) {
          return 30;
        }
        var s = 30 + (Math.round(n) << 2 | Math.round(r) << 1 | Math.round(t));
        return 2 === a && (s += 60), s;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (e, t, r) => He.ansi256ToAnsi(He.rgbToAnsi256(e, t, r)),
      enumerable: !1
    },
    hexToAnsi: {
      value: e => He.ansi256ToAnsi(He.hexToAnsi256(e)),
      enumerable: !1
    }
  }), He;
}(), Ye = new Set([ "", "¬õ" ]), ze = "]8;;", N = e => `${Ye.values().next().value}[${e}m`, L = e => `${Ye.values().next().value}${ze}${e}`, y$1 = (e, t, r) => {
  var n = [ ...t ];
  var i = !1, a = !1, s = A(S$1(e[e.length - 1]));
  for (var [D, c] of n.entries()) {
    var l = A(c);
    if (s + l <= r ? e[e.length - 1] += c : (e.push(c), s = 0), Ye.has(c) && (i = !0, 
    a = n.slice(D + 1).join("").startsWith(ze)), i) {
      a ? "" === c && (i = !1, a = !1) : "m" === c && (i = !1);
      continue;
    }
    (s += l) === r && D < n.length - 1 && (e.push(""), s = 0);
  }
  !s && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
}, ED = (e, t, r = {}) => {
  if (!1 !== r.trim && "" === e.trim()) {
    return "";
  }
  var n, i, a = "";
  var s = (e => e.split(" ").map((e => A(e))))(e);
  var D = [ "" ];
  for (var [c, l] of e.split(" ").entries()) {
    !1 !== r.trim && (D[D.length - 1] = D[D.length - 1].trimStart());
    var d = A(D[D.length - 1]);
    if (0 !== c && (d >= t && (!1 === r.wordWrap || !1 === r.trim) && (D.push(""), d = 0), 
    (d > 0 || !1 === r.trim) && (D[D.length - 1] += " ", d++)), r.hard && s[c] > t) {
      var f = 1 + Math.floor((s[c] - (t - d) - 1) / t);
      Math.floor((s[c] - 1) / t) < f && D.push(""), y$1(D, l, t);
      continue;
    }
    if (d + s[c] > t && d > 0 && s[c] > 0) {
      if (!1 === r.wordWrap && d < t) {
        y$1(D, l, t);
        continue;
      }
      D.push("");
    }
    if (d + s[c] > t && !1 === r.wordWrap) {
      y$1(D, l, t);
      continue;
    }
    D[D.length - 1] += l;
  }
  !1 !== r.trim && (D = D.map((e => (e => {
    var t = e.split(" ");
    var r = t.length;
    for (;r > 0 && !(A(t[r - 1]) > 0); ) {
      r--;
    }
    return r === t.length ? e : t.slice(0, r).join(" ") + t.slice(r).join("");
  })(e))));
  var p = [ ...D.join("\n") ];
  for (var [h, m] of p.entries()) {
    if (a += m, Ye.has(m)) {
      var {groups: g} = new RegExp(`(?:\\[(?<code>\\d+)m|\\${ze}(?<uri>.*))`).exec(p.slice(h).join("")) || {
        groups: {}
      };
      if (void 0 !== g.code) {
        var E = Number.parseFloat(g.code);
        n = 39 === E ? void 0 : E;
      } else {
        void 0 !== g.uri && (i = 0 === g.uri.length ? void 0 : g.uri);
      }
    }
    var w = Ke.codes.get(Number(n));
    "\n" === p[h + 1] ? (i && (a += L("")), n && w && (a += N(w))) : "\n" === m && (n && w && (a += N(n)), 
    i && (a += L(i)));
  }
  return a;
};

function R(e, t, r) {
  return String(e).normalize().replace(/\r\n/g, "\n").split("\n").map((e => ED(e, t, r))).join("\n");
}

var Je = Object.defineProperty, a$1 = (e, t, r) => (((e, t, r) => {
  t in e ? Je(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
  }) : e[t] = r;
})(e, "symbol" != typeof t ? t + "" : t, r), r);

var Ze = Symbol("clack:cancel");

function hD(e) {
  return e === Ze;
}

function v(e, t) {
  e.isTTY && e.setRawMode(t);
}

var Xe = new Map([ [ "k", "up" ], [ "j", "down" ], [ "h", "left" ], [ "l", "right" ] ]), Qe = new Set([ "up", "down", "left", "right", "space", "enter" ]);

let et = class x {
  constructor({render: e, input: t = a.stdin, output: r = a.stdout, ...n}, i = !0) {
    a$1(this, "input"), a$1(this, "output"), a$1(this, "rl"), a$1(this, "opts"), a$1(this, "_track", !1), 
    a$1(this, "_render"), a$1(this, "_cursor", 0), a$1(this, "state", "initial"), a$1(this, "value"), 
    a$1(this, "error", ""), a$1(this, "subscribers", new Map), a$1(this, "_prevFrame", ""), 
    this.opts = n, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), 
    this.render = this.render.bind(this), this._render = e.bind(this), this._track = i, 
    this.input = t, this.output = r;
  }
  prompt() {
    var e = new s.WriteStream(0);
    return e._write = (e, t, r) => {
      this._track && (this.value = this.rl.line.replace(/\t/g, ""), this._cursor = this.rl.cursor, 
      this.emit("value", this.value)), r();
    }, this.input.pipe(e), this.rl = n.createInterface({
      input: this.input,
      output: e,
      tabSize: 2,
      prompt: "",
      escapeCodeTimeout: 50
    }), n.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), void 0 !== this.opts.initialValue && this._track && this.rl.write(this.opts.initialValue), 
    this.input.on("keypress", this.onKeypress), v(this.input, !0), this.output.on("resize", this.render), 
    this.render(), new Promise(((e, t) => {
      this.once("submit", (() => {
        this.output.write(Re.cursor.show), this.output.off("resize", this.render), v(this.input, !1), 
        e(this.value);
      })), this.once("cancel", (() => {
        this.output.write(Re.cursor.show), this.output.off("resize", this.render), v(this.input, !1), 
        e(Ze);
      }));
    }));
  }
  on(e, t) {
    var r = this.subscribers.get(e) ?? [];
    r.push({
      cb: t
    }), this.subscribers.set(e, r);
  }
  once(e, t) {
    var r = this.subscribers.get(e) ?? [];
    r.push({
      cb: t,
      once: !0
    }), this.subscribers.set(e, r);
  }
  emit(e, ...t) {
    var r = this.subscribers.get(e) ?? [], n = [];
    var _loop = function(e) {
      e.cb(...t), e.once && n.push((() => r.splice(r.indexOf(e), 1)));
    };
    for (var i of r) {
      _loop(i);
    }
    for (var a of n) {
      a();
    }
  }
  unsubscribe() {
    this.subscribers.clear();
  }
  onKeypress(e, t) {
    if ("error" === this.state && (this.state = "active"), t?.name && !this._track && Xe.has(t.name) && this.emit("cursor", Xe.get(t.name)), 
    t?.name && Qe.has(t.name) && this.emit("cursor", t.name), e && ("y" === e.toLowerCase() || "n" === e.toLowerCase()) && this.emit("confirm", "y" === e.toLowerCase()), 
    "\t" === e && this.opts.placeholder && (this.value || (this.rl.write(this.opts.placeholder), 
    this.emit("value", this.opts.placeholder))), e && this.emit("key", e.toLowerCase()), 
    "return" === t?.name) {
      if (this.opts.validate) {
        var r = this.opts.validate(this.value);
        r && (this.error = r, this.state = "error", this.rl.write(this.value));
      }
      "error" !== this.state && (this.state = "submit");
    }
    "" === e && (this.state = "cancel"), ("submit" === this.state || "cancel" === this.state) && this.emit("finalize"), 
    this.render(), ("submit" === this.state || "cancel" === this.state) && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write("\n"), 
    v(this.input, !1), this.rl.close(), this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    var e = R(this._prevFrame, process.stdout.columns, {
      hard: !0
    }).split("\n").length - 1;
    this.output.write(Re.cursor.move(-999, -1 * e));
  }
  render() {
    var e = R(this._render(this) ?? "", process.stdout.columns, {
      hard: !0
    });
    if (e !== this._prevFrame) {
      if ("initial" === this.state) {
        this.output.write(Re.cursor.hide);
      } else {
        var t = function aD(e, t) {
          if (e === t) {
            return;
          }
          var r = e.split("\n"), n = t.split("\n"), i = [];
          for (var a = 0; a < Math.max(r.length, n.length); a++) {
            r[a] !== n[a] && i.push(a);
          }
          return i;
        }(this._prevFrame, e);
        if (this.restoreCursor(), t && 1 === t?.length) {
          var r = t[0];
          this.output.write(Re.cursor.move(0, r)), this.output.write(Re.erase.lines(1));
          var n = e.split("\n");
          this.output.write(n[r]), this._prevFrame = e, this.output.write(Re.cursor.move(0, n.length - r - 1));
          return;
        } else if (t && t?.length > 1) {
          var i = t[0];
          this.output.write(Re.cursor.move(0, i)), this.output.write(Re.erase.down());
          var a = e.split("\n").slice(i);
          this.output.write(a.join("\n")), this._prevFrame = e;
          return;
        }
        this.output.write(Re.erase.down());
      }
      this.output.write(e), "initial" === this.state && (this.state = "active"), this._prevFrame = e;
    }
  }
};

class xD extends et {
  get cursor() {
    return this.value ? 0 : 1;
  }
  get _value() {
    return 0 === this.cursor;
  }
  constructor(e) {
    super(e, !1), this.value = !!e.initialValue, this.on("value", (() => {
      this.value = this._value;
    })), this.on("confirm", (e => {
      this.output.write(Re.cursor.move(0, -1)), this.value = e, this.state = "submit", 
      this.close();
    })), this.on("cursor", (() => {
      this.value = !this.value;
    }));
  }
}

var tt = Object.defineProperty, MD = (e, t, r) => (((e, t, r) => {
  t in e ? tt(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
  }) : e[t] = r;
})(e, "symbol" != typeof t ? t + "" : t, r), r);

class TD extends et {
  constructor(e) {
    super(e), MD(this, "valueWithCursor", ""), this.on("finalize", (() => {
      this.value || (this.value = e.defaultValue), this.valueWithCursor = this.value;
    })), this.on("value", (() => {
      if (this.cursor >= this.value.length) {
        this.valueWithCursor = `${this.value}${Ge.inverse(Ge.hidden("_"))}`;
      } else {
        var e = this.value.slice(0, this.cursor), t = this.value.slice(this.cursor);
        this.valueWithCursor = `${e}${Ge.inverse(t[0])}${t.slice(1)}`;
      }
    }));
  }
  get cursor() {
    return this._cursor;
  }
}

var rt = globalThis.process.platform.startsWith("win");

var nt = function q() {
  return "win32" !== a.platform ? "linux" !== a.env.TERM : Boolean(a.env.CI) || Boolean(a.env.WT_SESSION) || Boolean(a.env.TERMINUS_SUBLIME) || "{cmd::Cmder}" === a.env.ConEmuTask || "Terminus-Sublime" === a.env.TERM_PROGRAM || "vscode" === a.env.TERM_PROGRAM || "xterm-256color" === a.env.TERM || "alacritty" === a.env.TERM || "JetBrains-JediTerm" === a.env.TERMINAL_EMULATOR;
}(), o = (e, t) => nt ? e : t, it = o("‚óÜ", "*"), ut = o("‚ñ†", "x"), at = o("‚ñ≤", "x"), ot = o("‚óá", "o"), st = o("‚îå", "T"), Dt = o("‚îÇ", "|"), ct = o("‚îî", "‚Äî"), lt = o("‚óè", ">"), dt = o("‚óã", " "), y = e => {
  switch (e) {
   case "initial":
   case "active":
    return Ge.cyan(it);

   case "cancel":
    return Ge.red(ut);

   case "error":
    return Ge.yellow(at);

   case "submit":
    return Ge.green(ot);
  }
}, te = e => new TD({
  validate: e.validate,
  placeholder: e.placeholder,
  defaultValue: e.defaultValue,
  initialValue: e.initialValue,
  render() {
    var t = `${Ge.gray(Dt)}\n${y(this.state)}  ${e.message}\n`, r = e.placeholder ? Ge.inverse(e.placeholder[0]) + Ge.dim(e.placeholder.slice(1)) : Ge.inverse(Ge.hidden("_")), n = this.value ? this.valueWithCursor : r;
    switch (this.state) {
     case "error":
      return `${t.trim()}\n${Ge.yellow(Dt)}  ${n}\n${Ge.yellow(ct)}  ${Ge.yellow(this.error)}\n`;

     case "submit":
      return `${t}${Ge.gray(Dt)}  ${Ge.dim(this.value || e.placeholder)}`;

     case "cancel":
      return `${t}${Ge.gray(Dt)}  ${Ge.strikethrough(Ge.dim(this.value ?? ""))}${this.value?.trim() ? "\n" + Ge.gray(Dt) : ""}`;

     default:
      return `${t}${Ge.cyan(Dt)}  ${n}\n${Ge.cyan(ct)}\n`;
    }
  }
}).prompt(), se = e => {
  var t = e.active ?? "Yes", r = e.inactive ?? "No";
  return new xD({
    active: t,
    inactive: r,
    initialValue: e.initialValue ?? !0,
    render() {
      var n = `${Ge.gray(Dt)}\n${y(this.state)}  ${e.message}\n`, i = this.value ? t : r;
      switch (this.state) {
       case "submit":
        return `${n}${Ge.gray(Dt)}  ${Ge.dim(i)}`;

       case "cancel":
        return `${n}${Ge.gray(Dt)}  ${Ge.strikethrough(Ge.dim(i))}\n${Ge.gray(Dt)}`;

       default:
        return `${n}${Ge.cyan(Dt)}  ${this.value ? `${Ge.green(lt)} ${t}` : `${Ge.dim(dt)} ${Ge.dim(t)}`} ${Ge.dim("/")} ${this.value ? `${Ge.dim(dt)} ${Ge.dim(r)}` : `${Ge.green(lt)} ${r}`}\n${Ge.cyan(ct)}\n`;
      }
    }
  }).prompt();
}, ue = (e = "") => {
  process.stdout.write(`${Ge.gray(ct)}  ${Ge.red(e)}\n\n`);
};

var ft = {
  exports: {}
};

var pt;

var ht;

var vt;

var mt;

var gt;

if ("win32" === process.platform || global.TESTING_WINDOWS) {
  gt = function requireWindows() {
    if (mt) {
      return vt;
    }
    mt = 1;
    vt = isexe;
    isexe.sync = function sync(t, r) {
      return checkStat(e.statSync(t), t, r);
    };
    var e = l;
    function checkStat(e, t, r) {
      if (!e.isSymbolicLink() && !e.isFile()) {
        return !1;
      }
      return function checkPathExt(e, t) {
        var r = void 0 !== t.pathExt ? t.pathExt : process.env.PATHEXT;
        if (!r) {
          return !0;
        }
        if (-1 !== (r = r.split(";")).indexOf("")) {
          return !0;
        }
        for (var n = 0; n < r.length; n++) {
          var i = r[n].toLowerCase();
          if (i && e.substr(-i.length).toLowerCase() === i) {
            return !0;
          }
        }
        return !1;
      }(t, r);
    }
    function isexe(t, r, n) {
      e.stat(t, (function(e, i) {
        n(e, e ? !1 : checkStat(i, t, r));
      }));
    }
    return vt;
  }();
} else {
  gt = function requireMode() {
    if (ht) {
      return pt;
    }
    ht = 1;
    pt = isexe;
    isexe.sync = function sync(t, r) {
      return checkStat(e.statSync(t), r);
    };
    var e = l;
    function isexe(t, r, n) {
      e.stat(t, (function(e, t) {
        n(e, e ? !1 : checkStat(t, r));
      }));
    }
    function checkStat(e, t) {
      return e.isFile() && function checkMode(e, t) {
        var r = e.mode;
        var n = e.uid;
        var i = e.gid;
        var a = void 0 !== t.uid ? t.uid : process.getuid && process.getuid();
        var s = void 0 !== t.gid ? t.gid : process.getgid && process.getgid();
        var D = parseInt("100", 8);
        var c = parseInt("010", 8);
        return r & parseInt("001", 8) || r & c && i === s || r & D && n === a || r & (D | c) && 0 === a;
      }(e, t);
    }
    return pt;
  }();
}

var Ct = isexe$1;

isexe$1.sync = function sync(e, t) {
  try {
    return gt.sync(e, t || {});
  } catch (e) {
    if (t && t.ignoreErrors || "EACCES" === e.code) {
      return !1;
    } else {
      throw e;
    }
  }
};

function isexe$1(e, t, r) {
  if ("function" == typeof t) {
    r = t;
    t = {};
  }
  if (!r) {
    if ("function" != typeof Promise) {
      throw new TypeError("callback not provided");
    }
    return new Promise((function(r, n) {
      isexe$1(e, t || {}, (function(e, t) {
        if (e) {
          n(e);
        } else {
          r(t);
        }
      }));
    }));
  }
  gt(e, t || {}, (function(e, n) {
    if (e) {
      if ("EACCES" === e.code || t && t.ignoreErrors) {
        e = null;
        n = !1;
      }
    }
    r(e, n);
  }));
}

var Ft = "win32" === process.platform || "cygwin" === process.env.OSTYPE || "msys" === process.env.OSTYPE;

var Et = d;

var yt = Ft ? ";" : ":";

var wt = Ct;

var getNotFoundError = e => Object.assign(new Error(`not found: ${e}`), {
  code: "ENOENT"
});

var getPathInfo = (e, t) => {
  var r = t.colon || yt;
  var n = e.match(/\//) || Ft && e.match(/\\/) ? [ "" ] : [ ...Ft ? [ process.cwd() ] : [], ...(t.path || process.env.PATH || "").split(r) ];
  var i = Ft ? t.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
  var a = Ft ? i.split(r) : [ "" ];
  if (Ft) {
    if (-1 !== e.indexOf(".") && "" !== a[0]) {
      a.unshift("");
    }
  }
  return {
    pathEnv: n,
    pathExt: a,
    pathExtExe: i
  };
};

var which$1 = (e, t, r) => {
  if ("function" == typeof t) {
    r = t;
    t = {};
  }
  if (!t) {
    t = {};
  }
  var {pathEnv: n, pathExt: i, pathExtExe: a} = getPathInfo(e, t);
  var s = [];
  var step = r => new Promise(((i, a) => {
    if (r === n.length) {
      return t.all && s.length ? i(s) : a(getNotFoundError(e));
    }
    var D = n[r];
    var c = /^".*"$/.test(D) ? D.slice(1, -1) : D;
    var l = Et.join(c, e);
    var d = !c && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + l : l;
    i(subStep(d, r, 0));
  }));
  var subStep = (e, r, n) => new Promise(((D, c) => {
    if (n === i.length) {
      return D(step(r + 1));
    }
    var l = i[n];
    wt(e + l, {
      pathExt: a
    }, ((i, a) => {
      if (!i && a) {
        if (t.all) {
          s.push(e + l);
        } else {
          return D(e + l);
        }
      }
      return D(subStep(e, r, n + 1));
    }));
  }));
  return r ? step(0).then((e => r(null, e)), r) : step(0);
};

var bt = which$1;

which$1.sync = (e, t) => {
  t = t || {};
  var {pathEnv: r, pathExt: n, pathExtExe: i} = getPathInfo(e, t);
  var a = [];
  for (var s = 0; s < r.length; s++) {
    var D = r[s];
    var c = /^".*"$/.test(D) ? D.slice(1, -1) : D;
    var l = Et.join(c, e);
    var d = !c && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + l : l;
    for (var f = 0; f < n.length; f++) {
      var p = d + n[f];
      try {
        if (wt.sync(p, {
          pathExt: i
        })) {
          if (t.all) {
            a.push(p);
          } else {
            return p;
          }
        }
      } catch (e) {}
    }
  }
  if (t.all && a.length) {
    return a;
  }
  if (t.nothrow) {
    return null;
  }
  throw getNotFoundError(e);
};

var Bt = {
  exports: {}
};

var pathKey$1 = (e = {}) => {
  var t = e.env || process.env;
  if ("win32" !== (e.platform || process.platform)) {
    return "PATH";
  }
  return Object.keys(t).reverse().find((e => "PATH" === e.toUpperCase())) || "Path";
};

Bt.exports = pathKey$1;

Bt.exports.default = pathKey$1;

var St = d;

var xt = bt;

var $t = Bt.exports;

function resolveCommandAttempt(e, t) {
  var r = e.options.env || process.env;
  var n = process.cwd();
  var i = null != e.options.cwd;
  var a = i && void 0 !== process.chdir && !process.chdir.disabled;
  if (a) {
    try {
      process.chdir(e.options.cwd);
    } catch (e) {}
  }
  var s;
  try {
    s = xt.sync(e.command, {
      path: r[$t({
        env: r
      })],
      pathExt: t ? St.delimiter : void 0
    });
  } catch (e) {} finally {
    if (a) {
      process.chdir(n);
    }
  }
  if (s) {
    s = St.resolve(i ? e.options.cwd : "", s);
  }
  return s;
}

var At = function resolveCommand$1(e) {
  return resolveCommandAttempt(e) || resolveCommandAttempt(e, !0);
};

var Ot = {};

var Tt = /([()\][%!^"`<>&|;, *?])/g;

Ot.command = function escapeCommand(e) {
  return e = e.replace(Tt, "^$1");
};

Ot.argument = function escapeArgument(e, t) {
  e = (e = `"${e = (e = (e = `${e}`).replace(/(\\*)"/g, '$1$1\\"')).replace(/(\\*)$/, "$1$1")}"`).replace(Tt, "^$1");
  if (t) {
    e = e.replace(Tt, "^$1");
  }
  return e;
};

var kt = /^#!(.*)/;

var It = l;

var shebangCommand = (e = "") => {
  var t = e.match(kt);
  if (!t) {
    return null;
  }
  var [r, n] = t[0].replace(/#! ?/, "").split(" ");
  var i = r.split("/").pop();
  if ("env" === i) {
    return n;
  }
  return n ? `${i} ${n}` : i;
};

var Nt = d;

var Pt = At;

var Mt = Ot;

var jt = function readShebang$1(e) {
  var t = Buffer.alloc(150);
  var r;
  try {
    r = It.openSync(e, "r");
    It.readSync(r, t, 0, 150, 0);
    It.closeSync(r);
  } catch (e) {}
  return shebangCommand(t.toString());
};

var Lt = "win32" === process.platform;

var Rt = /\.(?:com|exe)$/i;

var Ut = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function parseNonShell(e) {
  if (!Lt) {
    return e;
  }
  var t = function detectShebang(e) {
    e.file = Pt(e);
    var t = e.file && jt(e.file);
    if (t) {
      e.args.unshift(e.file);
      e.command = t;
      return Pt(e);
    }
    return e.file;
  }(e);
  var r = !Rt.test(t);
  if (e.options.forceShell || r) {
    var n = Ut.test(t);
    e.command = Nt.normalize(e.command);
    e.command = Mt.command(e.command);
    e.args = e.args.map((e => Mt.argument(e, n)));
    var i = [ e.command ].concat(e.args).join(" ");
    e.args = [ "/d", "/s", "/c", `"${i}"` ];
    e.command = process.env.comspec || "cmd.exe";
    e.options.windowsVerbatimArguments = !0;
  }
  return e;
}

var _t = "win32" === process.platform;

function notFoundError(e, t) {
  return Object.assign(new Error(`${t} ${e.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${t} ${e.command}`,
    path: e.command,
    spawnargs: e.args
  });
}

function verifyENOENT(e, t) {
  if (_t && 1 === e && !t.file) {
    return notFoundError(t.original, "spawn");
  }
  return null;
}

var Gt = {
  hookChildProcess: function hookChildProcess(e, t) {
    if (!_t) {
      return;
    }
    var r = e.emit;
    e.emit = function(n, i) {
      if ("exit" === n) {
        var a = verifyENOENT(i, t);
        if (a) {
          return r.call(e, "error", a);
        }
      }
      return r.apply(e, arguments);
    };
  },
  verifyENOENT,
  verifyENOENTSync: function verifyENOENTSync(e, t) {
    if (_t && 1 === e && !t.file) {
      return notFoundError(t.original, "spawnSync");
    }
    return null;
  },
  notFoundError
};

var qt = f;

var Wt = function parse$1(e, t, r) {
  if (t && !Array.isArray(t)) {
    r = t;
    t = null;
  }
  var n = {
    command: e,
    args: t = t ? t.slice(0) : [],
    options: r = Object.assign({}, r),
    file: void 0,
    original: {
      command: e,
      args: t
    }
  };
  return r.shell ? n : parseNonShell(n);
};

var Vt = Gt;

function spawn(e, t, r) {
  var n = Wt(e, t, r);
  var i = qt.spawn(n.command, n.args, n.options);
  Vt.hookChildProcess(i, n);
  return i;
}

ft.exports = spawn;

ft.exports.spawn = spawn;

ft.exports.sync = function spawnSync(e, t, r) {
  var n = Wt(e, t, r);
  var i = qt.spawnSync(n.command, n.args, n.options);
  i.error = i.error || Vt.verifyENOENTSync(i.status, n);
  return i;
};

ft.exports._parse = Wt;

ft.exports._enoent = Vt;

var Ht = getDefaultExportFromCjs(ft.exports);

function pathKey(e = {}) {
  var {env: t = process.env, platform: r = process.platform} = e;
  if ("win32" !== r) {
    return "PATH";
  }
  return Object.keys(t).reverse().find((e => "PATH" === e.toUpperCase())) || "Path";
}

function npmRunPathEnv({env: t = a.env, ...r} = {}) {
  var n = pathKey({
    env: t = {
      ...t
    }
  });
  r.path = t[n];
  t[n] = function npmRunPath(t = {}) {
    var {cwd: r = a.cwd(), path: n = a.env[pathKey()], execPath: i = a.execPath} = t;
    var s;
    var D = i instanceof URL ? p.fileURLToPath(i) : i;
    var c = r instanceof URL ? p.fileURLToPath(r) : r;
    var l = e.resolve(c);
    var d = [];
    while (s !== l) {
      d.push(e.join(l, "node_modules/.bin"));
      s = l;
      l = e.resolve(l, "..");
    }
    d.push(e.resolve(c, D, ".."));
    return [ ...d, n ].join(e.delimiter);
  }(r);
  return t;
}

var copyProperty = (e, t, r, n) => {
  if ("length" === r || "prototype" === r) {
    return;
  }
  if ("arguments" === r || "caller" === r) {
    return;
  }
  var i = Object.getOwnPropertyDescriptor(e, r);
  var a = Object.getOwnPropertyDescriptor(t, r);
  if (!canCopyProperty(i, a) && n) {
    return;
  }
  Object.defineProperty(e, r, a);
};

var canCopyProperty = function(e, t) {
  return void 0 === e || e.configurable || e.writable === t.writable && e.enumerable === t.enumerable && e.configurable === t.configurable && (e.writable || e.value === t.value);
};

var wrappedToString = (e, t) => `/* Wrapped ${e}*/\n${t}`;

var Kt = Object.getOwnPropertyDescriptor(Function.prototype, "toString");

var Yt = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");

function mimicFunction(e, t, {ignoreNonConfigurable: r = !1} = {}) {
  var {name: n} = e;
  for (var i of Reflect.ownKeys(t)) {
    copyProperty(e, t, i, r);
  }
  ((e, t) => {
    var r = Object.getPrototypeOf(t);
    if (r === Object.getPrototypeOf(e)) {
      return;
    }
    Object.setPrototypeOf(e, r);
  })(e, t);
  ((e, t, r) => {
    var n = "" === r ? "" : `with ${r.trim()}() `;
    var i = wrappedToString.bind(null, n, t.toString());
    Object.defineProperty(i, "name", Yt);
    Object.defineProperty(e, "toString", {
      ...Kt,
      value: i
    });
  })(e, t, n);
  return e;
}

var zt = new WeakMap;

var onetime = (e, t = {}) => {
  if ("function" != typeof e) {
    throw new TypeError("Expected a function");
  }
  var r;
  var n = 0;
  var i = e.displayName || e.name || "<anonymous>";
  var onetime = function(...a) {
    zt.set(onetime, ++n);
    if (1 === n) {
      r = e.apply(this, a);
      e = null;
    } else if (!0 === t.throw) {
      throw new Error(`Function \`${i}\` can only be called once`);
    }
    return r;
  };
  mimicFunction(onetime, e);
  zt.set(onetime, n);
  return onetime;
};

onetime.callCount = e => {
  if (!zt.has(e)) {
    throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`);
  }
  return zt.get(e);
};

var getRealtimeSignal = (e, t) => ({
  name: `SIGRT${t + 1}`,
  number: Jt + t,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});

var Jt = 34;

var Zt = 64;

var Xt = [ {
  name: "SIGHUP",
  number: 1,
  action: "terminate",
  description: "Terminal closed",
  standard: "posix"
}, {
  name: "SIGINT",
  number: 2,
  action: "terminate",
  description: "User interruption with CTRL-C",
  standard: "ansi"
}, {
  name: "SIGQUIT",
  number: 3,
  action: "core",
  description: "User interruption with CTRL-\\",
  standard: "posix"
}, {
  name: "SIGILL",
  number: 4,
  action: "core",
  description: "Invalid machine instruction",
  standard: "ansi"
}, {
  name: "SIGTRAP",
  number: 5,
  action: "core",
  description: "Debugger breakpoint",
  standard: "posix"
}, {
  name: "SIGABRT",
  number: 6,
  action: "core",
  description: "Aborted",
  standard: "ansi"
}, {
  name: "SIGIOT",
  number: 6,
  action: "core",
  description: "Aborted",
  standard: "bsd"
}, {
  name: "SIGBUS",
  number: 7,
  action: "core",
  description: "Bus error due to misaligned, non-existing address or paging error",
  standard: "bsd"
}, {
  name: "SIGEMT",
  number: 7,
  action: "terminate",
  description: "Command should be emulated but is not implemented",
  standard: "other"
}, {
  name: "SIGFPE",
  number: 8,
  action: "core",
  description: "Floating point arithmetic error",
  standard: "ansi"
}, {
  name: "SIGKILL",
  number: 9,
  action: "terminate",
  description: "Forced termination",
  standard: "posix",
  forced: !0
}, {
  name: "SIGUSR1",
  number: 10,
  action: "terminate",
  description: "Application-specific signal",
  standard: "posix"
}, {
  name: "SIGSEGV",
  number: 11,
  action: "core",
  description: "Segmentation fault",
  standard: "ansi"
}, {
  name: "SIGUSR2",
  number: 12,
  action: "terminate",
  description: "Application-specific signal",
  standard: "posix"
}, {
  name: "SIGPIPE",
  number: 13,
  action: "terminate",
  description: "Broken pipe or socket",
  standard: "posix"
}, {
  name: "SIGALRM",
  number: 14,
  action: "terminate",
  description: "Timeout or timer",
  standard: "posix"
}, {
  name: "SIGTERM",
  number: 15,
  action: "terminate",
  description: "Termination",
  standard: "ansi"
}, {
  name: "SIGSTKFLT",
  number: 16,
  action: "terminate",
  description: "Stack is empty or overflowed",
  standard: "other"
}, {
  name: "SIGCHLD",
  number: 17,
  action: "ignore",
  description: "Child process terminated, paused or unpaused",
  standard: "posix"
}, {
  name: "SIGCLD",
  number: 17,
  action: "ignore",
  description: "Child process terminated, paused or unpaused",
  standard: "other"
}, {
  name: "SIGCONT",
  number: 18,
  action: "unpause",
  description: "Unpaused",
  standard: "posix",
  forced: !0
}, {
  name: "SIGSTOP",
  number: 19,
  action: "pause",
  description: "Paused",
  standard: "posix",
  forced: !0
}, {
  name: "SIGTSTP",
  number: 20,
  action: "pause",
  description: 'Paused using CTRL-Z or "suspend"',
  standard: "posix"
}, {
  name: "SIGTTIN",
  number: 21,
  action: "pause",
  description: "Background process cannot read terminal input",
  standard: "posix"
}, {
  name: "SIGBREAK",
  number: 21,
  action: "terminate",
  description: "User interruption with CTRL-BREAK",
  standard: "other"
}, {
  name: "SIGTTOU",
  number: 22,
  action: "pause",
  description: "Background process cannot write to terminal output",
  standard: "posix"
}, {
  name: "SIGURG",
  number: 23,
  action: "ignore",
  description: "Socket received out-of-band data",
  standard: "bsd"
}, {
  name: "SIGXCPU",
  number: 24,
  action: "core",
  description: "Process timed out",
  standard: "bsd"
}, {
  name: "SIGXFSZ",
  number: 25,
  action: "core",
  description: "File too big",
  standard: "bsd"
}, {
  name: "SIGVTALRM",
  number: 26,
  action: "terminate",
  description: "Timeout or timer",
  standard: "bsd"
}, {
  name: "SIGPROF",
  number: 27,
  action: "terminate",
  description: "Timeout or timer",
  standard: "bsd"
}, {
  name: "SIGWINCH",
  number: 28,
  action: "ignore",
  description: "Terminal window size changed",
  standard: "bsd"
}, {
  name: "SIGIO",
  number: 29,
  action: "terminate",
  description: "I/O is available",
  standard: "other"
}, {
  name: "SIGPOLL",
  number: 29,
  action: "terminate",
  description: "Watched event",
  standard: "other"
}, {
  name: "SIGINFO",
  number: 29,
  action: "ignore",
  description: "Request for process information",
  standard: "other"
}, {
  name: "SIGPWR",
  number: 30,
  action: "terminate",
  description: "Device running out of power",
  standard: "systemv"
}, {
  name: "SIGSYS",
  number: 31,
  action: "core",
  description: "Invalid system call",
  standard: "other"
}, {
  name: "SIGUNUSED",
  number: 31,
  action: "terminate",
  description: "Invalid system call",
  standard: "other"
} ];

var getSignals = () => {
  var e = Array.from({
    length: Zt - Jt + 1
  }, getRealtimeSignal);
  return [ ...Xt, ...e ].map(normalizeSignal);
};

var normalizeSignal = ({name: e, number: t, description: r, action: n, forced: i = !1, standard: a}) => {
  var {signals: {[e]: s}} = h.constants;
  var D = void 0 !== s;
  return {
    name: e,
    number: D ? s : t,
    description: r,
    supported: D,
    action: n,
    forced: i,
    standard: a
  };
};

var getSignalByName = ({name: e, number: t, description: r, supported: n, action: i, forced: a, standard: s}) => [ e, {
  name: e,
  number: t,
  description: r,
  supported: n,
  action: i,
  forced: a,
  standard: s
} ];

var Qt = (() => {
  var e = getSignals();
  return Object.fromEntries(e.map(getSignalByName));
})();

var getSignalByNumber = (e, t) => {
  var r = findSignalByNumber(e, t);
  if (void 0 === r) {
    return {};
  }
  var {name: n, description: i, supported: a, action: s, forced: D, standard: c} = r;
  return {
    [e]: {
      name: n,
      number: e,
      description: i,
      supported: a,
      action: s,
      forced: D,
      standard: c
    }
  };
};

var findSignalByNumber = (e, t) => {
  var r = t.find((({name: t}) => h.constants.signals[t] === e));
  if (void 0 !== r) {
    return r;
  }
  return t.find((t => t.number === e));
};

(() => {
  var e = getSignals();
  var t = Array.from({
    length: Zt + 1
  }, ((t, r) => getSignalByNumber(r, e)));
  Object.assign({}, ...t);
})();

var makeError = ({stdout: e, stderr: t, all: r, error: n, signal: i, exitCode: s, command: D, escapedCommand: c, timedOut: l, isCanceled: d, killed: f, parsed: {options: {timeout: p, cwd: h = a.cwd()}}}) => {
  var m = void 0 === (i = null === i ? void 0 : i) ? void 0 : Qt[i].description;
  var g = (({timedOut: e, timeout: t, errorCode: r, signal: n, signalDescription: i, exitCode: a, isCanceled: s}) => {
    if (e) {
      return `timed out after ${t} milliseconds`;
    }
    if (s) {
      return "was canceled";
    }
    if (void 0 !== r) {
      return `failed with ${r}`;
    }
    if (void 0 !== n) {
      return `was killed with ${n} (${i})`;
    }
    if (void 0 !== a) {
      return `failed with exit code ${a}`;
    }
    return "failed";
  })({
    timedOut: l,
    timeout: p,
    errorCode: n && n.code,
    signal: i,
    signalDescription: m,
    exitCode: s = null === s ? void 0 : s,
    isCanceled: d
  });
  var E = `Command ${g}: ${D}`;
  var w = "[object Error]" === Object.prototype.toString.call(n);
  var b = w ? `${E}\n${n.message}` : E;
  var B = [ b, t, e ].filter(Boolean).join("\n");
  if (w) {
    n.originalMessage = n.message;
    n.message = B;
  } else {
    n = new Error(B);
  }
  n.shortMessage = b;
  n.command = D;
  n.escapedCommand = c;
  n.exitCode = s;
  n.signal = i;
  n.signalDescription = m;
  n.stdout = e;
  n.stderr = t;
  n.cwd = h;
  if (void 0 !== r) {
    n.all = r;
  }
  if ("bufferedData" in n) {
    delete n.bufferedData;
  }
  n.failed = !0;
  n.timedOut = Boolean(l);
  n.isCanceled = d;
  n.killed = f && !l;
  return n;
};

var er = [ "stdin", "stdout", "stderr" ];

var normalizeStdio = e => {
  if (!e) {
    return;
  }
  var {stdio: t} = e;
  if (void 0 === t) {
    return er.map((t => e[t]));
  }
  if ((e => er.some((t => void 0 !== e[t])))(e)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${er.map((e => `\`${e}\``)).join(", ")}`);
  }
  if ("string" == typeof t) {
    return t;
  }
  if (!Array.isArray(t)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);
  }
  var r = Math.max(t.length, er.length);
  return Array.from({
    length: r
  }, ((e, r) => t[r]));
};

var tr = [];

tr.push("SIGHUP", "SIGINT", "SIGTERM");

if ("win32" !== process.platform) {
  tr.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
}

if ("linux" === process.platform) {
  tr.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
}

var processOk = e => !!e && "object" == typeof e && "function" == typeof e.removeListener && "function" == typeof e.emit && "function" == typeof e.reallyExit && "function" == typeof e.listeners && "function" == typeof e.kill && "number" == typeof e.pid && "function" == typeof e.on;

var rr = Symbol.for("signal-exit emitter");

var nr = globalThis;

var ir = Object.defineProperty.bind(Object);

class Emitter {
  emitted={
    afterExit: !1,
    exit: !1
  };
  listeners={
    afterExit: [],
    exit: []
  };
  count=0;
  id=Math.random();
  constructor() {
    if (nr[rr]) {
      return nr[rr];
    }
    ir(nr, rr, {
      value: this,
      writable: !1,
      enumerable: !1,
      configurable: !1
    });
  }
  on(e, t) {
    this.listeners[e].push(t);
  }
  removeListener(e, t) {
    var r = this.listeners[e];
    var n = r.indexOf(t);
    if (-1 === n) {
      return;
    }
    if (0 === n && 1 === r.length) {
      r.length = 0;
    } else {
      r.splice(n, 1);
    }
  }
  emit(e, t, r) {
    if (this.emitted[e]) {
      return !1;
    }
    this.emitted[e] = !0;
    var n = !1;
    for (var i of this.listeners[e]) {
      n = !0 === i(t, r) || n;
    }
    if ("exit" === e) {
      n = this.emit("afterExit", t, r) || n;
    }
    return n;
  }
}

class SignalExitBase {}

var ur = globalThis.process;

var {onExit: ar} = (or = processOk(ur) ? new class SignalExit extends SignalExitBase {
  #e="win32" === ur.platform ? "SIGINT" : "SIGHUP";
  #t=new Emitter;
  #r;
  #n;
  #i;
  #u={};
  #a=!1;
  constructor(e) {
    var t;
    super();
    t = this;
    this.#r = e;
    this.#u = {};
    var _loop = function(r) {
      t.#u[r] = () => {
        var n = t.#r.listeners(r);
        var {count: i} = t.#t;
        if ("object" == typeof e.__signal_exit_emitter__ && "number" == typeof e.__signal_exit_emitter__.count) {
          i += e.__signal_exit_emitter__.count;
        }
        if (n.length === i) {
          t.unload();
          var a = t.#t.emit("exit", null, r);
          var s = "SIGHUP" === r ? t.#e : r;
          if (!a) {
            e.kill(e.pid, s);
          }
        }
      };
    };
    for (var r of tr) {
      _loop(r);
    }
    this.#i = e.reallyExit;
    this.#n = e.emit;
  }
  onExit(e, t) {
    if (!processOk(this.#r)) {
      return () => {};
    }
    if (!1 === this.#a) {
      this.load();
    }
    var r = t?.alwaysLast ? "afterExit" : "exit";
    this.#t.on(r, e);
    return () => {
      this.#t.removeListener(r, e);
      if (0 === this.#t.listeners.exit.length && 0 === this.#t.listeners.afterExit.length) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#a) {
      return;
    }
    this.#a = !0;
    this.#t.count += 1;
    for (var e of tr) {
      try {
        var t = this.#u[e];
        if (t) {
          this.#r.on(e, t);
        }
      } catch (e) {}
    }
    this.#r.emit = (e, ...t) => this.#o(e, ...t);
    this.#r.reallyExit = e => this.#s(e);
  }
  unload() {
    if (!this.#a) {
      return;
    }
    this.#a = !1;
    tr.forEach((e => {
      var t = this.#u[e];
      if (!t) {
        throw new Error("Listener not defined for signal: " + e);
      }
      try {
        this.#r.removeListener(e, t);
      } catch (e) {}
    }));
    this.#r.emit = this.#n;
    this.#r.reallyExit = this.#i;
    this.#t.count -= 1;
  }
  #s(e) {
    if (!processOk(this.#r)) {
      return 0;
    }
    this.#r.exitCode = e || 0;
    this.#t.emit("exit", this.#r.exitCode, null);
    return this.#i.call(this.#r, this.#r.exitCode);
  }
  #o(e, ...t) {
    var r = this.#n;
    if ("exit" === e && processOk(this.#r)) {
      if ("number" == typeof t[0]) {
        this.#r.exitCode = t[0];
      }
      var n = r.call(this.#r, e, ...t);
      this.#t.emit("exit", this.#r.exitCode, null);
      return n;
    } else {
      return r.call(this.#r, e, ...t);
    }
  }
}(ur) : new class SignalExitFallback extends SignalExitBase {
  onExit() {
    return () => {};
  }
  load() {}
  unload() {}
}, {
  onExit: (e, t) => or.onExit(e, t),
  load: () => or.load(),
  unload: () => or.unload()
});

var or;

var spawnedKill = (e, t = "SIGTERM", r = {}) => {
  var n = e(t);
  setKillTimeout(e, t, r, n);
  return n;
};

var setKillTimeout = (e, t, r, n) => {
  if (!shouldForceKill(t, r, n)) {
    return;
  }
  var i = getForceKillAfterTimeout(r);
  var a = setTimeout((() => {
    e("SIGKILL");
  }), i);
  if (a.unref) {
    a.unref();
  }
};

var shouldForceKill = (e, {forceKillAfterTimeout: t}, r) => isSigterm(e) && !1 !== t && r;

var isSigterm = e => e === h.constants.signals.SIGTERM || "string" == typeof e && "SIGTERM" === e.toUpperCase();

var getForceKillAfterTimeout = ({forceKillAfterTimeout: e = !0}) => {
  if (!0 === e) {
    return 5e3;
  }
  if (!Number.isFinite(e) || e < 0) {
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);
  }
  return e;
};

var spawnedCancel = (e, t) => {
  if (e.kill()) {
    t.isCanceled = !0;
  }
};

var setupTimeout = (e, {timeout: t, killSignal: r = "SIGTERM"}, n) => {
  if (0 === t || void 0 === t) {
    return n;
  }
  var i;
  var a = new Promise(((n, a) => {
    i = setTimeout((() => {
      ((e, t, r) => {
        e.kill(t);
        r(Object.assign(new Error("Timed out"), {
          timedOut: !0,
          signal: t
        }));
      })(e, r, a);
    }), t);
  }));
  var s = n.finally((() => {
    clearTimeout(i);
  }));
  return Promise.race([ a, s ]);
};

var validateTimeout = ({timeout: e}) => {
  if (void 0 !== e && (!Number.isFinite(e) || e < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);
  }
};

var setExitHandler = async (e, {cleanup: t, detached: r}, n) => {
  if (!t || r) {
    return n;
  }
  var i = ar((() => {
    e.kill();
  }));
  return n.finally((() => {
    i();
  }));
};

function isStream(e) {
  return null !== e && "object" == typeof e && "function" == typeof e.pipe;
}

function isWritableStream(e) {
  return isStream(e) && !1 !== e.writable && "function" == typeof e._write && "object" == typeof e._writableState;
}

var pipeToTarget = (e, t, r) => {
  if ("string" == typeof r) {
    e[t].pipe(m.createWriteStream(r));
    return e;
  }
  if (isWritableStream(r)) {
    e[t].pipe(r);
    return e;
  }
  if (!(e => e instanceof c.ChildProcess && "function" == typeof e.then)(r)) {
    throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
  }
  if (!isWritableStream(r.stdin)) {
    throw new TypeError("The target child process's stdin must be available.");
  }
  e[t].pipe(r.stdin);
  return r;
};

var addPipeMethods = e => {
  if (null !== e.stdout) {
    e.pipeStdout = pipeToTarget.bind(void 0, e, "stdout");
  }
  if (null !== e.stderr) {
    e.pipeStderr = pipeToTarget.bind(void 0, e, "stderr");
  }
  if (void 0 !== e.all) {
    e.pipeAll = pipeToTarget.bind(void 0, e, "all");
  }
};

var getStreamContents = async (e, {init: t, convertChunk: r, getSize: n, truncateChunk: i, addChunk: a, getFinalChunk: s, finalize: D}, {maxBuffer: c = Number.POSITIVE_INFINITY} = {}) => {
  if (!isAsyncIterable(e)) {
    throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
  }
  var l = t();
  l.length = 0;
  try {
    for await (var d of e) {
      var f = r[getChunkType(d)](d, l);
      appendChunk({
        convertedChunk: f,
        state: l,
        getSize: n,
        truncateChunk: i,
        addChunk: a,
        maxBuffer: c
      });
    }
    appendFinalChunk({
      state: l,
      convertChunk: r,
      getSize: n,
      truncateChunk: i,
      addChunk: a,
      getFinalChunk: s,
      maxBuffer: c
    });
    return D(l);
  } catch (e) {
    e.bufferedData = D(l);
    throw e;
  }
};

var appendFinalChunk = ({state: e, getSize: t, truncateChunk: r, addChunk: n, getFinalChunk: i, maxBuffer: a}) => {
  var s = i(e);
  if (void 0 !== s) {
    appendChunk({
      convertedChunk: s,
      state: e,
      getSize: t,
      truncateChunk: r,
      addChunk: n,
      maxBuffer: a
    });
  }
};

var appendChunk = ({convertedChunk: e, state: t, getSize: r, truncateChunk: n, addChunk: i, maxBuffer: a}) => {
  var s = r(e);
  var D = t.length + s;
  if (D <= a) {
    addNewChunk(e, t, i, D);
    return;
  }
  var c = n(e, a - t.length);
  if (void 0 !== c) {
    addNewChunk(c, t, i, a);
  }
  throw new MaxBufferError;
};

var addNewChunk = (e, t, r, n) => {
  t.contents = r(e, t, n);
  t.length = n;
};

var isAsyncIterable = e => "object" == typeof e && null !== e && "function" == typeof e[Symbol.asyncIterator];

var getChunkType = e => {
  var t = typeof e;
  if ("string" === t) {
    return "string";
  }
  if ("object" !== t || null === e) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(e)) {
    return "buffer";
  }
  var r = sr.call(e);
  if ("[object ArrayBuffer]" === r) {
    return "arrayBuffer";
  }
  if ("[object DataView]" === r) {
    return "dataView";
  }
  if (Number.isInteger(e.byteLength) && Number.isInteger(e.byteOffset) && "[object ArrayBuffer]" === sr.call(e.buffer)) {
    return "typedArray";
  }
  return "others";
};

var {toString: sr} = Object.prototype;

class MaxBufferError extends Error {
  name="MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
}

var throwObjectStream = e => {
  throw new Error(`Streams in object mode are not supported: ${String(e)}`);
};

var getLengthProp = e => e.length;

var Dr = new TextEncoder;

var useUint8Array = e => new Uint8Array(e);

var useUint8ArrayWithOffset = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength);

var resizeArrayBufferSlow = (e, t) => {
  if (t <= e.byteLength) {
    return e;
  }
  var r = new ArrayBuffer(getNewContentsLength(t));
  new Uint8Array(r).set(new Uint8Array(e), 0);
  return r;
};

var resizeArrayBuffer = (e, t) => {
  if (t <= e.maxByteLength) {
    e.resize(t);
    return e;
  }
  var r = new ArrayBuffer(t, {
    maxByteLength: getNewContentsLength(t)
  });
  new Uint8Array(r).set(new Uint8Array(e), 0);
  return r;
};

var getNewContentsLength = e => cr ** Math.ceil(Math.log(e) / Math.log(cr));

var cr = 2;

var hasArrayBufferResize = () => "resize" in ArrayBuffer.prototype;

var lr = {
  init: () => ({
    contents: new ArrayBuffer(0)
  }),
  convertChunk: {
    string: e => Dr.encode(e),
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProp,
  truncateChunk: (e, t) => e.slice(0, t),
  addChunk: (e, {contents: t, length: r}, n) => {
    var i = hasArrayBufferResize() ? resizeArrayBuffer(t, n) : resizeArrayBufferSlow(t, n);
    new Uint8Array(i).set(e, r);
    return i;
  },
  getFinalChunk: () => {},
  finalize: ({contents: e, length: t}) => hasArrayBufferResize() ? e : e.slice(0, t)
};

async function getStreamAsBuffer(e, t) {
  if (!("Buffer" in globalThis)) {
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  }
  try {
    return arrayBufferToNodeBuffer(await async function getStreamAsArrayBuffer(e, t) {
      return getStreamContents(e, lr, t);
    }(e, t));
  } catch (e) {
    if (void 0 !== e.bufferedData) {
      e.bufferedData = arrayBufferToNodeBuffer(e.bufferedData);
    }
    throw e;
  }
}

var arrayBufferToNodeBuffer = e => globalThis.Buffer.from(e);

var useTextDecoder = (e, {textDecoder: t}) => t.decode(e, {
  stream: !0
});

var dr = {
  init: () => ({
    contents: "",
    textDecoder: new TextDecoder
  }),
  convertChunk: {
    string: e => e,
    buffer: useTextDecoder,
    arrayBuffer: useTextDecoder,
    dataView: useTextDecoder,
    typedArray: useTextDecoder,
    others: throwObjectStream
  },
  getSize: getLengthProp,
  truncateChunk: (e, t) => e.slice(0, t),
  addChunk: (e, {contents: t}) => t + e,
  getFinalChunk: ({textDecoder: e}) => {
    var t = e.decode();
    return "" === t ? void 0 : t;
  },
  finalize: ({contents: e}) => e
};

var {PassThrough: fr} = E;

var pr = getDefaultExportFromCjs((function() {
  var e = [];
  var t = new fr({
    objectMode: !0
  });
  t.setMaxListeners(0);
  t.add = add;
  t.isEmpty = function isEmpty() {
    return 0 == e.length;
  };
  t.on("unpipe", remove);
  Array.prototype.slice.call(arguments).forEach(add);
  return t;
  function add(r) {
    if (Array.isArray(r)) {
      r.forEach(add);
      return this;
    }
    e.push(r);
    r.once("end", remove.bind(null, r));
    r.once("error", t.emit.bind(t, "error"));
    r.pipe(t, {
      end: !1
    });
    return this;
  }
  function remove(r) {
    if (!(e = e.filter((function(e) {
      return e !== r;
    }))).length && t.readable) {
      t.end();
    }
  }
}));

var getInput = ({input: e, inputFile: t}) => {
  if ("string" != typeof t) {
    return e;
  }
  (e => {
    if (void 0 !== e) {
      throw new TypeError("The `input` and `inputFile` options cannot be both set.");
    }
  })(e);
  return m.createReadStream(t);
};

var handleInput = (e, t) => {
  var r = getInput(t);
  if (void 0 === r) {
    return;
  }
  if (isStream(r)) {
    r.pipe(e.stdin);
  } else {
    e.stdin.end(r);
  }
};

var makeAllStream = (e, {all: t}) => {
  if (!t || !e.stdout && !e.stderr) {
    return;
  }
  var r = pr();
  if (e.stdout) {
    r.add(e.stdout);
  }
  if (e.stderr) {
    r.add(e.stderr);
  }
  return r;
};

var getBufferedData = async (e, t) => {
  if (!e || void 0 === t) {
    return;
  }
  await g.setTimeout(0);
  e.destroy();
  try {
    return await t;
  } catch (e) {
    return e.bufferedData;
  }
};

var getStreamPromise = (e, {encoding: t, buffer: r, maxBuffer: n}) => {
  if (!e || !r) {
    return;
  }
  if ("utf8" === t || "utf-8" === t) {
    return async function getStreamAsString(e, t) {
      return getStreamContents(e, dr, t);
    }(e, {
      maxBuffer: n
    });
  }
  if (null === t || "buffer" === t) {
    return getStreamAsBuffer(e, {
      maxBuffer: n
    });
  }
  return applyEncoding(e, n, t);
};

var applyEncoding = async (e, t, r) => (await getStreamAsBuffer(e, {
  maxBuffer: t
})).toString(r);

var getSpawnedResult = async ({stdout: e, stderr: t, all: r}, {encoding: n, buffer: i, maxBuffer: a}, s) => {
  var D = getStreamPromise(e, {
    encoding: n,
    buffer: i,
    maxBuffer: a
  });
  var c = getStreamPromise(t, {
    encoding: n,
    buffer: i,
    maxBuffer: a
  });
  var l = getStreamPromise(r, {
    encoding: n,
    buffer: i,
    maxBuffer: 2 * a
  });
  try {
    return await Promise.all([ s, D, c, l ]);
  } catch (n) {
    return Promise.all([ {
      error: n,
      signal: n.signal,
      timedOut: n.timedOut
    }, getBufferedData(e, D), getBufferedData(t, c), getBufferedData(r, l) ]);
  }
};

var hr = (async () => {})().constructor.prototype;

var vr = [ "then", "catch", "finally" ].map((e => [ e, Reflect.getOwnPropertyDescriptor(hr, e) ]));

var mergePromise = (e, t) => {
  var _loop = function(n) {
    var i = "function" == typeof t ? (...e) => Reflect.apply(n.value, t(), e) : n.value.bind(t);
    Reflect.defineProperty(e, r, {
      ...n,
      value: i
    });
  };
  for (var [r, n] of vr) {
    _loop(n);
  }
};

var getSpawnedPromise = e => new Promise(((t, r) => {
  e.on("exit", ((e, r) => {
    t({
      exitCode: e,
      signal: r
    });
  }));
  e.on("error", (e => {
    r(e);
  }));
  if (e.stdin) {
    e.stdin.on("error", (e => {
      r(e);
    }));
  }
}));

var normalizeArgs = (e, t = []) => {
  if (!Array.isArray(t)) {
    return [ e ];
  }
  return [ e, ...t ];
};

var mr = /^[\w.-]+$/;

var joinCommand = (e, t) => normalizeArgs(e, t).join(" ");

var getEscapedCommand = (e, t) => normalizeArgs(e, t).map((e => (e => {
  if ("string" != typeof e || mr.test(e)) {
    return e;
  }
  return `"${e.replaceAll('"', '\\"')}"`;
})(e))).join(" ");

var gr = w.debuglog("execa").enabled;

var padField = (e, t) => String(e).padStart(t, "0");

var logCommand = (e, {verbose: t}) => {
  if (!t) {
    return;
  }
  a.stderr.write(`[${r = new Date, `${padField(r.getHours(), 2)}:${padField(r.getMinutes(), 2)}:${padField(r.getSeconds(), 2)}.${padField(r.getMilliseconds(), 3)}`}] ${e}\n`);
  var r;
};

var handleArguments = (t, r, n = {}) => {
  var i = Ht._parse(t, r, n);
  t = i.command;
  r = i.args;
  (n = {
    maxBuffer: 1e8,
    buffer: !0,
    stripFinalNewline: !0,
    extendEnv: !0,
    preferLocal: !1,
    localDir: (n = i.options).cwd || a.cwd(),
    execPath: a.execPath,
    encoding: "utf8",
    reject: !0,
    cleanup: !0,
    all: !1,
    windowsHide: !0,
    verbose: gr,
    ...n
  }).env = (({env: e, extendEnv: t, preferLocal: r, localDir: n, execPath: i}) => {
    var s = t ? {
      ...a.env,
      ...e
    } : e;
    if (r) {
      return npmRunPathEnv({
        env: s,
        cwd: n,
        execPath: i
      });
    }
    return s;
  })(n);
  n.stdio = normalizeStdio(n);
  if ("win32" === a.platform && "cmd" === e.basename(t, ".exe")) {
    r.unshift("/q");
  }
  return {
    file: t,
    args: r,
    options: n,
    parsed: i
  };
};

var handleOutput = (e, t, r) => {
  if ("string" != typeof t && !D.Buffer.isBuffer(t)) {
    return void 0 === r ? void 0 : "";
  }
  if (e.stripFinalNewline) {
    return function stripFinalNewline(e) {
      var t = "string" == typeof e ? "\n" : "\n".charCodeAt();
      var r = "string" == typeof e ? "\r" : "\r".charCodeAt();
      if (e[e.length - 1] === t) {
        e = e.slice(0, -1);
      }
      if (e[e.length - 1] === r) {
        e = e.slice(0, -1);
      }
      return e;
    }(t);
  }
  return t;
};

function execa(e, t, r) {
  var n = handleArguments(e, t, r);
  var i = joinCommand(e, t);
  var a = getEscapedCommand(e, t);
  logCommand(a, n.options);
  validateTimeout(n.options);
  var s;
  try {
    s = c.spawn(n.file, n.args, n.options);
  } catch (e) {
    var D = new c.ChildProcess;
    var l = Promise.reject(makeError({
      error: e,
      stdout: "",
      stderr: "",
      all: "",
      command: i,
      escapedCommand: a,
      parsed: n,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    }));
    mergePromise(D, l);
    return D;
  }
  var d = getSpawnedPromise(s);
  var f = setupTimeout(s, n.options, d);
  var p = setExitHandler(s, n.options, f);
  s.kill = spawnedKill.bind(null, s.kill.bind(s));
  s.cancel = spawnedCancel.bind(null, s, {
    isCanceled: !1
  });
  var h = onetime((async () => {
    var [{error: e, exitCode: t, signal: r, timedOut: D}, c, l, d] = await getSpawnedResult(s, n.options, p);
    var f = handleOutput(n.options, c);
    var h = handleOutput(n.options, l);
    var m = handleOutput(n.options, d);
    if (e || 0 !== t || null !== r) {
      var g = makeError({
        error: e,
        exitCode: t,
        signal: r,
        stdout: f,
        stderr: h,
        all: m,
        command: i,
        escapedCommand: a,
        parsed: n,
        timedOut: D,
        isCanceled: n.options.signal ? n.options.signal.aborted : !1,
        killed: s.killed
      });
      if (!n.options.reject) {
        return g;
      }
      throw g;
    }
    return {
      command: i,
      escapedCommand: a,
      exitCode: 0,
      stdout: f,
      stderr: h,
      all: m,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  }));
  handleInput(s, n.options);
  s.all = makeAllStream(s, n.options);
  addPipeMethods(s);
  mergePromise(s, h);
  return s;
}

var Cr = (() => {
  var e = nt ? [ "‚óí", "‚óê", "‚óì", "‚óë" ] : [ "‚Ä¢", "o", "O", "0" ], t = nt ? 80 : 120;
  var r, n, i = !1, s = "";
  var u = (e = "", t = 0) => {
    s = e ?? s, i = !1, clearInterval(n);
    var a = 0 === t ? Ge.green(ot) : 1 === t ? Ge.red(ut) : Ge.red(at);
    process.stdout.write(Re.cursor.move(-999, 0)), process.stdout.write(Re.erase.down(1)), 
    process.stdout.write(`${a}  ${s}\n`), r();
  }, $ = e => {
    i && u(e > 1 ? "Something went wrong" : "Canceled", e);
  };
  return process.on("uncaughtExceptionMonitor", (() => $(2))), process.on("unhandledRejection", (() => $(2))), 
  process.on("SIGINT", (() => $(1))), process.on("SIGTERM", (() => $(1))), process.on("exit", $), 
  {
    start: (D = "") => {
      i = !0, r = function WD({input: e = a.stdin, output: t = a.stdout, overwrite: r = !0, hideCursor: n = !0} = {}) {
        var i = S.createInterface({
          input: e,
          output: t,
          prompt: "",
          tabSize: 1
        });
        S.emitKeypressEvents(e, i), e.isTTY && e.setRawMode(!0);
        var C = (n, {name: i}) => {
          if ("" === String(n) && process.exit(0), !r) {
            return;
          }
          S.moveCursor(t, "return" === i ? 0 : -1, "return" === i ? -1 : 0, (() => {
            S.clearLine(t, 1, (() => {
              e.once("keypress", C);
            }));
          }));
        };
        return n && process.stdout.write(Re.cursor.hide), e.once("keypress", C), () => {
          e.off("keypress", C), n && process.stdout.write(Re.cursor.show), e.isTTY && !rt && e.setRawMode(!1), 
          i.terminal = !1, i.close();
        };
      }(), s = D.replace(/\.+$/, ""), process.stdout.write(`${Ge.gray(Dt)}\n`);
      var c = 0, l = 0;
      n = setInterval((() => {
        var t = Ge.magenta(e[c]), r = ".".repeat(Math.floor(l)).slice(0, 3);
        process.stdout.write(Re.cursor.move(-999, 0)), process.stdout.write(Re.erase.down(1)), 
        process.stdout.write(`${t}  ${s}${r}`), c = c + 1 < e.length ? c + 1 : 0, l = l < e.length ? l + .125 : 0;
      }), t);
    },
    stop: u,
    message: (e = "") => {
      s = e ?? s;
    }
  };
})();

async function run(n) {
  ((e = "") => {
    process.stdout.write(`${Ge.gray(st)}  ${e}\n`);
  })("GQL.Tada");
  var i = await question("Where can we get your schema? Point us at an introspection JSON-file, a GraphQL schema file or an endpoint", (async t => {
    try {
      var i = new URL(t);
      Cr.start("Validating the URL.");
      try {
        var a = await fetch(i.toString());
        if (!a.ok) {
          Cr.stop("Validated the URL.");
          return !!await se({
            message: `Got ${a.status} from ${i.toString()}, continue anyway? You can add headers later.`
          });
        }
      } catch (e) {
        Cr.stop("Validated the URL.");
        return !!await se({
          message: `Got ${e.message} from ${i.toString()}, continue anyway? You can add headers later.`
        });
      }
      Cr.stop("Validated the URL.");
      return !0;
    } catch (e) {}
    if (!(t.endsWith(".json") || t.endsWith(".graphql"))) {
      return !1;
    }
    var s = e.resolve(n, t);
    var D = !!await r.readFile(s);
    if (!D) {
      console.log(`\nCould not find "${s}"`);
    }
    return D;
  }), !0);
  var a = await question("What directory do you want us to write the tadaOutputFile to?", (async t => {
    var i = e.resolve(n, t);
    var a = !!await r.stat(i);
    if (!a) {
      console.log(`\nCould not find "${i}"`);
    }
    return a;
  }), !0);
  if (hD(a)) {
    ue("Operation cancelled.");
    process.exit(0);
  }
  a = e.resolve(a, "graphql-env.d.ts");
  var s = await se({
    message: "Do you want us to install the dependencies?"
  });
  if (hD(s)) {
    ue("Operation cancelled.");
    process.exit(0);
  }
  if (s) {
    Cr.start("Installing packages.");
    await async function installPackages(e, t) {
      await execa(e, [ "yarn" === e ? "add" : "install", "-D", "@0no-co/graphqlsp" ], {
        stdio: "ignore",
        cwd: t
      });
      await execa(e, [ "yarn" === e ? "add" : "install", "gql.tada" ], {
        stdio: "ignore",
        cwd: t
      });
    }(function getPkgManager() {
      var e = process.env.npm_config_user_agent || "";
      if (e.startsWith("yarn")) {
        return "yarn";
      }
      if (e.startsWith("pnpm")) {
        return "pnpm";
      }
      return "npm";
    }(), n);
    Cr.stop("Installed packages.");
  } else {
    Cr.start("Writing to package.json.");
    try {
      var D = e.resolve(n, "package.json");
      var c = await r.readFile(D, "utf-8");
      var l = JSON.parse(c);
      if (!l.dependencies) {
        l.dependencies = {};
      }
      if (!l.dependencies["gql.tada"]) {
        l.dependencies["gql.tada"] = "^1.4.3";
      }
      if (!l.devDependencies) {
        l.devDependencies = {};
      }
      if (!l.devDependencies["@0no-co/graphqlsp"]) {
        l.devDependencies["@0no-co/graphqlsp"] = "^1.8.0";
      }
      await r.writeFile(D, JSON.stringify(l, null, 2));
      Cr.stop("Written to package.json.");
    } catch (e) {
      Cr.stop('Failed to write to package.json, you can try adding "gql.tada" and "@0no-co/graphqlsp" yourself.');
    }
  }
  Cr.start("Writing to tsconfig.json.");
  try {
    var d = e.resolve(n, "tsconfig.json");
    var f = await t.readTSConfigFile(d);
    var p = i.endsWith(".json") || i.endsWith(".graphql");
    f.compilerOptions = {
      ...f.compilerOptions,
      plugins: [ {
        name: "@0no-co/graphqlsp",
        schema: p ? e.relative(n, i) : i,
        tadaOutputLocation: e.relative(n, a)
      } ]
    };
    await r.writeFile(d, JSON.stringify(f, null, 2));
  } catch (e) {}
  Cr.stop("Written to tsconfig.json.");
  ((e = "") => {
    process.stdout.write(`${Ge.gray(Dt)}\n${Ge.gray(ct)}  ${e}\n\n`);
  })("Off to the races!");
}

var question = async (e, t, r) => {
  var n = "";
  if (r) {
    var i = !1;
    while (!i) {
      if (hD(n = await te({
        message: e
      }))) {
        i = !0;
        ue("Operation cancelled.");
        process.exit(0);
      } else if (await t(n)) {
        i = !0;
      }
    }
  } else if (hD(n = await te({
    message: e
  }))) {
    ue("Operation cancelled.");
    process.exit(0);
  }
  return n;
};

class InitCommand extends Command {
  static paths=[ [ "init" ] ];
  input=String$1({
    name: "dir"
  });
  async execute() {
    var e = b.resolve(process.cwd(), this.input);
    await run(e);
  }
}

var Fr = Object.assign((async function _main() {
  var e = new Cli({
    binaryVersion: process.env.npm_package_version || "0.0.0",
    binaryLabel: "gql.tada CLI",
    binaryName: "gql.tada"
  });
  e.register(CheckCommand);
  e.register(DoctorCommand);
  e.register(GenerateOutputCommand);
  e.register(GeneratePersisted);
  e.register(GenerateSchema);
  e.register(InitCommand);
  e.register(TurboCommand);
  await e.runExit(process.argv.slice(2));
}), Ae);

exports.default = Fr;

exports.generateOutput = generateOutput;

exports.generatePersisted = generatePersisted;

exports.generateSchema = generateSchema;

exports.generateTurbo = generateTurbo;
//# sourceMappingURL=gql-tada-cli.js.map
