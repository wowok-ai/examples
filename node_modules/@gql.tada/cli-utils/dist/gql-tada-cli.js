var t = require("node:fs");

var i = require("node:path");

var s = require("graphql");

var u = require("@urql/introspection");

function toArr(t) {
  return null == t ? [] : Array.isArray(t) ? t : [ t ];
}

function toVal(t, i, s, u) {
  var h, c = t[i], f = ~u.string.indexOf(i) ? null == s || !0 === s ? "" : String(s) : "boolean" == typeof s ? s : ~u.boolean.indexOf(i) ? "false" === s ? !1 : "true" === s || (t._.push(0 * (h = +s) == 0 ? h : s), 
  !!s) : 0 * (h = +s) == 0 ? h : s;
  t[i] = null == c ? f : Array.isArray(c) ? c.concat(f) : [ c, f ];
}

function e(t, i) {
  var s, u, h, c, f, p = {
    _: []
  };
  var m = 0, x = 0, v = 0, D = (t = t || []).length;
  var y = void 0 !== (i = i || {}).alias;
  var g = void 0 !== i.unknown;
  var S = void 0 !== i.default;
  i.alias = i.alias || {};
  i.string = toArr(i.string);
  i.boolean = toArr(i.boolean);
  if (y) {
    for (s in i.alias) {
      u = i.alias[s] = toArr(i.alias[s]);
      for (m = 0; m < u.length; m++) {
        (i.alias[u[m]] = u.concat(s)).splice(m, 1);
      }
    }
  }
  for (m = i.boolean.length; m-- > 0; ) {
    for (x = (u = i.alias[i.boolean[m]] || []).length; x-- > 0; ) {
      i.boolean.push(u[x]);
    }
  }
  for (m = i.string.length; m-- > 0; ) {
    for (x = (u = i.alias[i.string[m]] || []).length; x-- > 0; ) {
      i.string.push(u[x]);
    }
  }
  if (S) {
    for (s in i.default) {
      c = typeof i.default[s];
      u = i.alias[s] = i.alias[s] || [];
      if (void 0 !== i[c]) {
        i[c].push(s);
        for (m = 0; m < u.length; m++) {
          i[c].push(u[m]);
        }
      }
    }
  }
  var C = g ? Object.keys(i.alias) : [];
  for (m = 0; m < D; m++) {
    if ("--" === (h = t[m])) {
      p._ = p._.concat(t.slice(++m));
      break;
    }
    for (x = 0; x < h.length; x++) {
      if (45 !== h.charCodeAt(x)) {
        break;
      }
    }
    if (0 === x) {
      p._.push(h);
    } else if ("no-" === h.substring(x, x + 3)) {
      c = h.substring(x + 3);
      if (g && !~C.indexOf(c)) {
        return i.unknown(h);
      }
      p[c] = !1;
    } else {
      for (v = x + 1; v < h.length; v++) {
        if (61 === h.charCodeAt(v)) {
          break;
        }
      }
      c = h.substring(x, v);
      f = h.substring(++v) || m + 1 === D || 45 === ("" + t[m + 1]).charCodeAt(0) || t[++m];
      u = 2 === x ? [ c ] : c;
      for (v = 0; v < u.length; v++) {
        c = u[v];
        if (g && !~C.indexOf(c)) {
          return i.unknown("-".repeat(x) + c);
        }
        toVal(p, c, v + 1 < u.length || f, i);
      }
    }
  }
  if (S) {
    for (s in i.default) {
      if (void 0 === p[s]) {
        p[s] = i.default[s];
      }
    }
  }
  if (y) {
    for (s in p) {
      u = i.alias[s] || [];
      while (u.length > 0) {
        p[u.shift()] = p[s];
      }
    }
  }
  return p;
}

var h = "__all__", c = "__default__", f = "\n";

function r(t) {
  if (!t.length) {
    return "";
  }
  var i = function(t) {
    var i = 0, s = 0, u = 0, h = t.length;
    if (h) {
      for (;h--; ) {
        (s = t[h].length) > i && (u = h, i = s);
      }
    }
    return t[u].length;
  }(t.map((t => t[0]))) + 4;
  return t.map((t => t[0] + " ".repeat(i - t[0].length) + t[1] + (null == t[2] ? "" : `  (default ${t[2]})`)));
}

function n(t) {
  return t;
}

function l(t, i, s) {
  if (!i || !i.length) {
    return "";
  }
  var u = 0, h = "";
  for (h += "\n  " + t; u < i.length; u++) {
    h += "\n    " + s(i[u]);
  }
  return h + f;
}

function a(t, i, s = 1) {
  var u = l("ERROR", [ i ], n);
  console.error(u += `\n  Run \`$ ${t} --help\` for more info.\n`), process.exit(s);
}

class o {
  constructor(t, i) {
    var [s, ...u] = t.split(/\s+/);
    i = i || u.length > 0, this.bin = s, this.ver = "0.0.0", this.default = "", this.tree = {}, 
    this.command(h), this.command([ c ].concat(i ? u : "<command>").join(" ")), this.single = i, 
    this.curr = "";
  }
  command(t, i, s = {}) {
    if (this.single) {
      throw new Error('Disable "single" mode to add commands');
    }
    var u = [], h = [], c = /(\[|<)/;
    if (t.split(/\s+/).forEach((t => {
      (c.test(t.charAt(0)) ? h : u).push(t);
    })), (u = u.join(" ")) in this.tree) {
      throw new Error("Command already exists: " + u);
    }
    return u.includes("__") || h.unshift(u), h = h.join(" "), this.curr = u, s.default && (this.default = u), 
    this.tree[u] = {
      usage: h,
      alibi: [],
      options: [],
      alias: {},
      default: {},
      examples: []
    }, s.alias && this.alias(s.alias), i && this.describe(i), this;
  }
  describe(t) {
    return this.tree[this.curr || c].describe = Array.isArray(t) ? t : function(t) {
      return (t || "").replace(/([.?!])\s*(?=[A-Z])/g, "$1|").split("|");
    }(t), this;
  }
  alias(...t) {
    if (this.single) {
      throw new Error('Cannot call `alias()` in "single" mode');
    }
    if (!this.curr) {
      throw new Error("Cannot call `alias()` before defining a command");
    }
    return (this.tree[this.curr].alibi = this.tree[this.curr].alibi.concat(...t)).forEach((t => this.tree[t] = this.curr)), 
    this;
  }
  option(t, i, s) {
    var u = this.tree[this.curr || h], [c, f] = function(t) {
      return (t || "").split(/^-{1,2}|,|\s+-{1,2}|\s+/).filter(Boolean);
    }(t);
    if (f && f.length > 1 && ([c, f] = [ f, c ]), t = "--" + c, f && f.length > 0) {
      t = `-${f}, ${t}`;
      u.alias[f] = (u.alias[f] || []).concat(c);
    }
    var p = [ t, i || "" ];
    return void 0 !== s ? (p.push(s), u.default[c] = s) : f || (u.default[c] = void 0), 
    u.options.push(p), this;
  }
  action(t) {
    return this.tree[this.curr || c].handler = t, this;
  }
  example(t) {
    return this.tree[this.curr || c].examples.push(t), this;
  }
  version(t) {
    return this.ver = t, this;
  }
  parse(t, i = {}) {
    var s, u, f, p, m = 2, x = e((t = t.slice()).slice(m), {
      alias: {
        h: "help",
        v: "version"
      }
    }), v = this.single, D = this.bin, y = "";
    if (v) {
      p = this.tree[c];
    } else {
      var g, S = 1, C = x._.length + 1;
      for (;S < C; S++) {
        if (s = x._.slice(0, S).join(" "), "string" == typeof (g = this.tree[s])) {
          u = (y = g).split(" "), t.splice(t.indexOf(x._[0]), S, ...u), S += u.length - S;
        } else if (g) {
          y = s;
        } else if (y) {
          break;
        }
      }
      if (f = void 0 === (p = this.tree[y])) {
        if (this.default) {
          p = this.tree[y = this.default], t.unshift(y), m++;
        } else if (s) {
          return a(D, "Invalid command: " + s);
        }
      }
    }
    if (x.help) {
      return this.help(!v && !f && y);
    }
    if (x.version) {
      return this._version();
    }
    if (!v && void 0 === p) {
      return a(D, "No command specified.");
    }
    var A = this.tree[h];
    i.alias = Object.assign(A.alias, p.alias, i.alias), i.default = Object.assign(A.default, p.default, i.default), 
    s = y.split(" "), ~(u = t.indexOf(s[0], 2)) && t.splice(u, s.length);
    var w = e(t.slice(m), i);
    if (!w || "string" == typeof w) {
      return a(D, w || "Parsed unknown option flag(s)!");
    }
    var F = p.usage.split(/\s+/), B = F.filter((t => "<" === t.charAt(0))), b = w._.splice(0, B.length);
    if (b.length < B.length) {
      return y && (D += " " + y), a(D, "Insufficient arguments!");
    }
    F.filter((t => "[" === t.charAt(0))).forEach((t => {
      b.push(w._.shift());
    })), b.push(w);
    var k = p.handler;
    return i.lazy ? {
      args: b,
      name: y,
      handler: k
    } : k.apply(null, b);
  }
  help(t) {
    console.log(function(t, i, s, u) {
      var p = "", m = i[s], x = "$ " + t, v = i[h], d = t => `${x} ${t}`.replace(/\s+/g, " "), D = [ [ "-h, --help", "Displays this message" ] ];
      if (s === c && D.unshift([ "-v, --version", "Displays current version" ]), m.options = (m.options || []).concat(v.options, D), 
      m.options.length > 0 && (m.usage += " [options]"), p += l("Description", m.describe, n), 
      p += l("Usage", [ m.usage ], d), u || s !== c) {
        u || s === c || (p += l("Aliases", m.alibi, d));
      } else {
        var y, g = /^__/, S = "", C = [];
        for (y in i) {
          "string" == typeof i[y] || g.test(y) || C.push([ y, (i[y].describe || [ "" ])[0] ]) < 3 && (S += `\n    ${x} ${y} --help`);
        }
        p += l("Available Commands", r(C), n), p += "\n  For more info, run any command with the `--help` flag" + S + f;
      }
      return p += l("Options", r(m.options), n), p += l("Examples", m.examples.map(d), n);
    }(this.bin, this.tree, t || c, this.single));
  }
  _version() {
    console.log(`${this.bin}, ${this.ver}`);
  }
}

var p = {
  exports: {}
};

!function(t, i) {
  !function webpackUniversalModuleDefinition(i, s) {
    t.exports = s();
  }(0, (function() {
    return function(t) {
      var i = {};
      function __webpack_require__(s) {
        if (i[s]) {
          return i[s].exports;
        }
        var u = i[s] = {
          exports: {},
          id: s,
          loaded: !1
        };
        t[s].call(u.exports, u, u.exports, __webpack_require__);
        u.loaded = !0;
        return u.exports;
      }
      __webpack_require__.m = t;
      __webpack_require__.c = i;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([ function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(1);
      var h = s(3);
      var c = s(8);
      var f = s(15);
      function parse(t, i, s) {
        var f = null;
        var proxyDelegate = function(t, i) {
          if (s) {
            s(t, i);
          }
          if (f) {
            f.visit(t, i);
          }
        };
        var p = "function" == typeof s ? proxyDelegate : null;
        var m = !1;
        if (i) {
          var x = "boolean" == typeof i.attachComment && i.attachComment;
          if ((m = "boolean" == typeof i.comment && i.comment) || x) {
            (f = new u.CommentHandler).attach = x;
            i.comment = !0;
            p = proxyDelegate;
          }
        }
        var v = !1;
        if (i && "string" == typeof i.sourceType) {
          v = "module" === i.sourceType;
        }
        var D;
        if (i && "boolean" == typeof i.jsx && i.jsx) {
          D = new h.JSXParser(t, i, p);
        } else {
          D = new c.Parser(t, i, p);
        }
        var y = v ? D.parseModule() : D.parseScript();
        if (m && f) {
          y.comments = f.comments;
        }
        if (D.config.tokens) {
          y.tokens = D.tokens;
        }
        if (D.config.tolerant) {
          y.errors = D.errorHandler.errors;
        }
        return y;
      }
      i.parse = parse;
      i.parseModule = function parseModule(t, i, s) {
        var u = i || {};
        u.sourceType = "module";
        return parse(t, u, s);
      };
      i.parseScript = function parseScript(t, i, s) {
        var u = i || {};
        u.sourceType = "script";
        return parse(t, u, s);
      };
      i.tokenize = function tokenize(t, i, s) {
        var u = new f.Tokenizer(t, i);
        var h;
        h = [];
        try {
          while (1) {
            var c = u.getNextToken();
            if (!c) {
              break;
            }
            if (s) {
              c = s(c);
            }
            h.push(c);
          }
        } catch (t) {
          u.errorHandler.tolerate(t);
        }
        if (u.errorHandler.tolerant) {
          h.errors = u.errors();
        }
        return h;
      };
      var p = s(2);
      i.Syntax = p.Syntax;
      i.version = "4.0.1";
    }, function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(2);
      var h = function() {
        function CommentHandler() {
          this.attach = !1;
          this.comments = [];
          this.stack = [];
          this.leading = [];
          this.trailing = [];
        }
        CommentHandler.prototype.insertInnerComments = function(t, i) {
          if (t.type === u.Syntax.BlockStatement && 0 === t.body.length) {
            var s = [];
            for (var h = this.leading.length - 1; h >= 0; --h) {
              var c = this.leading[h];
              if (i.end.offset >= c.start) {
                s.unshift(c.comment);
                this.leading.splice(h, 1);
                this.trailing.splice(h, 1);
              }
            }
            if (s.length) {
              t.innerComments = s;
            }
          }
        };
        CommentHandler.prototype.findTrailingComments = function(t) {
          var i = [];
          if (this.trailing.length > 0) {
            for (var s = this.trailing.length - 1; s >= 0; --s) {
              var u = this.trailing[s];
              if (u.start >= t.end.offset) {
                i.unshift(u.comment);
              }
            }
            this.trailing.length = 0;
            return i;
          }
          var h = this.stack[this.stack.length - 1];
          if (h && h.node.trailingComments) {
            var c = h.node.trailingComments[0];
            if (c && c.range[0] >= t.end.offset) {
              i = h.node.trailingComments;
              delete h.node.trailingComments;
            }
          }
          return i;
        };
        CommentHandler.prototype.findLeadingComments = function(t) {
          var i = [];
          var s;
          while (this.stack.length > 0) {
            if ((c = this.stack[this.stack.length - 1]) && c.start >= t.start.offset) {
              s = c.node;
              this.stack.pop();
            } else {
              break;
            }
          }
          if (s) {
            for (var u = (s.leadingComments ? s.leadingComments.length : 0) - 1; u >= 0; --u) {
              var h = s.leadingComments[u];
              if (h.range[1] <= t.start.offset) {
                i.unshift(h);
                s.leadingComments.splice(u, 1);
              }
            }
            if (s.leadingComments && 0 === s.leadingComments.length) {
              delete s.leadingComments;
            }
            return i;
          }
          for (u = this.leading.length - 1; u >= 0; --u) {
            var c;
            if ((c = this.leading[u]).start <= t.start.offset) {
              i.unshift(c.comment);
              this.leading.splice(u, 1);
            }
          }
          return i;
        };
        CommentHandler.prototype.visitNode = function(t, i) {
          if (t.type === u.Syntax.Program && t.body.length > 0) {
            return;
          }
          this.insertInnerComments(t, i);
          var s = this.findTrailingComments(i);
          var h = this.findLeadingComments(i);
          if (h.length > 0) {
            t.leadingComments = h;
          }
          if (s.length > 0) {
            t.trailingComments = s;
          }
          this.stack.push({
            node: t,
            start: i.start.offset
          });
        };
        CommentHandler.prototype.visitComment = function(t, i) {
          var s = "L" === t.type[0] ? "Line" : "Block";
          var u = {
            type: s,
            value: t.value
          };
          if (t.range) {
            u.range = t.range;
          }
          if (t.loc) {
            u.loc = t.loc;
          }
          this.comments.push(u);
          if (this.attach) {
            var h = {
              comment: {
                type: s,
                value: t.value,
                range: [ i.start.offset, i.end.offset ]
              },
              start: i.start.offset
            };
            if (t.loc) {
              h.comment.loc = t.loc;
            }
            t.type = s;
            this.leading.push(h);
            this.trailing.push(h);
          }
        };
        CommentHandler.prototype.visit = function(t, i) {
          if ("LineComment" === t.type) {
            this.visitComment(t, i);
          } else if ("BlockComment" === t.type) {
            this.visitComment(t, i);
          } else if (this.attach) {
            this.visitNode(t, i);
          }
        };
        return CommentHandler;
      }();
      i.CommentHandler = h;
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      i.Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DoWhileStatement: "DoWhileStatement",
        DebuggerStatement: "DebuggerStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForOfStatement: "ForOfStatement",
        ForInStatement: "ForInStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        Program: "Program",
        Property: "Property",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchCase: "SwitchCase",
        SwitchStatement: "SwitchStatement",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
    }, function(t, i, s) {
      var u = this && this.__extends || (h = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(t, i) {
        t.__proto__ = i;
      } || function(t, i) {
        for (var s in i) {
          if (i.hasOwnProperty(s)) {
            t[s] = i[s];
          }
        }
      }, function(t, i) {
        h(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = null === i ? Object.create(i) : (__.prototype = i.prototype, new __);
      });
      var h;
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var c = s(4);
      var f = s(5);
      var p = s(6);
      var m = s(7);
      var x = s(8);
      var v = s(13);
      var D = s(14);
      v.TokenName[100] = "JSXIdentifier";
      v.TokenName[101] = "JSXText";
      function getQualifiedElementName(t) {
        var i;
        switch (t.type) {
         case p.JSXSyntax.JSXIdentifier:
          i = t.name;
          break;

         case p.JSXSyntax.JSXNamespacedName:
          var s = t;
          i = getQualifiedElementName(s.namespace) + ":" + getQualifiedElementName(s.name);
          break;

         case p.JSXSyntax.JSXMemberExpression:
          var u = t;
          i = getQualifiedElementName(u.object) + "." + getQualifiedElementName(u.property);
        }
        return i;
      }
      var y = function(t) {
        u(JSXParser, t);
        function JSXParser(i, s, u) {
          return t.call(this, i, s, u) || this;
        }
        JSXParser.prototype.parsePrimaryExpression = function() {
          return this.match("<") ? this.parseJSXRoot() : t.prototype.parsePrimaryExpression.call(this);
        };
        JSXParser.prototype.startJSX = function() {
          this.scanner.index = this.startMarker.index;
          this.scanner.lineNumber = this.startMarker.line;
          this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
        };
        JSXParser.prototype.finishJSX = function() {
          this.nextToken();
        };
        JSXParser.prototype.reenterJSX = function() {
          this.startJSX();
          this.expectJSX("}");
          if (this.config.tokens) {
            this.tokens.pop();
          }
        };
        JSXParser.prototype.createJSXNode = function() {
          this.collectComments();
          return {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
          };
        };
        JSXParser.prototype.createJSXChildNode = function() {
          return {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
          };
        };
        JSXParser.prototype.scanXHTMLEntity = function(t) {
          var i = "&";
          var s = !0;
          var u = !1;
          var h = !1;
          var f = !1;
          while (!this.scanner.eof() && s && !u) {
            var p = this.scanner.source[this.scanner.index];
            if (p === t) {
              break;
            }
            u = ";" === p;
            i += p;
            ++this.scanner.index;
            if (!u) {
              switch (i.length) {
               case 2:
                h = "#" === p;
                break;

               case 3:
                if (h) {
                  s = (f = "x" === p) || c.Character.isDecimalDigit(p.charCodeAt(0));
                  h = h && !f;
                }
                break;

               default:
                s = (s = s && !(h && !c.Character.isDecimalDigit(p.charCodeAt(0)))) && !(f && !c.Character.isHexDigit(p.charCodeAt(0)));
              }
            }
          }
          if (s && u && i.length > 2) {
            var m = i.substr(1, i.length - 2);
            if (h && m.length > 1) {
              i = String.fromCharCode(parseInt(m.substr(1), 10));
            } else if (f && m.length > 2) {
              i = String.fromCharCode(parseInt("0" + m.substr(1), 16));
            } else if (!h && !f && D.XHTMLEntities[m]) {
              i = D.XHTMLEntities[m];
            }
          }
          return i;
        };
        JSXParser.prototype.lexJSX = function() {
          var t = this.scanner.source.charCodeAt(this.scanner.index);
          if (60 === t || 62 === t || 47 === t || 58 === t || 61 === t || 123 === t || 125 === t) {
            return {
              type: 7,
              value: p = this.scanner.source[this.scanner.index++],
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: this.scanner.index - 1,
              end: this.scanner.index
            };
          }
          if (34 === t || 39 === t) {
            var i = this.scanner.index;
            var s = this.scanner.source[this.scanner.index++];
            var u = "";
            while (!this.scanner.eof()) {
              if ((m = this.scanner.source[this.scanner.index++]) === s) {
                break;
              } else if ("&" === m) {
                u += this.scanXHTMLEntity(s);
              } else {
                u += m;
              }
            }
            return {
              type: 8,
              value: u,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: i,
              end: this.scanner.index
            };
          }
          if (46 === t) {
            var h = this.scanner.source.charCodeAt(this.scanner.index + 1);
            var f = this.scanner.source.charCodeAt(this.scanner.index + 2);
            var p;
            i = this.scanner.index;
            this.scanner.index += (p = 46 === h && 46 === f ? "..." : ".").length;
            return {
              type: 7,
              value: p,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: i,
              end: this.scanner.index
            };
          }
          if (96 === t) {
            return {
              type: 10,
              value: "",
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: this.scanner.index,
              end: this.scanner.index
            };
          }
          if (c.Character.isIdentifierStart(t) && 92 !== t) {
            i = this.scanner.index;
            ++this.scanner.index;
            while (!this.scanner.eof()) {
              var m = this.scanner.source.charCodeAt(this.scanner.index);
              if (c.Character.isIdentifierPart(m) && 92 !== m) {
                ++this.scanner.index;
              } else if (45 === m) {
                ++this.scanner.index;
              } else {
                break;
              }
            }
            return {
              type: 100,
              value: this.scanner.source.slice(i, this.scanner.index),
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: i,
              end: this.scanner.index
            };
          }
          return this.scanner.lex();
        };
        JSXParser.prototype.nextJSXToken = function() {
          this.collectComments();
          this.startMarker.index = this.scanner.index;
          this.startMarker.line = this.scanner.lineNumber;
          this.startMarker.column = this.scanner.index - this.scanner.lineStart;
          var t = this.lexJSX();
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.line = this.scanner.lineNumber;
          this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
          if (this.config.tokens) {
            this.tokens.push(this.convertToken(t));
          }
          return t;
        };
        JSXParser.prototype.nextJSXText = function() {
          this.startMarker.index = this.scanner.index;
          this.startMarker.line = this.scanner.lineNumber;
          this.startMarker.column = this.scanner.index - this.scanner.lineStart;
          var t = this.scanner.index;
          var i = "";
          while (!this.scanner.eof()) {
            var s = this.scanner.source[this.scanner.index];
            if ("{" === s || "<" === s) {
              break;
            }
            ++this.scanner.index;
            i += s;
            if (c.Character.isLineTerminator(s.charCodeAt(0))) {
              ++this.scanner.lineNumber;
              if ("\r" === s && "\n" === this.scanner.source[this.scanner.index]) {
                ++this.scanner.index;
              }
              this.scanner.lineStart = this.scanner.index;
            }
          }
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.line = this.scanner.lineNumber;
          this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
          var u = {
            type: 101,
            value: i,
            lineNumber: this.scanner.lineNumber,
            lineStart: this.scanner.lineStart,
            start: t,
            end: this.scanner.index
          };
          if (i.length > 0 && this.config.tokens) {
            this.tokens.push(this.convertToken(u));
          }
          return u;
        };
        JSXParser.prototype.peekJSXToken = function() {
          var t = this.scanner.saveState();
          this.scanner.scanComments();
          var i = this.lexJSX();
          this.scanner.restoreState(t);
          return i;
        };
        JSXParser.prototype.expectJSX = function(t) {
          var i = this.nextJSXToken();
          if (7 !== i.type || i.value !== t) {
            this.throwUnexpectedToken(i);
          }
        };
        JSXParser.prototype.matchJSX = function(t) {
          var i = this.peekJSXToken();
          return 7 === i.type && i.value === t;
        };
        JSXParser.prototype.parseJSXIdentifier = function() {
          var t = this.createJSXNode();
          var i = this.nextJSXToken();
          if (100 !== i.type) {
            this.throwUnexpectedToken(i);
          }
          return this.finalize(t, new f.JSXIdentifier(i.value));
        };
        JSXParser.prototype.parseJSXElementName = function() {
          var t = this.createJSXNode();
          var i = this.parseJSXIdentifier();
          if (this.matchJSX(":")) {
            var s = i;
            this.expectJSX(":");
            var u = this.parseJSXIdentifier();
            i = this.finalize(t, new f.JSXNamespacedName(s, u));
          } else if (this.matchJSX(".")) {
            while (this.matchJSX(".")) {
              var h = i;
              this.expectJSX(".");
              var c = this.parseJSXIdentifier();
              i = this.finalize(t, new f.JSXMemberExpression(h, c));
            }
          }
          return i;
        };
        JSXParser.prototype.parseJSXAttributeName = function() {
          var t = this.createJSXNode();
          var i;
          var s = this.parseJSXIdentifier();
          if (this.matchJSX(":")) {
            var u = s;
            this.expectJSX(":");
            var h = this.parseJSXIdentifier();
            i = this.finalize(t, new f.JSXNamespacedName(u, h));
          } else {
            i = s;
          }
          return i;
        };
        JSXParser.prototype.parseJSXStringLiteralAttribute = function() {
          var t = this.createJSXNode();
          var i = this.nextJSXToken();
          if (8 !== i.type) {
            this.throwUnexpectedToken(i);
          }
          var s = this.getTokenRaw(i);
          return this.finalize(t, new m.Literal(i.value, s));
        };
        JSXParser.prototype.parseJSXExpressionAttribute = function() {
          var t = this.createJSXNode();
          this.expectJSX("{");
          this.finishJSX();
          if (this.match("}")) {
            this.tolerateError("JSX attributes must only be assigned a non-empty expression");
          }
          var i = this.parseAssignmentExpression();
          this.reenterJSX();
          return this.finalize(t, new f.JSXExpressionContainer(i));
        };
        JSXParser.prototype.parseJSXAttributeValue = function() {
          return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
        };
        JSXParser.prototype.parseJSXNameValueAttribute = function() {
          var t = this.createJSXNode();
          var i = this.parseJSXAttributeName();
          var s = null;
          if (this.matchJSX("=")) {
            this.expectJSX("=");
            s = this.parseJSXAttributeValue();
          }
          return this.finalize(t, new f.JSXAttribute(i, s));
        };
        JSXParser.prototype.parseJSXSpreadAttribute = function() {
          var t = this.createJSXNode();
          this.expectJSX("{");
          this.expectJSX("...");
          this.finishJSX();
          var i = this.parseAssignmentExpression();
          this.reenterJSX();
          return this.finalize(t, new f.JSXSpreadAttribute(i));
        };
        JSXParser.prototype.parseJSXAttributes = function() {
          var t = [];
          while (!this.matchJSX("/") && !this.matchJSX(">")) {
            var i = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
            t.push(i);
          }
          return t;
        };
        JSXParser.prototype.parseJSXOpeningElement = function() {
          var t = this.createJSXNode();
          this.expectJSX("<");
          var i = this.parseJSXElementName();
          var s = this.parseJSXAttributes();
          var u = this.matchJSX("/");
          if (u) {
            this.expectJSX("/");
          }
          this.expectJSX(">");
          return this.finalize(t, new f.JSXOpeningElement(i, u, s));
        };
        JSXParser.prototype.parseJSXBoundaryElement = function() {
          var t = this.createJSXNode();
          this.expectJSX("<");
          if (this.matchJSX("/")) {
            this.expectJSX("/");
            var i = this.parseJSXElementName();
            this.expectJSX(">");
            return this.finalize(t, new f.JSXClosingElement(i));
          }
          var s = this.parseJSXElementName();
          var u = this.parseJSXAttributes();
          var h = this.matchJSX("/");
          if (h) {
            this.expectJSX("/");
          }
          this.expectJSX(">");
          return this.finalize(t, new f.JSXOpeningElement(s, h, u));
        };
        JSXParser.prototype.parseJSXEmptyExpression = function() {
          var t = this.createJSXChildNode();
          this.collectComments();
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.line = this.scanner.lineNumber;
          this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
          return this.finalize(t, new f.JSXEmptyExpression);
        };
        JSXParser.prototype.parseJSXExpressionContainer = function() {
          var t = this.createJSXNode();
          this.expectJSX("{");
          var i;
          if (this.matchJSX("}")) {
            i = this.parseJSXEmptyExpression();
            this.expectJSX("}");
          } else {
            this.finishJSX();
            i = this.parseAssignmentExpression();
            this.reenterJSX();
          }
          return this.finalize(t, new f.JSXExpressionContainer(i));
        };
        JSXParser.prototype.parseJSXChildren = function() {
          var t = [];
          while (!this.scanner.eof()) {
            var i = this.createJSXChildNode();
            var s = this.nextJSXText();
            if (s.start < s.end) {
              var u = this.getTokenRaw(s);
              var h = this.finalize(i, new f.JSXText(s.value, u));
              t.push(h);
            }
            if ("{" === this.scanner.source[this.scanner.index]) {
              var c = this.parseJSXExpressionContainer();
              t.push(c);
            } else {
              break;
            }
          }
          return t;
        };
        JSXParser.prototype.parseComplexJSXElement = function(t) {
          var i = [];
          while (!this.scanner.eof()) {
            t.children = t.children.concat(this.parseJSXChildren());
            var s = this.createJSXChildNode();
            var u = this.parseJSXBoundaryElement();
            if (u.type === p.JSXSyntax.JSXOpeningElement) {
              var h = u;
              if (h.selfClosing) {
                var c = this.finalize(s, new f.JSXElement(h, [], null));
                t.children.push(c);
              } else {
                i.push(t);
                t = {
                  node: s,
                  opening: h,
                  closing: null,
                  children: []
                };
              }
            }
            if (u.type === p.JSXSyntax.JSXClosingElement) {
              t.closing = u;
              var m = getQualifiedElementName(t.opening.name);
              if (m !== getQualifiedElementName(t.closing.name)) {
                this.tolerateError("Expected corresponding JSX closing tag for %0", m);
              }
              if (i.length > 0) {
                c = this.finalize(t.node, new f.JSXElement(t.opening, t.children, t.closing));
                (t = i[i.length - 1]).children.push(c);
                i.pop();
              } else {
                break;
              }
            }
          }
          return t;
        };
        JSXParser.prototype.parseJSXElement = function() {
          var t = this.createJSXNode();
          var i = this.parseJSXOpeningElement();
          var s = [];
          var u = null;
          if (!i.selfClosing) {
            var h = this.parseComplexJSXElement({
              node: t,
              opening: i,
              closing: u,
              children: s
            });
            s = h.children;
            u = h.closing;
          }
          return this.finalize(t, new f.JSXElement(i, s, u));
        };
        JSXParser.prototype.parseJSXRoot = function() {
          if (this.config.tokens) {
            this.tokens.pop();
          }
          this.startJSX();
          var t = this.parseJSXElement();
          this.finishJSX();
          return t;
        };
        JSXParser.prototype.isStartOfExpression = function() {
          return t.prototype.isStartOfExpression.call(this) || this.match("<");
        };
        return JSXParser;
      }(x.Parser);
      i.JSXParser = y;
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var s = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      i.Character = {
        fromCodePoint: function(t) {
          return t < 65536 ? String.fromCharCode(t) : String.fromCharCode(55296 + (t - 65536 >> 10)) + String.fromCharCode(56320 + (t - 65536 & 1023));
        },
        isWhiteSpace: function(t) {
          return 32 === t || 9 === t || 11 === t || 12 === t || 160 === t || t >= 5760 && [ 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279 ].indexOf(t) >= 0;
        },
        isLineTerminator: function(t) {
          return 10 === t || 13 === t || 8232 === t || 8233 === t;
        },
        isIdentifierStart: function(t) {
          return 36 === t || 95 === t || t >= 65 && t <= 90 || t >= 97 && t <= 122 || 92 === t || t >= 128 && s.NonAsciiIdentifierStart.test(i.Character.fromCodePoint(t));
        },
        isIdentifierPart: function(t) {
          return 36 === t || 95 === t || t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57 || 92 === t || t >= 128 && s.NonAsciiIdentifierPart.test(i.Character.fromCodePoint(t));
        },
        isDecimalDigit: function(t) {
          return t >= 48 && t <= 57;
        },
        isHexDigit: function(t) {
          return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
        },
        isOctalDigit: function(t) {
          return t >= 48 && t <= 55;
        }
      };
    }, function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(6);
      i.JSXClosingElement = function JSXClosingElement(t) {
        this.type = u.JSXSyntax.JSXClosingElement;
        this.name = t;
      };
      i.JSXElement = function JSXElement(t, i, s) {
        this.type = u.JSXSyntax.JSXElement;
        this.openingElement = t;
        this.children = i;
        this.closingElement = s;
      };
      i.JSXEmptyExpression = function JSXEmptyExpression() {
        this.type = u.JSXSyntax.JSXEmptyExpression;
      };
      i.JSXExpressionContainer = function JSXExpressionContainer(t) {
        this.type = u.JSXSyntax.JSXExpressionContainer;
        this.expression = t;
      };
      i.JSXIdentifier = function JSXIdentifier(t) {
        this.type = u.JSXSyntax.JSXIdentifier;
        this.name = t;
      };
      i.JSXMemberExpression = function JSXMemberExpression(t, i) {
        this.type = u.JSXSyntax.JSXMemberExpression;
        this.object = t;
        this.property = i;
      };
      i.JSXAttribute = function JSXAttribute(t, i) {
        this.type = u.JSXSyntax.JSXAttribute;
        this.name = t;
        this.value = i;
      };
      i.JSXNamespacedName = function JSXNamespacedName(t, i) {
        this.type = u.JSXSyntax.JSXNamespacedName;
        this.namespace = t;
        this.name = i;
      };
      i.JSXOpeningElement = function JSXOpeningElement(t, i, s) {
        this.type = u.JSXSyntax.JSXOpeningElement;
        this.name = t;
        this.selfClosing = i;
        this.attributes = s;
      };
      i.JSXSpreadAttribute = function JSXSpreadAttribute(t) {
        this.type = u.JSXSyntax.JSXSpreadAttribute;
        this.argument = t;
      };
      i.JSXText = function JSXText(t, i) {
        this.type = u.JSXSyntax.JSXText;
        this.value = t;
        this.raw = i;
      };
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      i.JSXSyntax = {
        JSXAttribute: "JSXAttribute",
        JSXClosingElement: "JSXClosingElement",
        JSXElement: "JSXElement",
        JSXEmptyExpression: "JSXEmptyExpression",
        JSXExpressionContainer: "JSXExpressionContainer",
        JSXIdentifier: "JSXIdentifier",
        JSXMemberExpression: "JSXMemberExpression",
        JSXNamespacedName: "JSXNamespacedName",
        JSXOpeningElement: "JSXOpeningElement",
        JSXSpreadAttribute: "JSXSpreadAttribute",
        JSXText: "JSXText"
      };
    }, function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(2);
      i.ArrayExpression = function ArrayExpression(t) {
        this.type = u.Syntax.ArrayExpression;
        this.elements = t;
      };
      i.ArrayPattern = function ArrayPattern(t) {
        this.type = u.Syntax.ArrayPattern;
        this.elements = t;
      };
      i.ArrowFunctionExpression = function ArrowFunctionExpression(t, i, s) {
        this.type = u.Syntax.ArrowFunctionExpression;
        this.id = null;
        this.params = t;
        this.body = i;
        this.generator = !1;
        this.expression = s;
        this.async = !1;
      };
      i.AssignmentExpression = function AssignmentExpression(t, i, s) {
        this.type = u.Syntax.AssignmentExpression;
        this.operator = t;
        this.left = i;
        this.right = s;
      };
      i.AssignmentPattern = function AssignmentPattern(t, i) {
        this.type = u.Syntax.AssignmentPattern;
        this.left = t;
        this.right = i;
      };
      i.AsyncArrowFunctionExpression = function AsyncArrowFunctionExpression(t, i, s) {
        this.type = u.Syntax.ArrowFunctionExpression;
        this.id = null;
        this.params = t;
        this.body = i;
        this.generator = !1;
        this.expression = s;
        this.async = !0;
      };
      i.AsyncFunctionDeclaration = function AsyncFunctionDeclaration(t, i, s) {
        this.type = u.Syntax.FunctionDeclaration;
        this.id = t;
        this.params = i;
        this.body = s;
        this.generator = !1;
        this.expression = !1;
        this.async = !0;
      };
      i.AsyncFunctionExpression = function AsyncFunctionExpression(t, i, s) {
        this.type = u.Syntax.FunctionExpression;
        this.id = t;
        this.params = i;
        this.body = s;
        this.generator = !1;
        this.expression = !1;
        this.async = !0;
      };
      i.AwaitExpression = function AwaitExpression(t) {
        this.type = u.Syntax.AwaitExpression;
        this.argument = t;
      };
      i.BinaryExpression = function BinaryExpression(t, i, s) {
        this.type = "||" === t || "&&" === t ? u.Syntax.LogicalExpression : u.Syntax.BinaryExpression;
        this.operator = t;
        this.left = i;
        this.right = s;
      };
      i.BlockStatement = function BlockStatement(t) {
        this.type = u.Syntax.BlockStatement;
        this.body = t;
      };
      i.BreakStatement = function BreakStatement(t) {
        this.type = u.Syntax.BreakStatement;
        this.label = t;
      };
      i.CallExpression = function CallExpression(t, i) {
        this.type = u.Syntax.CallExpression;
        this.callee = t;
        this.arguments = i;
      };
      i.CatchClause = function CatchClause(t, i) {
        this.type = u.Syntax.CatchClause;
        this.param = t;
        this.body = i;
      };
      i.ClassBody = function ClassBody(t) {
        this.type = u.Syntax.ClassBody;
        this.body = t;
      };
      i.ClassDeclaration = function ClassDeclaration(t, i, s) {
        this.type = u.Syntax.ClassDeclaration;
        this.id = t;
        this.superClass = i;
        this.body = s;
      };
      i.ClassExpression = function ClassExpression(t, i, s) {
        this.type = u.Syntax.ClassExpression;
        this.id = t;
        this.superClass = i;
        this.body = s;
      };
      i.ComputedMemberExpression = function ComputedMemberExpression(t, i) {
        this.type = u.Syntax.MemberExpression;
        this.computed = !0;
        this.object = t;
        this.property = i;
      };
      i.ConditionalExpression = function ConditionalExpression(t, i, s) {
        this.type = u.Syntax.ConditionalExpression;
        this.test = t;
        this.consequent = i;
        this.alternate = s;
      };
      i.ContinueStatement = function ContinueStatement(t) {
        this.type = u.Syntax.ContinueStatement;
        this.label = t;
      };
      i.DebuggerStatement = function DebuggerStatement() {
        this.type = u.Syntax.DebuggerStatement;
      };
      i.Directive = function Directive(t, i) {
        this.type = u.Syntax.ExpressionStatement;
        this.expression = t;
        this.directive = i;
      };
      i.DoWhileStatement = function DoWhileStatement(t, i) {
        this.type = u.Syntax.DoWhileStatement;
        this.body = t;
        this.test = i;
      };
      i.EmptyStatement = function EmptyStatement() {
        this.type = u.Syntax.EmptyStatement;
      };
      i.ExportAllDeclaration = function ExportAllDeclaration(t) {
        this.type = u.Syntax.ExportAllDeclaration;
        this.source = t;
      };
      i.ExportDefaultDeclaration = function ExportDefaultDeclaration(t) {
        this.type = u.Syntax.ExportDefaultDeclaration;
        this.declaration = t;
      };
      i.ExportNamedDeclaration = function ExportNamedDeclaration(t, i, s) {
        this.type = u.Syntax.ExportNamedDeclaration;
        this.declaration = t;
        this.specifiers = i;
        this.source = s;
      };
      i.ExportSpecifier = function ExportSpecifier(t, i) {
        this.type = u.Syntax.ExportSpecifier;
        this.exported = i;
        this.local = t;
      };
      i.ExpressionStatement = function ExpressionStatement(t) {
        this.type = u.Syntax.ExpressionStatement;
        this.expression = t;
      };
      i.ForInStatement = function ForInStatement(t, i, s) {
        this.type = u.Syntax.ForInStatement;
        this.left = t;
        this.right = i;
        this.body = s;
        this.each = !1;
      };
      i.ForOfStatement = function ForOfStatement(t, i, s) {
        this.type = u.Syntax.ForOfStatement;
        this.left = t;
        this.right = i;
        this.body = s;
      };
      i.ForStatement = function ForStatement(t, i, s, h) {
        this.type = u.Syntax.ForStatement;
        this.init = t;
        this.test = i;
        this.update = s;
        this.body = h;
      };
      i.FunctionDeclaration = function FunctionDeclaration(t, i, s, h) {
        this.type = u.Syntax.FunctionDeclaration;
        this.id = t;
        this.params = i;
        this.body = s;
        this.generator = h;
        this.expression = !1;
        this.async = !1;
      };
      i.FunctionExpression = function FunctionExpression(t, i, s, h) {
        this.type = u.Syntax.FunctionExpression;
        this.id = t;
        this.params = i;
        this.body = s;
        this.generator = h;
        this.expression = !1;
        this.async = !1;
      };
      i.Identifier = function Identifier(t) {
        this.type = u.Syntax.Identifier;
        this.name = t;
      };
      i.IfStatement = function IfStatement(t, i, s) {
        this.type = u.Syntax.IfStatement;
        this.test = t;
        this.consequent = i;
        this.alternate = s;
      };
      i.ImportDeclaration = function ImportDeclaration(t, i) {
        this.type = u.Syntax.ImportDeclaration;
        this.specifiers = t;
        this.source = i;
      };
      i.ImportDefaultSpecifier = function ImportDefaultSpecifier(t) {
        this.type = u.Syntax.ImportDefaultSpecifier;
        this.local = t;
      };
      i.ImportNamespaceSpecifier = function ImportNamespaceSpecifier(t) {
        this.type = u.Syntax.ImportNamespaceSpecifier;
        this.local = t;
      };
      i.ImportSpecifier = function ImportSpecifier(t, i) {
        this.type = u.Syntax.ImportSpecifier;
        this.local = t;
        this.imported = i;
      };
      i.LabeledStatement = function LabeledStatement(t, i) {
        this.type = u.Syntax.LabeledStatement;
        this.label = t;
        this.body = i;
      };
      i.Literal = function Literal(t, i) {
        this.type = u.Syntax.Literal;
        this.value = t;
        this.raw = i;
      };
      var h = function h(t, i) {
        this.type = u.Syntax.MetaProperty;
        this.meta = t;
        this.property = i;
      };
      i.MetaProperty = h;
      i.MethodDefinition = function MethodDefinition(t, i, s, h, c) {
        this.type = u.Syntax.MethodDefinition;
        this.key = t;
        this.computed = i;
        this.value = s;
        this.kind = h;
        this.static = c;
      };
      i.Module = function Module(t) {
        this.type = u.Syntax.Program;
        this.body = t;
        this.sourceType = "module";
      };
      i.NewExpression = function NewExpression(t, i) {
        this.type = u.Syntax.NewExpression;
        this.callee = t;
        this.arguments = i;
      };
      i.ObjectExpression = function ObjectExpression(t) {
        this.type = u.Syntax.ObjectExpression;
        this.properties = t;
      };
      i.ObjectPattern = function ObjectPattern(t) {
        this.type = u.Syntax.ObjectPattern;
        this.properties = t;
      };
      i.Property = function Property(t, i, s, h, c, f) {
        this.type = u.Syntax.Property;
        this.key = i;
        this.computed = s;
        this.value = h;
        this.kind = t;
        this.method = c;
        this.shorthand = f;
      };
      i.RegexLiteral = function RegexLiteral(t, i, s, h) {
        this.type = u.Syntax.Literal;
        this.value = t;
        this.raw = i;
        this.regex = {
          pattern: s,
          flags: h
        };
      };
      i.RestElement = function RestElement(t) {
        this.type = u.Syntax.RestElement;
        this.argument = t;
      };
      i.ReturnStatement = function ReturnStatement(t) {
        this.type = u.Syntax.ReturnStatement;
        this.argument = t;
      };
      i.Script = function Script(t) {
        this.type = u.Syntax.Program;
        this.body = t;
        this.sourceType = "script";
      };
      i.SequenceExpression = function SequenceExpression(t) {
        this.type = u.Syntax.SequenceExpression;
        this.expressions = t;
      };
      i.SpreadElement = function SpreadElement(t) {
        this.type = u.Syntax.SpreadElement;
        this.argument = t;
      };
      i.StaticMemberExpression = function StaticMemberExpression(t, i) {
        this.type = u.Syntax.MemberExpression;
        this.computed = !1;
        this.object = t;
        this.property = i;
      };
      i.Super = function Super() {
        this.type = u.Syntax.Super;
      };
      i.SwitchCase = function SwitchCase(t, i) {
        this.type = u.Syntax.SwitchCase;
        this.test = t;
        this.consequent = i;
      };
      i.SwitchStatement = function SwitchStatement(t, i) {
        this.type = u.Syntax.SwitchStatement;
        this.discriminant = t;
        this.cases = i;
      };
      i.TaggedTemplateExpression = function TaggedTemplateExpression(t, i) {
        this.type = u.Syntax.TaggedTemplateExpression;
        this.tag = t;
        this.quasi = i;
      };
      i.TemplateElement = function TemplateElement(t, i) {
        this.type = u.Syntax.TemplateElement;
        this.value = t;
        this.tail = i;
      };
      i.TemplateLiteral = function TemplateLiteral(t, i) {
        this.type = u.Syntax.TemplateLiteral;
        this.quasis = t;
        this.expressions = i;
      };
      i.ThisExpression = function ThisExpression() {
        this.type = u.Syntax.ThisExpression;
      };
      i.ThrowStatement = function ThrowStatement(t) {
        this.type = u.Syntax.ThrowStatement;
        this.argument = t;
      };
      i.TryStatement = function TryStatement(t, i, s) {
        this.type = u.Syntax.TryStatement;
        this.block = t;
        this.handler = i;
        this.finalizer = s;
      };
      i.UnaryExpression = function UnaryExpression(t, i) {
        this.type = u.Syntax.UnaryExpression;
        this.operator = t;
        this.argument = i;
        this.prefix = !0;
      };
      i.UpdateExpression = function UpdateExpression(t, i, s) {
        this.type = u.Syntax.UpdateExpression;
        this.operator = t;
        this.argument = i;
        this.prefix = s;
      };
      i.VariableDeclaration = function VariableDeclaration(t, i) {
        this.type = u.Syntax.VariableDeclaration;
        this.declarations = t;
        this.kind = i;
      };
      i.VariableDeclarator = function VariableDeclarator(t, i) {
        this.type = u.Syntax.VariableDeclarator;
        this.id = t;
        this.init = i;
      };
      i.WhileStatement = function WhileStatement(t, i) {
        this.type = u.Syntax.WhileStatement;
        this.test = t;
        this.body = i;
      };
      i.WithStatement = function WithStatement(t, i) {
        this.type = u.Syntax.WithStatement;
        this.object = t;
        this.body = i;
      };
      i.YieldExpression = function YieldExpression(t, i) {
        this.type = u.Syntax.YieldExpression;
        this.argument = t;
        this.delegate = i;
      };
    }, function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(9);
      var h = s(10);
      var c = s(11);
      var f = s(7);
      var p = s(12);
      var m = s(2);
      var x = s(13);
      var v = "ArrowParameterPlaceHolder";
      var D = function() {
        function Parser(t, i, s) {
          if (void 0 === i) {
            i = {};
          }
          this.config = {
            range: "boolean" == typeof i.range && i.range,
            loc: "boolean" == typeof i.loc && i.loc,
            source: null,
            tokens: "boolean" == typeof i.tokens && i.tokens,
            comment: "boolean" == typeof i.comment && i.comment,
            tolerant: "boolean" == typeof i.tolerant && i.tolerant
          };
          if (this.config.loc && i.source && null !== i.source) {
            this.config.source = String(i.source);
          }
          this.delegate = s;
          this.errorHandler = new h.ErrorHandler;
          this.errorHandler.tolerant = this.config.tolerant;
          this.scanner = new p.Scanner(t, this.errorHandler);
          this.scanner.trackComment = this.config.comment;
          this.operatorPrecedence = {
            ")": 0,
            ";": 0,
            ",": 0,
            "=": 0,
            "]": 0,
            "||": 1,
            "&&": 2,
            "|": 3,
            "^": 4,
            "&": 5,
            "==": 6,
            "!=": 6,
            "===": 6,
            "!==": 6,
            "<": 7,
            ">": 7,
            "<=": 7,
            ">=": 7,
            "<<": 8,
            ">>": 8,
            ">>>": 8,
            "+": 9,
            "-": 9,
            "*": 11,
            "/": 11,
            "%": 11
          };
          this.lookahead = {
            type: 2,
            value: "",
            lineNumber: this.scanner.lineNumber,
            lineStart: 0,
            start: 0,
            end: 0
          };
          this.hasLineTerminator = !1;
          this.context = {
            isModule: !1,
            await: !1,
            allowIn: !0,
            allowStrictDirective: !0,
            allowYield: !0,
            firstCoverInitializedNameError: null,
            isAssignmentTarget: !1,
            isBindingElement: !1,
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            labelSet: {},
            strict: !1
          };
          this.tokens = [];
          this.startMarker = {
            index: 0,
            line: this.scanner.lineNumber,
            column: 0
          };
          this.lastMarker = {
            index: 0,
            line: this.scanner.lineNumber,
            column: 0
          };
          this.nextToken();
          this.lastMarker = {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
          };
        }
        Parser.prototype.throwError = function(t) {
          var i = Array.prototype.slice.call(arguments, 1);
          var s = t.replace(/%(\d)/g, (function(t, s) {
            u.assert(s < i.length, "Message reference must be in range");
            return i[s];
          }));
          throw this.errorHandler.createError(this.lastMarker.index, this.lastMarker.line, this.lastMarker.column + 1, s);
        };
        Parser.prototype.tolerateError = function(t) {
          var i = Array.prototype.slice.call(arguments, 1);
          var s = t.replace(/%(\d)/g, (function(t, s) {
            u.assert(s < i.length, "Message reference must be in range");
            return i[s];
          }));
          this.errorHandler.tolerateError(this.lastMarker.index, this.scanner.lineNumber, this.lastMarker.column + 1, s);
        };
        Parser.prototype.unexpectedTokenError = function(t, i) {
          var s = i || c.Messages.UnexpectedToken;
          var u;
          if (t) {
            if (!i) {
              s = 2 === t.type ? c.Messages.UnexpectedEOS : 3 === t.type ? c.Messages.UnexpectedIdentifier : 6 === t.type ? c.Messages.UnexpectedNumber : 8 === t.type ? c.Messages.UnexpectedString : 10 === t.type ? c.Messages.UnexpectedTemplate : c.Messages.UnexpectedToken;
              if (4 === t.type) {
                if (this.scanner.isFutureReservedWord(t.value)) {
                  s = c.Messages.UnexpectedReserved;
                } else if (this.context.strict && this.scanner.isStrictModeReservedWord(t.value)) {
                  s = c.Messages.StrictReservedWord;
                }
              }
            }
            u = t.value;
          } else {
            u = "ILLEGAL";
          }
          s = s.replace("%0", u);
          if (t && "number" == typeof t.lineNumber) {
            return this.errorHandler.createError(t.start, t.lineNumber, t.start - (this.lastMarker.index - this.lastMarker.column) + 1, s);
          } else {
            return this.errorHandler.createError(this.lastMarker.index, this.lastMarker.line, this.lastMarker.column + 1, s);
          }
        };
        Parser.prototype.throwUnexpectedToken = function(t, i) {
          throw this.unexpectedTokenError(t, i);
        };
        Parser.prototype.tolerateUnexpectedToken = function(t, i) {
          this.errorHandler.tolerate(this.unexpectedTokenError(t, i));
        };
        Parser.prototype.collectComments = function() {
          if (!this.config.comment) {
            this.scanner.scanComments();
          } else {
            var t = this.scanner.scanComments();
            if (t.length > 0 && this.delegate) {
              for (var i = 0; i < t.length; ++i) {
                var s = t[i];
                var u = void 0;
                u = {
                  type: s.multiLine ? "BlockComment" : "LineComment",
                  value: this.scanner.source.slice(s.slice[0], s.slice[1])
                };
                if (this.config.range) {
                  u.range = s.range;
                }
                if (this.config.loc) {
                  u.loc = s.loc;
                }
                this.delegate(u, {
                  start: {
                    line: s.loc.start.line,
                    column: s.loc.start.column,
                    offset: s.range[0]
                  },
                  end: {
                    line: s.loc.end.line,
                    column: s.loc.end.column,
                    offset: s.range[1]
                  }
                });
              }
            }
          }
        };
        Parser.prototype.getTokenRaw = function(t) {
          return this.scanner.source.slice(t.start, t.end);
        };
        Parser.prototype.convertToken = function(t) {
          var i = {
            type: x.TokenName[t.type],
            value: this.getTokenRaw(t)
          };
          if (this.config.range) {
            i.range = [ t.start, t.end ];
          }
          if (this.config.loc) {
            i.loc = {
              start: {
                line: this.startMarker.line,
                column: this.startMarker.column
              },
              end: {
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              }
            };
          }
          if (9 === t.type) {
            i.regex = {
              pattern: t.pattern,
              flags: t.flags
            };
          }
          return i;
        };
        Parser.prototype.nextToken = function() {
          var t = this.lookahead;
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.line = this.scanner.lineNumber;
          this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
          this.collectComments();
          if (this.scanner.index !== this.startMarker.index) {
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
          }
          var i = this.scanner.lex();
          this.hasLineTerminator = t.lineNumber !== i.lineNumber;
          if (i && this.context.strict && 3 === i.type) {
            if (this.scanner.isStrictModeReservedWord(i.value)) {
              i.type = 4;
            }
          }
          this.lookahead = i;
          if (this.config.tokens && 2 !== i.type) {
            this.tokens.push(this.convertToken(i));
          }
          return t;
        };
        Parser.prototype.nextRegexToken = function() {
          this.collectComments();
          var t = this.scanner.scanRegExp();
          if (this.config.tokens) {
            this.tokens.pop();
            this.tokens.push(this.convertToken(t));
          }
          this.lookahead = t;
          this.nextToken();
          return t;
        };
        Parser.prototype.createNode = function() {
          return {
            index: this.startMarker.index,
            line: this.startMarker.line,
            column: this.startMarker.column
          };
        };
        Parser.prototype.startNode = function(t, i) {
          if (void 0 === i) {
            i = 0;
          }
          var s = t.start - t.lineStart;
          var u = t.lineNumber;
          if (s < 0) {
            s += i;
            u--;
          }
          return {
            index: t.start,
            line: u,
            column: s
          };
        };
        Parser.prototype.finalize = function(t, i) {
          if (this.config.range) {
            i.range = [ t.index, this.lastMarker.index ];
          }
          if (this.config.loc) {
            i.loc = {
              start: {
                line: t.line,
                column: t.column
              },
              end: {
                line: this.lastMarker.line,
                column: this.lastMarker.column
              }
            };
            if (this.config.source) {
              i.loc.source = this.config.source;
            }
          }
          if (this.delegate) {
            this.delegate(i, {
              start: {
                line: t.line,
                column: t.column,
                offset: t.index
              },
              end: {
                line: this.lastMarker.line,
                column: this.lastMarker.column,
                offset: this.lastMarker.index
              }
            });
          }
          return i;
        };
        Parser.prototype.expect = function(t) {
          var i = this.nextToken();
          if (7 !== i.type || i.value !== t) {
            this.throwUnexpectedToken(i);
          }
        };
        Parser.prototype.expectCommaSeparator = function() {
          if (this.config.tolerant) {
            var t = this.lookahead;
            if (7 === t.type && "," === t.value) {
              this.nextToken();
            } else if (7 === t.type && ";" === t.value) {
              this.nextToken();
              this.tolerateUnexpectedToken(t);
            } else {
              this.tolerateUnexpectedToken(t, c.Messages.UnexpectedToken);
            }
          } else {
            this.expect(",");
          }
        };
        Parser.prototype.expectKeyword = function(t) {
          var i = this.nextToken();
          if (4 !== i.type || i.value !== t) {
            this.throwUnexpectedToken(i);
          }
        };
        Parser.prototype.match = function(t) {
          return 7 === this.lookahead.type && this.lookahead.value === t;
        };
        Parser.prototype.matchKeyword = function(t) {
          return 4 === this.lookahead.type && this.lookahead.value === t;
        };
        Parser.prototype.matchContextualKeyword = function(t) {
          return 3 === this.lookahead.type && this.lookahead.value === t;
        };
        Parser.prototype.matchAssign = function() {
          if (7 !== this.lookahead.type) {
            return !1;
          }
          var t = this.lookahead.value;
          return "=" === t || "*=" === t || "**=" === t || "/=" === t || "%=" === t || "+=" === t || "-=" === t || "<<=" === t || ">>=" === t || ">>>=" === t || "&=" === t || "^=" === t || "|=" === t;
        };
        Parser.prototype.isolateCoverGrammar = function(t) {
          var i = this.context.isBindingElement;
          var s = this.context.isAssignmentTarget;
          var u = this.context.firstCoverInitializedNameError;
          this.context.isBindingElement = !0;
          this.context.isAssignmentTarget = !0;
          this.context.firstCoverInitializedNameError = null;
          var h = t.call(this);
          if (null !== this.context.firstCoverInitializedNameError) {
            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
          }
          this.context.isBindingElement = i;
          this.context.isAssignmentTarget = s;
          this.context.firstCoverInitializedNameError = u;
          return h;
        };
        Parser.prototype.inheritCoverGrammar = function(t) {
          var i = this.context.isBindingElement;
          var s = this.context.isAssignmentTarget;
          var u = this.context.firstCoverInitializedNameError;
          this.context.isBindingElement = !0;
          this.context.isAssignmentTarget = !0;
          this.context.firstCoverInitializedNameError = null;
          var h = t.call(this);
          this.context.isBindingElement = this.context.isBindingElement && i;
          this.context.isAssignmentTarget = this.context.isAssignmentTarget && s;
          this.context.firstCoverInitializedNameError = u || this.context.firstCoverInitializedNameError;
          return h;
        };
        Parser.prototype.consumeSemicolon = function() {
          if (this.match(";")) {
            this.nextToken();
          } else if (!this.hasLineTerminator) {
            if (2 !== this.lookahead.type && !this.match("}")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            this.lastMarker.index = this.startMarker.index;
            this.lastMarker.line = this.startMarker.line;
            this.lastMarker.column = this.startMarker.column;
          }
        };
        Parser.prototype.parsePrimaryExpression = function() {
          var t = this.createNode();
          var i;
          var s, u;
          switch (this.lookahead.type) {
           case 3:
            if ((this.context.isModule || this.context.await) && "await" === this.lookahead.value) {
              this.tolerateUnexpectedToken(this.lookahead);
            }
            i = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(t, new f.Identifier(this.nextToken().value));
            break;

           case 6:
           case 8:
            if (this.context.strict && this.lookahead.octal) {
              this.tolerateUnexpectedToken(this.lookahead, c.Messages.StrictOctalLiteral);
            }
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
            s = this.nextToken();
            u = this.getTokenRaw(s);
            i = this.finalize(t, new f.Literal(s.value, u));
            break;

           case 1:
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
            s = this.nextToken();
            u = this.getTokenRaw(s);
            i = this.finalize(t, new f.Literal("true" === s.value, u));
            break;

           case 5:
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
            s = this.nextToken();
            u = this.getTokenRaw(s);
            i = this.finalize(t, new f.Literal(null, u));
            break;

           case 10:
            i = this.parseTemplateLiteral();
            break;

           case 7:
            switch (this.lookahead.value) {
             case "(":
              this.context.isBindingElement = !1;
              i = this.inheritCoverGrammar(this.parseGroupExpression);
              break;

             case "[":
              i = this.inheritCoverGrammar(this.parseArrayInitializer);
              break;

             case "{":
              i = this.inheritCoverGrammar(this.parseObjectInitializer);
              break;

             case "/":
             case "/=":
              this.context.isAssignmentTarget = !1;
              this.context.isBindingElement = !1;
              this.scanner.index = this.startMarker.index;
              s = this.nextRegexToken();
              u = this.getTokenRaw(s);
              i = this.finalize(t, new f.RegexLiteral(s.regex, u, s.pattern, s.flags));
              break;

             default:
              i = this.throwUnexpectedToken(this.nextToken());
            }
            break;

           case 4:
            if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
              i = this.parseIdentifierName();
            } else if (!this.context.strict && this.matchKeyword("let")) {
              i = this.finalize(t, new f.Identifier(this.nextToken().value));
            } else {
              this.context.isAssignmentTarget = !1;
              this.context.isBindingElement = !1;
              if (this.matchKeyword("function")) {
                i = this.parseFunctionExpression();
              } else if (this.matchKeyword("this")) {
                this.nextToken();
                i = this.finalize(t, new f.ThisExpression);
              } else if (this.matchKeyword("class")) {
                i = this.parseClassExpression();
              } else {
                i = this.throwUnexpectedToken(this.nextToken());
              }
            }
            break;

           default:
            i = this.throwUnexpectedToken(this.nextToken());
          }
          return i;
        };
        Parser.prototype.parseSpreadElement = function() {
          var t = this.createNode();
          this.expect("...");
          var i = this.inheritCoverGrammar(this.parseAssignmentExpression);
          return this.finalize(t, new f.SpreadElement(i));
        };
        Parser.prototype.parseArrayInitializer = function() {
          var t = this.createNode();
          var i = [];
          this.expect("[");
          while (!this.match("]")) {
            if (this.match(",")) {
              this.nextToken();
              i.push(null);
            } else if (this.match("...")) {
              var s = this.parseSpreadElement();
              if (!this.match("]")) {
                this.context.isAssignmentTarget = !1;
                this.context.isBindingElement = !1;
                this.expect(",");
              }
              i.push(s);
            } else {
              i.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
              if (!this.match("]")) {
                this.expect(",");
              }
            }
          }
          this.expect("]");
          return this.finalize(t, new f.ArrayExpression(i));
        };
        Parser.prototype.parsePropertyMethod = function(t) {
          this.context.isAssignmentTarget = !1;
          this.context.isBindingElement = !1;
          var i = this.context.strict;
          var s = this.context.allowStrictDirective;
          this.context.allowStrictDirective = t.simple;
          var u = this.isolateCoverGrammar(this.parseFunctionSourceElements);
          if (this.context.strict && t.firstRestricted) {
            this.tolerateUnexpectedToken(t.firstRestricted, t.message);
          }
          if (this.context.strict && t.stricted) {
            this.tolerateUnexpectedToken(t.stricted, t.message);
          }
          this.context.strict = i;
          this.context.allowStrictDirective = s;
          return u;
        };
        Parser.prototype.parsePropertyMethodFunction = function() {
          var t = this.createNode();
          var i = this.context.allowYield;
          this.context.allowYield = !0;
          var s = this.parseFormalParameters();
          var u = this.parsePropertyMethod(s);
          this.context.allowYield = i;
          return this.finalize(t, new f.FunctionExpression(null, s.params, u, !1));
        };
        Parser.prototype.parsePropertyMethodAsyncFunction = function() {
          var t = this.createNode();
          var i = this.context.allowYield;
          var s = this.context.await;
          this.context.allowYield = !1;
          this.context.await = !0;
          var u = this.parseFormalParameters();
          var h = this.parsePropertyMethod(u);
          this.context.allowYield = i;
          this.context.await = s;
          return this.finalize(t, new f.AsyncFunctionExpression(null, u.params, h));
        };
        Parser.prototype.parseObjectPropertyKey = function() {
          var t = this.createNode();
          var i = this.nextToken();
          var s;
          switch (i.type) {
           case 8:
           case 6:
            if (this.context.strict && i.octal) {
              this.tolerateUnexpectedToken(i, c.Messages.StrictOctalLiteral);
            }
            var u = this.getTokenRaw(i);
            s = this.finalize(t, new f.Literal(i.value, u));
            break;

           case 3:
           case 1:
           case 5:
           case 4:
            s = this.finalize(t, new f.Identifier(i.value));
            break;

           case 7:
            if ("[" === i.value) {
              s = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.expect("]");
            } else {
              s = this.throwUnexpectedToken(i);
            }
            break;

           default:
            s = this.throwUnexpectedToken(i);
          }
          return s;
        };
        Parser.prototype.isPropertyKey = function(t, i) {
          return t.type === m.Syntax.Identifier && t.name === i || t.type === m.Syntax.Literal && t.value === i;
        };
        Parser.prototype.parseObjectProperty = function(t) {
          var i = this.createNode();
          var s = this.lookahead;
          var u;
          var h = null;
          var p = null;
          var m = !1;
          var x = !1;
          var v = !1;
          var D = !1;
          if (3 === s.type) {
            var y = s.value;
            this.nextToken();
            m = this.match("[");
            h = (D = !(this.hasLineTerminator || "async" !== y || this.match(":") || this.match("(") || this.match("*") || this.match(","))) ? this.parseObjectPropertyKey() : this.finalize(i, new f.Identifier(y));
          } else if (this.match("*")) {
            this.nextToken();
          } else {
            m = this.match("[");
            h = this.parseObjectPropertyKey();
          }
          var g = this.qualifiedPropertyName(this.lookahead);
          if (3 === s.type && !D && "get" === s.value && g) {
            u = "get";
            m = this.match("[");
            h = this.parseObjectPropertyKey();
            this.context.allowYield = !1;
            p = this.parseGetterMethod();
          } else if (3 === s.type && !D && "set" === s.value && g) {
            u = "set";
            m = this.match("[");
            h = this.parseObjectPropertyKey();
            p = this.parseSetterMethod();
          } else if (7 === s.type && "*" === s.value && g) {
            u = "init";
            m = this.match("[");
            h = this.parseObjectPropertyKey();
            p = this.parseGeneratorMethod();
            x = !0;
          } else {
            if (!h) {
              this.throwUnexpectedToken(this.lookahead);
            }
            u = "init";
            if (this.match(":") && !D) {
              if (!m && this.isPropertyKey(h, "__proto__")) {
                if (t.value) {
                  this.tolerateError(c.Messages.DuplicateProtoProperty);
                }
                t.value = !0;
              }
              this.nextToken();
              p = this.inheritCoverGrammar(this.parseAssignmentExpression);
            } else if (this.match("(")) {
              p = D ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
              x = !0;
            } else if (3 === s.type) {
              y = this.finalize(i, new f.Identifier(s.value));
              if (this.match("=")) {
                this.context.firstCoverInitializedNameError = this.lookahead;
                this.nextToken();
                v = !0;
                var S = this.isolateCoverGrammar(this.parseAssignmentExpression);
                p = this.finalize(i, new f.AssignmentPattern(y, S));
              } else {
                v = !0;
                p = y;
              }
            } else {
              this.throwUnexpectedToken(this.nextToken());
            }
          }
          return this.finalize(i, new f.Property(u, h, m, p, x, v));
        };
        Parser.prototype.parseObjectInitializer = function() {
          var t = this.createNode();
          this.expect("{");
          var i = [];
          var s = {
            value: !1
          };
          while (!this.match("}")) {
            i.push(this.parseObjectProperty(s));
            if (!this.match("}")) {
              this.expectCommaSeparator();
            }
          }
          this.expect("}");
          return this.finalize(t, new f.ObjectExpression(i));
        };
        Parser.prototype.parseTemplateHead = function() {
          u.assert(this.lookahead.head, "Template literal must start with a template head");
          var t = this.createNode();
          var i = this.nextToken();
          return this.finalize(t, new f.TemplateElement({
            raw: i.value,
            cooked: i.cooked
          }, i.tail));
        };
        Parser.prototype.parseTemplateElement = function() {
          if (10 !== this.lookahead.type) {
            this.throwUnexpectedToken();
          }
          var t = this.createNode();
          var i = this.nextToken();
          return this.finalize(t, new f.TemplateElement({
            raw: i.value,
            cooked: i.cooked
          }, i.tail));
        };
        Parser.prototype.parseTemplateLiteral = function() {
          var t = this.createNode();
          var i = [];
          var s = [];
          var u = this.parseTemplateHead();
          s.push(u);
          while (!u.tail) {
            i.push(this.parseExpression());
            u = this.parseTemplateElement();
            s.push(u);
          }
          return this.finalize(t, new f.TemplateLiteral(s, i));
        };
        Parser.prototype.reinterpretExpressionAsPattern = function(t) {
          switch (t.type) {
           case m.Syntax.Identifier:
           case m.Syntax.MemberExpression:
           case m.Syntax.RestElement:
           case m.Syntax.AssignmentPattern:
            break;

           case m.Syntax.SpreadElement:
            t.type = m.Syntax.RestElement;
            this.reinterpretExpressionAsPattern(t.argument);
            break;

           case m.Syntax.ArrayExpression:
            t.type = m.Syntax.ArrayPattern;
            for (var i = 0; i < t.elements.length; i++) {
              if (null !== t.elements[i]) {
                this.reinterpretExpressionAsPattern(t.elements[i]);
              }
            }
            break;

           case m.Syntax.ObjectExpression:
            t.type = m.Syntax.ObjectPattern;
            for (i = 0; i < t.properties.length; i++) {
              this.reinterpretExpressionAsPattern(t.properties[i].value);
            }
            break;

           case m.Syntax.AssignmentExpression:
            t.type = m.Syntax.AssignmentPattern;
            delete t.operator;
            this.reinterpretExpressionAsPattern(t.left);
          }
        };
        Parser.prototype.parseGroupExpression = function() {
          var t;
          this.expect("(");
          if (this.match(")")) {
            this.nextToken();
            if (!this.match("=>")) {
              this.expect("=>");
            }
            t = {
              type: v,
              params: [],
              async: !1
            };
          } else {
            var i = this.lookahead;
            var s = [];
            if (this.match("...")) {
              t = this.parseRestElement(s);
              this.expect(")");
              if (!this.match("=>")) {
                this.expect("=>");
              }
              t = {
                type: v,
                params: [ t ],
                async: !1
              };
            } else {
              var u = !1;
              this.context.isBindingElement = !0;
              t = this.inheritCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var h = [];
                this.context.isAssignmentTarget = !1;
                h.push(t);
                while (2 !== this.lookahead.type) {
                  if (!this.match(",")) {
                    break;
                  }
                  this.nextToken();
                  if (this.match(")")) {
                    this.nextToken();
                    for (var c = 0; c < h.length; c++) {
                      this.reinterpretExpressionAsPattern(h[c]);
                    }
                    u = !0;
                    t = {
                      type: v,
                      params: h,
                      async: !1
                    };
                  } else if (this.match("...")) {
                    if (!this.context.isBindingElement) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    h.push(this.parseRestElement(s));
                    this.expect(")");
                    if (!this.match("=>")) {
                      this.expect("=>");
                    }
                    this.context.isBindingElement = !1;
                    for (c = 0; c < h.length; c++) {
                      this.reinterpretExpressionAsPattern(h[c]);
                    }
                    u = !0;
                    t = {
                      type: v,
                      params: h,
                      async: !1
                    };
                  } else {
                    h.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  }
                  if (u) {
                    break;
                  }
                }
                if (!u) {
                  t = this.finalize(this.startNode(i), new f.SequenceExpression(h));
                }
              }
              if (!u) {
                this.expect(")");
                if (this.match("=>")) {
                  if (t.type === m.Syntax.Identifier && "yield" === t.name) {
                    u = !0;
                    t = {
                      type: v,
                      params: [ t ],
                      async: !1
                    };
                  }
                  if (!u) {
                    if (!this.context.isBindingElement) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    if (t.type === m.Syntax.SequenceExpression) {
                      for (c = 0; c < t.expressions.length; c++) {
                        this.reinterpretExpressionAsPattern(t.expressions[c]);
                      }
                    } else {
                      this.reinterpretExpressionAsPattern(t);
                    }
                    t = {
                      type: v,
                      params: t.type === m.Syntax.SequenceExpression ? t.expressions : [ t ],
                      async: !1
                    };
                  }
                }
                this.context.isBindingElement = !1;
              }
            }
          }
          return t;
        };
        Parser.prototype.parseArguments = function() {
          this.expect("(");
          var t = [];
          if (!this.match(")")) {
            while (1) {
              var i = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
              t.push(i);
              if (this.match(")")) {
                break;
              }
              this.expectCommaSeparator();
              if (this.match(")")) {
                break;
              }
            }
          }
          this.expect(")");
          return t;
        };
        Parser.prototype.isIdentifierName = function(t) {
          return 3 === t.type || 4 === t.type || 1 === t.type || 5 === t.type;
        };
        Parser.prototype.parseIdentifierName = function() {
          var t = this.createNode();
          var i = this.nextToken();
          if (!this.isIdentifierName(i)) {
            this.throwUnexpectedToken(i);
          }
          return this.finalize(t, new f.Identifier(i.value));
        };
        Parser.prototype.parseNewExpression = function() {
          var t = this.createNode();
          var i = this.parseIdentifierName();
          u.assert("new" === i.name, "New expression must start with `new`");
          var s;
          if (this.match(".")) {
            this.nextToken();
            if (3 === this.lookahead.type && this.context.inFunctionBody && "target" === this.lookahead.value) {
              var h = this.parseIdentifierName();
              s = new f.MetaProperty(i, h);
            } else {
              this.throwUnexpectedToken(this.lookahead);
            }
          } else {
            var c = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
            var p = this.match("(") ? this.parseArguments() : [];
            s = new f.NewExpression(c, p);
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
          }
          return this.finalize(t, s);
        };
        Parser.prototype.parseAsyncArgument = function() {
          var t = this.parseAssignmentExpression();
          this.context.firstCoverInitializedNameError = null;
          return t;
        };
        Parser.prototype.parseAsyncArguments = function() {
          this.expect("(");
          var t = [];
          if (!this.match(")")) {
            while (1) {
              var i = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
              t.push(i);
              if (this.match(")")) {
                break;
              }
              this.expectCommaSeparator();
              if (this.match(")")) {
                break;
              }
            }
          }
          this.expect(")");
          return t;
        };
        Parser.prototype.parseLeftHandSideExpressionAllowCall = function() {
          var t = this.lookahead;
          var i = this.matchContextualKeyword("async");
          var s = this.context.allowIn;
          this.context.allowIn = !0;
          var u;
          if (this.matchKeyword("super") && this.context.inFunctionBody) {
            u = this.createNode();
            this.nextToken();
            u = this.finalize(u, new f.Super);
            if (!this.match("(") && !this.match(".") && !this.match("[")) {
              this.throwUnexpectedToken(this.lookahead);
            }
          } else {
            u = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
          }
          while (1) {
            if (this.match(".")) {
              this.context.isBindingElement = !1;
              this.context.isAssignmentTarget = !0;
              this.expect(".");
              var h = this.parseIdentifierName();
              u = this.finalize(this.startNode(t), new f.StaticMemberExpression(u, h));
            } else if (this.match("(")) {
              var c = i && t.lineNumber === this.lookahead.lineNumber;
              this.context.isBindingElement = !1;
              this.context.isAssignmentTarget = !1;
              var p = c ? this.parseAsyncArguments() : this.parseArguments();
              u = this.finalize(this.startNode(t), new f.CallExpression(u, p));
              if (c && this.match("=>")) {
                for (var m = 0; m < p.length; ++m) {
                  this.reinterpretExpressionAsPattern(p[m]);
                }
                u = {
                  type: v,
                  params: p,
                  async: !0
                };
              }
            } else if (this.match("[")) {
              this.context.isBindingElement = !1;
              this.context.isAssignmentTarget = !0;
              this.expect("[");
              h = this.isolateCoverGrammar(this.parseExpression);
              this.expect("]");
              u = this.finalize(this.startNode(t), new f.ComputedMemberExpression(u, h));
            } else if (10 === this.lookahead.type && this.lookahead.head) {
              var x = this.parseTemplateLiteral();
              u = this.finalize(this.startNode(t), new f.TaggedTemplateExpression(u, x));
            } else {
              break;
            }
          }
          this.context.allowIn = s;
          return u;
        };
        Parser.prototype.parseSuper = function() {
          var t = this.createNode();
          this.expectKeyword("super");
          if (!this.match("[") && !this.match(".")) {
            this.throwUnexpectedToken(this.lookahead);
          }
          return this.finalize(t, new f.Super);
        };
        Parser.prototype.parseLeftHandSideExpression = function() {
          u.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
          var t = this.startNode(this.lookahead);
          var i = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
          while (1) {
            if (this.match("[")) {
              this.context.isBindingElement = !1;
              this.context.isAssignmentTarget = !0;
              this.expect("[");
              var s = this.isolateCoverGrammar(this.parseExpression);
              this.expect("]");
              i = this.finalize(t, new f.ComputedMemberExpression(i, s));
            } else if (this.match(".")) {
              this.context.isBindingElement = !1;
              this.context.isAssignmentTarget = !0;
              this.expect(".");
              s = this.parseIdentifierName();
              i = this.finalize(t, new f.StaticMemberExpression(i, s));
            } else if (10 === this.lookahead.type && this.lookahead.head) {
              var h = this.parseTemplateLiteral();
              i = this.finalize(t, new f.TaggedTemplateExpression(i, h));
            } else {
              break;
            }
          }
          return i;
        };
        Parser.prototype.parseUpdateExpression = function() {
          var t;
          var i = this.lookahead;
          if (this.match("++") || this.match("--")) {
            var s = this.startNode(i);
            var u = this.nextToken();
            t = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (this.context.strict && t.type === m.Syntax.Identifier && this.scanner.isRestrictedWord(t.name)) {
              this.tolerateError(c.Messages.StrictLHSPrefix);
            }
            if (!this.context.isAssignmentTarget) {
              this.tolerateError(c.Messages.InvalidLHSInAssignment);
            }
            t = this.finalize(s, new f.UpdateExpression(u.value, t, p = !0));
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
          } else {
            t = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            if (!this.hasLineTerminator && 7 === this.lookahead.type) {
              if (this.match("++") || this.match("--")) {
                if (this.context.strict && t.type === m.Syntax.Identifier && this.scanner.isRestrictedWord(t.name)) {
                  this.tolerateError(c.Messages.StrictLHSPostfix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(c.Messages.InvalidLHSInAssignment);
                }
                this.context.isAssignmentTarget = !1;
                this.context.isBindingElement = !1;
                var h = this.nextToken().value;
                var p = !1;
                t = this.finalize(this.startNode(i), new f.UpdateExpression(h, t, p));
              }
            }
          }
          return t;
        };
        Parser.prototype.parseAwaitExpression = function() {
          var t = this.createNode();
          this.nextToken();
          var i = this.parseUnaryExpression();
          return this.finalize(t, new f.AwaitExpression(i));
        };
        Parser.prototype.parseUnaryExpression = function() {
          var t;
          if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
            var i = this.startNode(this.lookahead);
            var s = this.nextToken();
            t = this.inheritCoverGrammar(this.parseUnaryExpression);
            t = this.finalize(i, new f.UnaryExpression(s.value, t));
            if (this.context.strict && "delete" === t.operator && t.argument.type === m.Syntax.Identifier) {
              this.tolerateError(c.Messages.StrictDelete);
            }
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
          } else if (this.context.await && this.matchContextualKeyword("await")) {
            t = this.parseAwaitExpression();
          } else {
            t = this.parseUpdateExpression();
          }
          return t;
        };
        Parser.prototype.parseExponentiationExpression = function() {
          var t = this.lookahead;
          var i = this.inheritCoverGrammar(this.parseUnaryExpression);
          if (i.type !== m.Syntax.UnaryExpression && this.match("**")) {
            this.nextToken();
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
            var s = i;
            var u = this.isolateCoverGrammar(this.parseExponentiationExpression);
            i = this.finalize(this.startNode(t), new f.BinaryExpression("**", s, u));
          }
          return i;
        };
        Parser.prototype.binaryPrecedence = function(t) {
          var i = t.value;
          var s;
          if (7 === t.type) {
            s = this.operatorPrecedence[i] || 0;
          } else if (4 === t.type) {
            s = "instanceof" === i || this.context.allowIn && "in" === i ? 7 : 0;
          } else {
            s = 0;
          }
          return s;
        };
        Parser.prototype.parseBinaryExpression = function() {
          var t = this.lookahead;
          var i = this.inheritCoverGrammar(this.parseExponentiationExpression);
          var s = this.lookahead;
          var u = this.binaryPrecedence(s);
          if (u > 0) {
            this.nextToken();
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
            var h = [ t, this.lookahead ];
            var c = i;
            var p = this.isolateCoverGrammar(this.parseExponentiationExpression);
            var m = [ c, s.value, p ];
            var x = [ u ];
            while (1) {
              if ((u = this.binaryPrecedence(this.lookahead)) <= 0) {
                break;
              }
              while (m.length > 2 && u <= x[x.length - 1]) {
                p = m.pop();
                var v = m.pop();
                x.pop();
                c = m.pop();
                h.pop();
                var D = this.startNode(h[h.length - 1]);
                m.push(this.finalize(D, new f.BinaryExpression(v, c, p)));
              }
              m.push(this.nextToken().value);
              x.push(u);
              h.push(this.lookahead);
              m.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
            }
            var y = m.length - 1;
            i = m[y];
            var g = h.pop();
            while (y > 1) {
              var S = h.pop();
              D = this.startNode(S, g && g.lineStart);
              i = this.finalize(D, new f.BinaryExpression(v = m[y - 1], m[y - 2], i));
              y -= 2;
              g = S;
            }
          }
          return i;
        };
        Parser.prototype.parseConditionalExpression = function() {
          var t = this.lookahead;
          var i = this.inheritCoverGrammar(this.parseBinaryExpression);
          if (this.match("?")) {
            this.nextToken();
            var s = this.context.allowIn;
            this.context.allowIn = !0;
            var u = this.isolateCoverGrammar(this.parseAssignmentExpression);
            this.context.allowIn = s;
            this.expect(":");
            var h = this.isolateCoverGrammar(this.parseAssignmentExpression);
            i = this.finalize(this.startNode(t), new f.ConditionalExpression(i, u, h));
            this.context.isAssignmentTarget = !1;
            this.context.isBindingElement = !1;
          }
          return i;
        };
        Parser.prototype.checkPatternParam = function(t, i) {
          switch (i.type) {
           case m.Syntax.Identifier:
            this.validateParam(t, i, i.name);
            break;

           case m.Syntax.RestElement:
            this.checkPatternParam(t, i.argument);
            break;

           case m.Syntax.AssignmentPattern:
            this.checkPatternParam(t, i.left);
            break;

           case m.Syntax.ArrayPattern:
            for (var s = 0; s < i.elements.length; s++) {
              if (null !== i.elements[s]) {
                this.checkPatternParam(t, i.elements[s]);
              }
            }
            break;

           case m.Syntax.ObjectPattern:
            for (s = 0; s < i.properties.length; s++) {
              this.checkPatternParam(t, i.properties[s].value);
            }
          }
          t.simple = t.simple && i instanceof f.Identifier;
        };
        Parser.prototype.reinterpretAsCoverFormalsList = function(t) {
          var i = [ t ];
          var s;
          var u = !1;
          switch (t.type) {
           case m.Syntax.Identifier:
            break;

           case v:
            i = t.params;
            u = t.async;
            break;

           default:
            return null;
          }
          s = {
            simple: !0,
            paramSet: {}
          };
          for (var h = 0; h < i.length; ++h) {
            if ((f = i[h]).type === m.Syntax.AssignmentPattern) {
              if (f.right.type === m.Syntax.YieldExpression) {
                if (f.right.argument) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                f.right.type = m.Syntax.Identifier;
                f.right.name = "yield";
                delete f.right.argument;
                delete f.right.delegate;
              }
            } else if (u && f.type === m.Syntax.Identifier && "await" === f.name) {
              this.throwUnexpectedToken(this.lookahead);
            }
            this.checkPatternParam(s, f);
            i[h] = f;
          }
          if (this.context.strict || !this.context.allowYield) {
            for (h = 0; h < i.length; ++h) {
              var f;
              if ((f = i[h]).type === m.Syntax.YieldExpression) {
                this.throwUnexpectedToken(this.lookahead);
              }
            }
          }
          if (s.message === c.Messages.StrictParamDupe) {
            this.throwUnexpectedToken(this.context.strict ? s.stricted : s.firstRestricted, s.message);
          }
          return {
            simple: s.simple,
            params: i,
            stricted: s.stricted,
            firstRestricted: s.firstRestricted,
            message: s.message
          };
        };
        Parser.prototype.parseAssignmentExpression = function() {
          var t;
          if (!this.context.allowYield && this.matchKeyword("yield")) {
            t = this.parseYieldExpression();
          } else {
            var i = this.lookahead;
            var s = i;
            t = this.parseConditionalExpression();
            if (3 === s.type && s.lineNumber === this.lookahead.lineNumber && "async" === s.value) {
              if (3 === this.lookahead.type || this.matchKeyword("yield")) {
                var u = this.parsePrimaryExpression();
                this.reinterpretExpressionAsPattern(u);
                t = {
                  type: v,
                  params: [ u ],
                  async: !0
                };
              }
            }
            if (t.type === v || this.match("=>")) {
              this.context.isAssignmentTarget = !1;
              this.context.isBindingElement = !1;
              var h = t.async;
              var p = this.reinterpretAsCoverFormalsList(t);
              if (p) {
                if (this.hasLineTerminator) {
                  this.tolerateUnexpectedToken(this.lookahead);
                }
                this.context.firstCoverInitializedNameError = null;
                var x = this.context.strict;
                var D = this.context.allowStrictDirective;
                this.context.allowStrictDirective = p.simple;
                var y = this.context.allowYield;
                var g = this.context.await;
                this.context.allowYield = !0;
                this.context.await = h;
                var S = this.startNode(i);
                this.expect("=>");
                var C = void 0;
                if (this.match("{")) {
                  var A = this.context.allowIn;
                  this.context.allowIn = !0;
                  C = this.parseFunctionSourceElements();
                  this.context.allowIn = A;
                } else {
                  C = this.isolateCoverGrammar(this.parseAssignmentExpression);
                }
                var w = C.type !== m.Syntax.BlockStatement;
                if (this.context.strict && p.firstRestricted) {
                  this.throwUnexpectedToken(p.firstRestricted, p.message);
                }
                if (this.context.strict && p.stricted) {
                  this.tolerateUnexpectedToken(p.stricted, p.message);
                }
                t = h ? this.finalize(S, new f.AsyncArrowFunctionExpression(p.params, C, w)) : this.finalize(S, new f.ArrowFunctionExpression(p.params, C, w));
                this.context.strict = x;
                this.context.allowStrictDirective = D;
                this.context.allowYield = y;
                this.context.await = g;
              }
            } else if (this.matchAssign()) {
              if (!this.context.isAssignmentTarget) {
                this.tolerateError(c.Messages.InvalidLHSInAssignment);
              }
              if (this.context.strict && t.type === m.Syntax.Identifier) {
                var F = t;
                if (this.scanner.isRestrictedWord(F.name)) {
                  this.tolerateUnexpectedToken(s, c.Messages.StrictLHSAssignment);
                }
                if (this.scanner.isStrictModeReservedWord(F.name)) {
                  this.tolerateUnexpectedToken(s, c.Messages.StrictReservedWord);
                }
              }
              if (!this.match("=")) {
                this.context.isAssignmentTarget = !1;
                this.context.isBindingElement = !1;
              } else {
                this.reinterpretExpressionAsPattern(t);
              }
              var B = (s = this.nextToken()).value;
              var b = this.isolateCoverGrammar(this.parseAssignmentExpression);
              t = this.finalize(this.startNode(i), new f.AssignmentExpression(B, t, b));
              this.context.firstCoverInitializedNameError = null;
            }
          }
          return t;
        };
        Parser.prototype.parseExpression = function() {
          var t = this.lookahead;
          var i = this.isolateCoverGrammar(this.parseAssignmentExpression);
          if (this.match(",")) {
            var s = [];
            s.push(i);
            while (2 !== this.lookahead.type) {
              if (!this.match(",")) {
                break;
              }
              this.nextToken();
              s.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
            }
            i = this.finalize(this.startNode(t), new f.SequenceExpression(s));
          }
          return i;
        };
        Parser.prototype.parseStatementListItem = function() {
          var t;
          this.context.isAssignmentTarget = !0;
          this.context.isBindingElement = !0;
          if (4 === this.lookahead.type) {
            switch (this.lookahead.value) {
             case "export":
              if (!this.context.isModule) {
                this.tolerateUnexpectedToken(this.lookahead, c.Messages.IllegalExportDeclaration);
              }
              t = this.parseExportDeclaration();
              break;

             case "import":
              if (!this.context.isModule) {
                this.tolerateUnexpectedToken(this.lookahead, c.Messages.IllegalImportDeclaration);
              }
              t = this.parseImportDeclaration();
              break;

             case "const":
              t = this.parseLexicalDeclaration({
                inFor: !1
              });
              break;

             case "function":
              t = this.parseFunctionDeclaration();
              break;

             case "class":
              t = this.parseClassDeclaration();
              break;

             case "let":
              t = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({
                inFor: !1
              }) : this.parseStatement();
              break;

             default:
              t = this.parseStatement();
            }
          } else {
            t = this.parseStatement();
          }
          return t;
        };
        Parser.prototype.parseBlock = function() {
          var t = this.createNode();
          this.expect("{");
          var i = [];
          while (1) {
            if (this.match("}")) {
              break;
            }
            i.push(this.parseStatementListItem());
          }
          this.expect("}");
          return this.finalize(t, new f.BlockStatement(i));
        };
        Parser.prototype.parseLexicalBinding = function(t, i) {
          var s = this.createNode();
          var u = this.parsePattern([], t);
          if (this.context.strict && u.type === m.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord(u.name)) {
              this.tolerateError(c.Messages.StrictVarName);
            }
          }
          var h = null;
          if ("const" === t) {
            if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
              if (this.match("=")) {
                this.nextToken();
                h = this.isolateCoverGrammar(this.parseAssignmentExpression);
              } else {
                this.throwError(c.Messages.DeclarationMissingInitializer, "const");
              }
            }
          } else if (!i.inFor && u.type !== m.Syntax.Identifier || this.match("=")) {
            this.expect("=");
            h = this.isolateCoverGrammar(this.parseAssignmentExpression);
          }
          return this.finalize(s, new f.VariableDeclarator(u, h));
        };
        Parser.prototype.parseBindingList = function(t, i) {
          var s = [ this.parseLexicalBinding(t, i) ];
          while (this.match(",")) {
            this.nextToken();
            s.push(this.parseLexicalBinding(t, i));
          }
          return s;
        };
        Parser.prototype.isLexicalDeclaration = function() {
          var t = this.scanner.saveState();
          this.scanner.scanComments();
          var i = this.scanner.lex();
          this.scanner.restoreState(t);
          return 3 === i.type || 7 === i.type && "[" === i.value || 7 === i.type && "{" === i.value || 4 === i.type && "let" === i.value || 4 === i.type && "yield" === i.value;
        };
        Parser.prototype.parseLexicalDeclaration = function(t) {
          var i = this.createNode();
          var s = this.nextToken().value;
          u.assert("let" === s || "const" === s, "Lexical declaration must be either let or const");
          var h = this.parseBindingList(s, t);
          this.consumeSemicolon();
          return this.finalize(i, new f.VariableDeclaration(h, s));
        };
        Parser.prototype.parseBindingRestElement = function(t, i) {
          var s = this.createNode();
          this.expect("...");
          var u = this.parsePattern(t, i);
          return this.finalize(s, new f.RestElement(u));
        };
        Parser.prototype.parseArrayPattern = function(t, i) {
          var s = this.createNode();
          this.expect("[");
          var u = [];
          while (!this.match("]")) {
            if (this.match(",")) {
              this.nextToken();
              u.push(null);
            } else {
              if (this.match("...")) {
                u.push(this.parseBindingRestElement(t, i));
                break;
              } else {
                u.push(this.parsePatternWithDefault(t, i));
              }
              if (!this.match("]")) {
                this.expect(",");
              }
            }
          }
          this.expect("]");
          return this.finalize(s, new f.ArrayPattern(u));
        };
        Parser.prototype.parsePropertyPattern = function(t, i) {
          var s = this.createNode();
          var u = !1;
          var h = !1;
          var c;
          var p;
          if (3 === this.lookahead.type) {
            var m = this.lookahead;
            c = this.parseVariableIdentifier();
            var x = this.finalize(s, new f.Identifier(m.value));
            if (this.match("=")) {
              t.push(m);
              h = !0;
              this.nextToken();
              var v = this.parseAssignmentExpression();
              p = this.finalize(this.startNode(m), new f.AssignmentPattern(x, v));
            } else if (!this.match(":")) {
              t.push(m);
              h = !0;
              p = x;
            } else {
              this.expect(":");
              p = this.parsePatternWithDefault(t, i);
            }
          } else {
            u = this.match("[");
            c = this.parseObjectPropertyKey();
            this.expect(":");
            p = this.parsePatternWithDefault(t, i);
          }
          return this.finalize(s, new f.Property("init", c, u, p, !1, h));
        };
        Parser.prototype.parseObjectPattern = function(t, i) {
          var s = this.createNode();
          var u = [];
          this.expect("{");
          while (!this.match("}")) {
            u.push(this.parsePropertyPattern(t, i));
            if (!this.match("}")) {
              this.expect(",");
            }
          }
          this.expect("}");
          return this.finalize(s, new f.ObjectPattern(u));
        };
        Parser.prototype.parsePattern = function(t, i) {
          var s;
          if (this.match("[")) {
            s = this.parseArrayPattern(t, i);
          } else if (this.match("{")) {
            s = this.parseObjectPattern(t, i);
          } else {
            if (this.matchKeyword("let") && ("const" === i || "let" === i)) {
              this.tolerateUnexpectedToken(this.lookahead, c.Messages.LetInLexicalBinding);
            }
            t.push(this.lookahead);
            s = this.parseVariableIdentifier(i);
          }
          return s;
        };
        Parser.prototype.parsePatternWithDefault = function(t, i) {
          var s = this.lookahead;
          var u = this.parsePattern(t, i);
          if (this.match("=")) {
            this.nextToken();
            var h = this.context.allowYield;
            this.context.allowYield = !0;
            var c = this.isolateCoverGrammar(this.parseAssignmentExpression);
            this.context.allowYield = h;
            u = this.finalize(this.startNode(s), new f.AssignmentPattern(u, c));
          }
          return u;
        };
        Parser.prototype.parseVariableIdentifier = function(t) {
          var i = this.createNode();
          var s = this.nextToken();
          if (4 === s.type && "yield" === s.value) {
            if (this.context.strict) {
              this.tolerateUnexpectedToken(s, c.Messages.StrictReservedWord);
            } else if (!this.context.allowYield) {
              this.throwUnexpectedToken(s);
            }
          } else if (3 !== s.type) {
            if (this.context.strict && 4 === s.type && this.scanner.isStrictModeReservedWord(s.value)) {
              this.tolerateUnexpectedToken(s, c.Messages.StrictReservedWord);
            } else if (this.context.strict || "let" !== s.value || "var" !== t) {
              this.throwUnexpectedToken(s);
            }
          } else if ((this.context.isModule || this.context.await) && 3 === s.type && "await" === s.value) {
            this.tolerateUnexpectedToken(s);
          }
          return this.finalize(i, new f.Identifier(s.value));
        };
        Parser.prototype.parseVariableDeclaration = function(t) {
          var i = this.createNode();
          var s = this.parsePattern([], "var");
          if (this.context.strict && s.type === m.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord(s.name)) {
              this.tolerateError(c.Messages.StrictVarName);
            }
          }
          var u = null;
          if (this.match("=")) {
            this.nextToken();
            u = this.isolateCoverGrammar(this.parseAssignmentExpression);
          } else if (s.type !== m.Syntax.Identifier && !t.inFor) {
            this.expect("=");
          }
          return this.finalize(i, new f.VariableDeclarator(s, u));
        };
        Parser.prototype.parseVariableDeclarationList = function(t) {
          var i = {
            inFor: t.inFor
          };
          var s = [];
          s.push(this.parseVariableDeclaration(i));
          while (this.match(",")) {
            this.nextToken();
            s.push(this.parseVariableDeclaration(i));
          }
          return s;
        };
        Parser.prototype.parseVariableStatement = function() {
          var t = this.createNode();
          this.expectKeyword("var");
          var i = this.parseVariableDeclarationList({
            inFor: !1
          });
          this.consumeSemicolon();
          return this.finalize(t, new f.VariableDeclaration(i, "var"));
        };
        Parser.prototype.parseEmptyStatement = function() {
          var t = this.createNode();
          this.expect(";");
          return this.finalize(t, new f.EmptyStatement);
        };
        Parser.prototype.parseExpressionStatement = function() {
          var t = this.createNode();
          var i = this.parseExpression();
          this.consumeSemicolon();
          return this.finalize(t, new f.ExpressionStatement(i));
        };
        Parser.prototype.parseIfClause = function() {
          if (this.context.strict && this.matchKeyword("function")) {
            this.tolerateError(c.Messages.StrictFunction);
          }
          return this.parseStatement();
        };
        Parser.prototype.parseIfStatement = function() {
          var t = this.createNode();
          var i;
          var s = null;
          this.expectKeyword("if");
          this.expect("(");
          var u = this.parseExpression();
          if (!this.match(")") && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            i = this.finalize(this.createNode(), new f.EmptyStatement);
          } else {
            this.expect(")");
            i = this.parseIfClause();
            if (this.matchKeyword("else")) {
              this.nextToken();
              s = this.parseIfClause();
            }
          }
          return this.finalize(t, new f.IfStatement(u, i, s));
        };
        Parser.prototype.parseDoWhileStatement = function() {
          var t = this.createNode();
          this.expectKeyword("do");
          var i = this.context.inIteration;
          this.context.inIteration = !0;
          var s = this.parseStatement();
          this.context.inIteration = i;
          this.expectKeyword("while");
          this.expect("(");
          var u = this.parseExpression();
          if (!this.match(")") && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
          } else {
            this.expect(")");
            if (this.match(";")) {
              this.nextToken();
            }
          }
          return this.finalize(t, new f.DoWhileStatement(s, u));
        };
        Parser.prototype.parseWhileStatement = function() {
          var t = this.createNode();
          var i;
          this.expectKeyword("while");
          this.expect("(");
          var s = this.parseExpression();
          if (!this.match(")") && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            i = this.finalize(this.createNode(), new f.EmptyStatement);
          } else {
            this.expect(")");
            var u = this.context.inIteration;
            this.context.inIteration = !0;
            i = this.parseStatement();
            this.context.inIteration = u;
          }
          return this.finalize(t, new f.WhileStatement(s, i));
        };
        Parser.prototype.parseForStatement = function() {
          var t = null;
          var i = null;
          var s = null;
          var u = !0;
          var h, p;
          var x = this.createNode();
          this.expectKeyword("for");
          this.expect("(");
          if (this.match(";")) {
            this.nextToken();
          } else if (this.matchKeyword("var")) {
            t = this.createNode();
            this.nextToken();
            var v = this.context.allowIn;
            this.context.allowIn = !1;
            var D = this.parseVariableDeclarationList({
              inFor: !0
            });
            this.context.allowIn = v;
            if (1 === D.length && this.matchKeyword("in")) {
              var y = D[0];
              if (y.init && (y.id.type === m.Syntax.ArrayPattern || y.id.type === m.Syntax.ObjectPattern || this.context.strict)) {
                this.tolerateError(c.Messages.ForInOfLoopInitializer, "for-in");
              }
              t = this.finalize(t, new f.VariableDeclaration(D, "var"));
              this.nextToken();
              h = t;
              p = this.parseExpression();
              t = null;
            } else if (1 === D.length && null === D[0].init && this.matchContextualKeyword("of")) {
              t = this.finalize(t, new f.VariableDeclaration(D, "var"));
              this.nextToken();
              h = t;
              p = this.parseAssignmentExpression();
              t = null;
              u = !1;
            } else {
              t = this.finalize(t, new f.VariableDeclaration(D, "var"));
              this.expect(";");
            }
          } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
            t = this.createNode();
            var g = this.nextToken().value;
            if (!this.context.strict && "in" === this.lookahead.value) {
              t = this.finalize(t, new f.Identifier(g));
              this.nextToken();
              h = t;
              p = this.parseExpression();
              t = null;
            } else {
              v = this.context.allowIn;
              this.context.allowIn = !1;
              D = this.parseBindingList(g, {
                inFor: !0
              });
              this.context.allowIn = v;
              if (1 === D.length && null === D[0].init && this.matchKeyword("in")) {
                t = this.finalize(t, new f.VariableDeclaration(D, g));
                this.nextToken();
                h = t;
                p = this.parseExpression();
                t = null;
              } else if (1 === D.length && null === D[0].init && this.matchContextualKeyword("of")) {
                t = this.finalize(t, new f.VariableDeclaration(D, g));
                this.nextToken();
                h = t;
                p = this.parseAssignmentExpression();
                t = null;
                u = !1;
              } else {
                this.consumeSemicolon();
                t = this.finalize(t, new f.VariableDeclaration(D, g));
              }
            }
          } else {
            var S = this.lookahead;
            v = this.context.allowIn;
            this.context.allowIn = !1;
            t = this.inheritCoverGrammar(this.parseAssignmentExpression);
            this.context.allowIn = v;
            if (this.matchKeyword("in")) {
              if (!this.context.isAssignmentTarget || t.type === m.Syntax.AssignmentExpression) {
                this.tolerateError(c.Messages.InvalidLHSInForIn);
              }
              this.nextToken();
              this.reinterpretExpressionAsPattern(t);
              h = t;
              p = this.parseExpression();
              t = null;
            } else if (this.matchContextualKeyword("of")) {
              if (!this.context.isAssignmentTarget || t.type === m.Syntax.AssignmentExpression) {
                this.tolerateError(c.Messages.InvalidLHSInForLoop);
              }
              this.nextToken();
              this.reinterpretExpressionAsPattern(t);
              h = t;
              p = this.parseAssignmentExpression();
              t = null;
              u = !1;
            } else {
              if (this.match(",")) {
                var C = [ t ];
                while (this.match(",")) {
                  this.nextToken();
                  C.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                }
                t = this.finalize(this.startNode(S), new f.SequenceExpression(C));
              }
              this.expect(";");
            }
          }
          if (void 0 === h) {
            if (!this.match(";")) {
              i = this.parseExpression();
            }
            this.expect(";");
            if (!this.match(")")) {
              s = this.parseExpression();
            }
          }
          var A;
          if (!this.match(")") && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            A = this.finalize(this.createNode(), new f.EmptyStatement);
          } else {
            this.expect(")");
            var w = this.context.inIteration;
            this.context.inIteration = !0;
            A = this.isolateCoverGrammar(this.parseStatement);
            this.context.inIteration = w;
          }
          return void 0 === h ? this.finalize(x, new f.ForStatement(t, i, s, A)) : u ? this.finalize(x, new f.ForInStatement(h, p, A)) : this.finalize(x, new f.ForOfStatement(h, p, A));
        };
        Parser.prototype.parseContinueStatement = function() {
          var t = this.createNode();
          this.expectKeyword("continue");
          var i = null;
          if (3 === this.lookahead.type && !this.hasLineTerminator) {
            var s = this.parseVariableIdentifier();
            i = s;
            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, "$" + s.name)) {
              this.throwError(c.Messages.UnknownLabel, s.name);
            }
          }
          this.consumeSemicolon();
          if (null === i && !this.context.inIteration) {
            this.throwError(c.Messages.IllegalContinue);
          }
          return this.finalize(t, new f.ContinueStatement(i));
        };
        Parser.prototype.parseBreakStatement = function() {
          var t = this.createNode();
          this.expectKeyword("break");
          var i = null;
          if (3 === this.lookahead.type && !this.hasLineTerminator) {
            var s = this.parseVariableIdentifier();
            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, "$" + s.name)) {
              this.throwError(c.Messages.UnknownLabel, s.name);
            }
            i = s;
          }
          this.consumeSemicolon();
          if (null === i && !this.context.inIteration && !this.context.inSwitch) {
            this.throwError(c.Messages.IllegalBreak);
          }
          return this.finalize(t, new f.BreakStatement(i));
        };
        Parser.prototype.parseReturnStatement = function() {
          if (!this.context.inFunctionBody) {
            this.tolerateError(c.Messages.IllegalReturn);
          }
          var t = this.createNode();
          this.expectKeyword("return");
          var i = !this.match(";") && !this.match("}") && !this.hasLineTerminator && 2 !== this.lookahead.type || 8 === this.lookahead.type || 10 === this.lookahead.type ? this.parseExpression() : null;
          this.consumeSemicolon();
          return this.finalize(t, new f.ReturnStatement(i));
        };
        Parser.prototype.parseWithStatement = function() {
          if (this.context.strict) {
            this.tolerateError(c.Messages.StrictModeWith);
          }
          var t = this.createNode();
          var i;
          this.expectKeyword("with");
          this.expect("(");
          var s = this.parseExpression();
          if (!this.match(")") && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            i = this.finalize(this.createNode(), new f.EmptyStatement);
          } else {
            this.expect(")");
            i = this.parseStatement();
          }
          return this.finalize(t, new f.WithStatement(s, i));
        };
        Parser.prototype.parseSwitchCase = function() {
          var t = this.createNode();
          var i;
          if (this.matchKeyword("default")) {
            this.nextToken();
            i = null;
          } else {
            this.expectKeyword("case");
            i = this.parseExpression();
          }
          this.expect(":");
          var s = [];
          while (1) {
            if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
              break;
            }
            s.push(this.parseStatementListItem());
          }
          return this.finalize(t, new f.SwitchCase(i, s));
        };
        Parser.prototype.parseSwitchStatement = function() {
          var t = this.createNode();
          this.expectKeyword("switch");
          this.expect("(");
          var i = this.parseExpression();
          this.expect(")");
          var s = this.context.inSwitch;
          this.context.inSwitch = !0;
          var u = [];
          var h = !1;
          this.expect("{");
          while (1) {
            if (this.match("}")) {
              break;
            }
            var p = this.parseSwitchCase();
            if (null === p.test) {
              if (h) {
                this.throwError(c.Messages.MultipleDefaultsInSwitch);
              }
              h = !0;
            }
            u.push(p);
          }
          this.expect("}");
          this.context.inSwitch = s;
          return this.finalize(t, new f.SwitchStatement(i, u));
        };
        Parser.prototype.parseLabelledStatement = function() {
          var t = this.createNode();
          var i = this.parseExpression();
          var s;
          if (i.type === m.Syntax.Identifier && this.match(":")) {
            this.nextToken();
            var u = i;
            var h = "$" + u.name;
            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, h)) {
              this.throwError(c.Messages.Redeclaration, "Label", u.name);
            }
            this.context.labelSet[h] = !0;
            var p = void 0;
            if (this.matchKeyword("class")) {
              this.tolerateUnexpectedToken(this.lookahead);
              p = this.parseClassDeclaration();
            } else if (this.matchKeyword("function")) {
              var x = this.lookahead;
              var v = this.parseFunctionDeclaration();
              if (this.context.strict) {
                this.tolerateUnexpectedToken(x, c.Messages.StrictFunction);
              } else if (v.generator) {
                this.tolerateUnexpectedToken(x, c.Messages.GeneratorInLegacyContext);
              }
              p = v;
            } else {
              p = this.parseStatement();
            }
            delete this.context.labelSet[h];
            s = new f.LabeledStatement(u, p);
          } else {
            this.consumeSemicolon();
            s = new f.ExpressionStatement(i);
          }
          return this.finalize(t, s);
        };
        Parser.prototype.parseThrowStatement = function() {
          var t = this.createNode();
          this.expectKeyword("throw");
          if (this.hasLineTerminator) {
            this.throwError(c.Messages.NewlineAfterThrow);
          }
          var i = this.parseExpression();
          this.consumeSemicolon();
          return this.finalize(t, new f.ThrowStatement(i));
        };
        Parser.prototype.parseCatchClause = function() {
          var t = this.createNode();
          this.expectKeyword("catch");
          this.expect("(");
          if (this.match(")")) {
            this.throwUnexpectedToken(this.lookahead);
          }
          var i = [];
          var s = this.parsePattern(i);
          var u = {};
          for (var h = 0; h < i.length; h++) {
            var p = "$" + i[h].value;
            if (Object.prototype.hasOwnProperty.call(u, p)) {
              this.tolerateError(c.Messages.DuplicateBinding, i[h].value);
            }
            u[p] = !0;
          }
          if (this.context.strict && s.type === m.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord(s.name)) {
              this.tolerateError(c.Messages.StrictCatchVariable);
            }
          }
          this.expect(")");
          var x = this.parseBlock();
          return this.finalize(t, new f.CatchClause(s, x));
        };
        Parser.prototype.parseFinallyClause = function() {
          this.expectKeyword("finally");
          return this.parseBlock();
        };
        Parser.prototype.parseTryStatement = function() {
          var t = this.createNode();
          this.expectKeyword("try");
          var i = this.parseBlock();
          var s = this.matchKeyword("catch") ? this.parseCatchClause() : null;
          var u = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
          if (!s && !u) {
            this.throwError(c.Messages.NoCatchOrFinally);
          }
          return this.finalize(t, new f.TryStatement(i, s, u));
        };
        Parser.prototype.parseDebuggerStatement = function() {
          var t = this.createNode();
          this.expectKeyword("debugger");
          this.consumeSemicolon();
          return this.finalize(t, new f.DebuggerStatement);
        };
        Parser.prototype.parseStatement = function() {
          var t;
          switch (this.lookahead.type) {
           case 1:
           case 5:
           case 6:
           case 8:
           case 10:
           case 9:
            t = this.parseExpressionStatement();
            break;

           case 7:
            var i = this.lookahead.value;
            if ("{" === i) {
              t = this.parseBlock();
            } else if ("(" === i) {
              t = this.parseExpressionStatement();
            } else if (";" === i) {
              t = this.parseEmptyStatement();
            } else {
              t = this.parseExpressionStatement();
            }
            break;

           case 3:
            t = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
            break;

           case 4:
            switch (this.lookahead.value) {
             case "break":
              t = this.parseBreakStatement();
              break;

             case "continue":
              t = this.parseContinueStatement();
              break;

             case "debugger":
              t = this.parseDebuggerStatement();
              break;

             case "do":
              t = this.parseDoWhileStatement();
              break;

             case "for":
              t = this.parseForStatement();
              break;

             case "function":
              t = this.parseFunctionDeclaration();
              break;

             case "if":
              t = this.parseIfStatement();
              break;

             case "return":
              t = this.parseReturnStatement();
              break;

             case "switch":
              t = this.parseSwitchStatement();
              break;

             case "throw":
              t = this.parseThrowStatement();
              break;

             case "try":
              t = this.parseTryStatement();
              break;

             case "var":
              t = this.parseVariableStatement();
              break;

             case "while":
              t = this.parseWhileStatement();
              break;

             case "with":
              t = this.parseWithStatement();
              break;

             default:
              t = this.parseExpressionStatement();
            }
            break;

           default:
            t = this.throwUnexpectedToken(this.lookahead);
          }
          return t;
        };
        Parser.prototype.parseFunctionSourceElements = function() {
          var t = this.createNode();
          this.expect("{");
          var i = this.parseDirectivePrologues();
          var s = this.context.labelSet;
          var u = this.context.inIteration;
          var h = this.context.inSwitch;
          var c = this.context.inFunctionBody;
          this.context.labelSet = {};
          this.context.inIteration = !1;
          this.context.inSwitch = !1;
          this.context.inFunctionBody = !0;
          while (2 !== this.lookahead.type) {
            if (this.match("}")) {
              break;
            }
            i.push(this.parseStatementListItem());
          }
          this.expect("}");
          this.context.labelSet = s;
          this.context.inIteration = u;
          this.context.inSwitch = h;
          this.context.inFunctionBody = c;
          return this.finalize(t, new f.BlockStatement(i));
        };
        Parser.prototype.validateParam = function(t, i, s) {
          var u = "$" + s;
          if (this.context.strict) {
            if (this.scanner.isRestrictedWord(s)) {
              t.stricted = i;
              t.message = c.Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(t.paramSet, u)) {
              t.stricted = i;
              t.message = c.Messages.StrictParamDupe;
            }
          } else if (!t.firstRestricted) {
            if (this.scanner.isRestrictedWord(s)) {
              t.firstRestricted = i;
              t.message = c.Messages.StrictParamName;
            } else if (this.scanner.isStrictModeReservedWord(s)) {
              t.firstRestricted = i;
              t.message = c.Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(t.paramSet, u)) {
              t.stricted = i;
              t.message = c.Messages.StrictParamDupe;
            }
          }
          if ("function" == typeof Object.defineProperty) {
            Object.defineProperty(t.paramSet, u, {
              value: !0,
              enumerable: !0,
              writable: !0,
              configurable: !0
            });
          } else {
            t.paramSet[u] = !0;
          }
        };
        Parser.prototype.parseRestElement = function(t) {
          var i = this.createNode();
          this.expect("...");
          var s = this.parsePattern(t);
          if (this.match("=")) {
            this.throwError(c.Messages.DefaultRestParameter);
          }
          if (!this.match(")")) {
            this.throwError(c.Messages.ParameterAfterRestParameter);
          }
          return this.finalize(i, new f.RestElement(s));
        };
        Parser.prototype.parseFormalParameter = function(t) {
          var i = [];
          var s = this.match("...") ? this.parseRestElement(i) : this.parsePatternWithDefault(i);
          for (var u = 0; u < i.length; u++) {
            this.validateParam(t, i[u], i[u].value);
          }
          t.simple = t.simple && s instanceof f.Identifier;
          t.params.push(s);
        };
        Parser.prototype.parseFormalParameters = function(t) {
          var i;
          i = {
            simple: !0,
            params: [],
            firstRestricted: t
          };
          this.expect("(");
          if (!this.match(")")) {
            i.paramSet = {};
            while (2 !== this.lookahead.type) {
              this.parseFormalParameter(i);
              if (this.match(")")) {
                break;
              }
              this.expect(",");
              if (this.match(")")) {
                break;
              }
            }
          }
          this.expect(")");
          return {
            simple: i.simple,
            params: i.params,
            stricted: i.stricted,
            firstRestricted: i.firstRestricted,
            message: i.message
          };
        };
        Parser.prototype.matchAsyncFunction = function() {
          var t = this.matchContextualKeyword("async");
          if (t) {
            var i = this.scanner.saveState();
            this.scanner.scanComments();
            var s = this.scanner.lex();
            this.scanner.restoreState(i);
            t = i.lineNumber === s.lineNumber && 4 === s.type && "function" === s.value;
          }
          return t;
        };
        Parser.prototype.parseFunctionDeclaration = function(t) {
          var i = this.createNode();
          var s = this.matchContextualKeyword("async");
          if (s) {
            this.nextToken();
          }
          this.expectKeyword("function");
          var u = s ? !1 : this.match("*");
          if (u) {
            this.nextToken();
          }
          var h;
          var p = null;
          var m = null;
          if (!t || !this.match("(")) {
            var x = this.lookahead;
            p = this.parseVariableIdentifier();
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(x.value)) {
                this.tolerateUnexpectedToken(x, c.Messages.StrictFunctionName);
              }
            } else if (this.scanner.isRestrictedWord(x.value)) {
              m = x;
              h = c.Messages.StrictFunctionName;
            } else if (this.scanner.isStrictModeReservedWord(x.value)) {
              m = x;
              h = c.Messages.StrictReservedWord;
            }
          }
          var v = this.context.await;
          var D = this.context.allowYield;
          this.context.await = s;
          this.context.allowYield = !u;
          var y = this.parseFormalParameters(m);
          var g = y.params;
          var S = y.stricted;
          m = y.firstRestricted;
          if (y.message) {
            h = y.message;
          }
          var C = this.context.strict;
          var A = this.context.allowStrictDirective;
          this.context.allowStrictDirective = y.simple;
          var w = this.parseFunctionSourceElements();
          if (this.context.strict && m) {
            this.throwUnexpectedToken(m, h);
          }
          if (this.context.strict && S) {
            this.tolerateUnexpectedToken(S, h);
          }
          this.context.strict = C;
          this.context.allowStrictDirective = A;
          this.context.await = v;
          this.context.allowYield = D;
          return s ? this.finalize(i, new f.AsyncFunctionDeclaration(p, g, w)) : this.finalize(i, new f.FunctionDeclaration(p, g, w, u));
        };
        Parser.prototype.parseFunctionExpression = function() {
          var t = this.createNode();
          var i = this.matchContextualKeyword("async");
          if (i) {
            this.nextToken();
          }
          this.expectKeyword("function");
          var s = i ? !1 : this.match("*");
          if (s) {
            this.nextToken();
          }
          var u;
          var h = null;
          var p;
          var m = this.context.await;
          var x = this.context.allowYield;
          this.context.await = i;
          this.context.allowYield = !s;
          if (!this.match("(")) {
            var v = this.lookahead;
            h = !this.context.strict && !s && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(v.value)) {
                this.tolerateUnexpectedToken(v, c.Messages.StrictFunctionName);
              }
            } else if (this.scanner.isRestrictedWord(v.value)) {
              p = v;
              u = c.Messages.StrictFunctionName;
            } else if (this.scanner.isStrictModeReservedWord(v.value)) {
              p = v;
              u = c.Messages.StrictReservedWord;
            }
          }
          var D = this.parseFormalParameters(p);
          var y = D.params;
          var g = D.stricted;
          p = D.firstRestricted;
          if (D.message) {
            u = D.message;
          }
          var S = this.context.strict;
          var C = this.context.allowStrictDirective;
          this.context.allowStrictDirective = D.simple;
          var A = this.parseFunctionSourceElements();
          if (this.context.strict && p) {
            this.throwUnexpectedToken(p, u);
          }
          if (this.context.strict && g) {
            this.tolerateUnexpectedToken(g, u);
          }
          this.context.strict = S;
          this.context.allowStrictDirective = C;
          this.context.await = m;
          this.context.allowYield = x;
          return i ? this.finalize(t, new f.AsyncFunctionExpression(h, y, A)) : this.finalize(t, new f.FunctionExpression(h, y, A, s));
        };
        Parser.prototype.parseDirective = function() {
          var t = this.lookahead;
          var i = this.createNode();
          var s = this.parseExpression();
          var u = s.type === m.Syntax.Literal ? this.getTokenRaw(t).slice(1, -1) : null;
          this.consumeSemicolon();
          return this.finalize(i, u ? new f.Directive(s, u) : new f.ExpressionStatement(s));
        };
        Parser.prototype.parseDirectivePrologues = function() {
          var t = null;
          var i = [];
          while (1) {
            var s = this.lookahead;
            if (8 !== s.type) {
              break;
            }
            var u = this.parseDirective();
            i.push(u);
            var h = u.directive;
            if ("string" != typeof h) {
              break;
            }
            if ("use strict" === h) {
              this.context.strict = !0;
              if (t) {
                this.tolerateUnexpectedToken(t, c.Messages.StrictOctalLiteral);
              }
              if (!this.context.allowStrictDirective) {
                this.tolerateUnexpectedToken(s, c.Messages.IllegalLanguageModeDirective);
              }
            } else if (!t && s.octal) {
              t = s;
            }
          }
          return i;
        };
        Parser.prototype.qualifiedPropertyName = function(t) {
          switch (t.type) {
           case 3:
           case 8:
           case 1:
           case 5:
           case 6:
           case 4:
            return !0;

           case 7:
            return "[" === t.value;
          }
          return !1;
        };
        Parser.prototype.parseGetterMethod = function() {
          var t = this.createNode();
          var i = this.context.allowYield;
          this.context.allowYield = !0;
          var s = this.parseFormalParameters();
          if (s.params.length > 0) {
            this.tolerateError(c.Messages.BadGetterArity);
          }
          var u = this.parsePropertyMethod(s);
          this.context.allowYield = i;
          return this.finalize(t, new f.FunctionExpression(null, s.params, u, false));
        };
        Parser.prototype.parseSetterMethod = function() {
          var t = this.createNode();
          var i = this.context.allowYield;
          this.context.allowYield = !0;
          var s = this.parseFormalParameters();
          if (1 !== s.params.length) {
            this.tolerateError(c.Messages.BadSetterArity);
          } else if (s.params[0] instanceof f.RestElement) {
            this.tolerateError(c.Messages.BadSetterRestParameter);
          }
          var u = this.parsePropertyMethod(s);
          this.context.allowYield = i;
          return this.finalize(t, new f.FunctionExpression(null, s.params, u, false));
        };
        Parser.prototype.parseGeneratorMethod = function() {
          var t = this.createNode();
          var i = this.context.allowYield;
          this.context.allowYield = !0;
          var s = this.parseFormalParameters();
          this.context.allowYield = !1;
          var u = this.parsePropertyMethod(s);
          this.context.allowYield = i;
          return this.finalize(t, new f.FunctionExpression(null, s.params, u, !0));
        };
        Parser.prototype.isStartOfExpression = function() {
          var t = !0;
          var i = this.lookahead.value;
          switch (this.lookahead.type) {
           case 7:
            t = "[" === i || "(" === i || "{" === i || "+" === i || "-" === i || "!" === i || "~" === i || "++" === i || "--" === i || "/" === i || "/=" === i;
            break;

           case 4:
            t = "class" === i || "delete" === i || "function" === i || "let" === i || "new" === i || "super" === i || "this" === i || "typeof" === i || "void" === i || "yield" === i;
          }
          return t;
        };
        Parser.prototype.parseYieldExpression = function() {
          var t = this.createNode();
          this.expectKeyword("yield");
          var i = null;
          var s = !1;
          if (!this.hasLineTerminator) {
            var u = this.context.allowYield;
            this.context.allowYield = !1;
            if (s = this.match("*")) {
              this.nextToken();
              i = this.parseAssignmentExpression();
            } else if (this.isStartOfExpression()) {
              i = this.parseAssignmentExpression();
            }
            this.context.allowYield = u;
          }
          return this.finalize(t, new f.YieldExpression(i, s));
        };
        Parser.prototype.parseClassElement = function(t) {
          var i = this.lookahead;
          var s = this.createNode();
          var u = "";
          var h = null;
          var p = null;
          var m = !1;
          var x = !1;
          var v = !1;
          var D = !1;
          if (this.match("*")) {
            this.nextToken();
          } else {
            m = this.match("[");
            if ("static" === (h = this.parseObjectPropertyKey()).name && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
              i = this.lookahead;
              v = !0;
              m = this.match("[");
              if (this.match("*")) {
                this.nextToken();
              } else {
                h = this.parseObjectPropertyKey();
              }
            }
            if (3 === i.type && !this.hasLineTerminator && "async" === i.value) {
              var y = this.lookahead.value;
              if (":" !== y && "(" !== y && "*" !== y) {
                D = !0;
                i = this.lookahead;
                h = this.parseObjectPropertyKey();
                if (3 === i.type && "constructor" === i.value) {
                  this.tolerateUnexpectedToken(i, c.Messages.ConstructorIsAsync);
                }
              }
            }
          }
          var g = this.qualifiedPropertyName(this.lookahead);
          if (3 === i.type) {
            if ("get" === i.value && g) {
              u = "get";
              m = this.match("[");
              h = this.parseObjectPropertyKey();
              this.context.allowYield = !1;
              p = this.parseGetterMethod();
            } else if ("set" === i.value && g) {
              u = "set";
              m = this.match("[");
              h = this.parseObjectPropertyKey();
              p = this.parseSetterMethod();
            }
          } else if (7 === i.type && "*" === i.value && g) {
            u = "init";
            m = this.match("[");
            h = this.parseObjectPropertyKey();
            p = this.parseGeneratorMethod();
            x = !0;
          }
          if (!u && h && this.match("(")) {
            u = "init";
            p = D ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
            x = !0;
          }
          if (!u) {
            this.throwUnexpectedToken(this.lookahead);
          }
          if ("init" === u) {
            u = "method";
          }
          if (!m) {
            if (v && this.isPropertyKey(h, "prototype")) {
              this.throwUnexpectedToken(i, c.Messages.StaticPrototype);
            }
            if (!v && this.isPropertyKey(h, "constructor")) {
              if ("method" !== u || !x || p && p.generator) {
                this.throwUnexpectedToken(i, c.Messages.ConstructorSpecialMethod);
              }
              if (t.value) {
                this.throwUnexpectedToken(i, c.Messages.DuplicateConstructor);
              } else {
                t.value = !0;
              }
              u = "constructor";
            }
          }
          return this.finalize(s, new f.MethodDefinition(h, m, p, u, v));
        };
        Parser.prototype.parseClassElementList = function() {
          var t = [];
          var i = {
            value: !1
          };
          this.expect("{");
          while (!this.match("}")) {
            if (this.match(";")) {
              this.nextToken();
            } else {
              t.push(this.parseClassElement(i));
            }
          }
          this.expect("}");
          return t;
        };
        Parser.prototype.parseClassBody = function() {
          var t = this.createNode();
          var i = this.parseClassElementList();
          return this.finalize(t, new f.ClassBody(i));
        };
        Parser.prototype.parseClassDeclaration = function(t) {
          var i = this.createNode();
          var s = this.context.strict;
          this.context.strict = !0;
          this.expectKeyword("class");
          var u = t && 3 !== this.lookahead.type ? null : this.parseVariableIdentifier();
          var h = null;
          if (this.matchKeyword("extends")) {
            this.nextToken();
            h = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
          }
          var c = this.parseClassBody();
          this.context.strict = s;
          return this.finalize(i, new f.ClassDeclaration(u, h, c));
        };
        Parser.prototype.parseClassExpression = function() {
          var t = this.createNode();
          var i = this.context.strict;
          this.context.strict = !0;
          this.expectKeyword("class");
          var s = 3 === this.lookahead.type ? this.parseVariableIdentifier() : null;
          var u = null;
          if (this.matchKeyword("extends")) {
            this.nextToken();
            u = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
          }
          var h = this.parseClassBody();
          this.context.strict = i;
          return this.finalize(t, new f.ClassExpression(s, u, h));
        };
        Parser.prototype.parseModule = function() {
          this.context.strict = !0;
          this.context.isModule = !0;
          this.scanner.isModule = !0;
          var t = this.createNode();
          var i = this.parseDirectivePrologues();
          while (2 !== this.lookahead.type) {
            i.push(this.parseStatementListItem());
          }
          return this.finalize(t, new f.Module(i));
        };
        Parser.prototype.parseScript = function() {
          var t = this.createNode();
          var i = this.parseDirectivePrologues();
          while (2 !== this.lookahead.type) {
            i.push(this.parseStatementListItem());
          }
          return this.finalize(t, new f.Script(i));
        };
        Parser.prototype.parseModuleSpecifier = function() {
          var t = this.createNode();
          if (8 !== this.lookahead.type) {
            this.throwError(c.Messages.InvalidModuleSpecifier);
          }
          var i = this.nextToken();
          var s = this.getTokenRaw(i);
          return this.finalize(t, new f.Literal(i.value, s));
        };
        Parser.prototype.parseImportSpecifier = function() {
          var t = this.createNode();
          var i;
          var s;
          if (3 === this.lookahead.type) {
            s = i = this.parseVariableIdentifier();
            if (this.matchContextualKeyword("as")) {
              this.nextToken();
              s = this.parseVariableIdentifier();
            }
          } else {
            s = i = this.parseIdentifierName();
            if (this.matchContextualKeyword("as")) {
              this.nextToken();
              s = this.parseVariableIdentifier();
            } else {
              this.throwUnexpectedToken(this.nextToken());
            }
          }
          return this.finalize(t, new f.ImportSpecifier(s, i));
        };
        Parser.prototype.parseNamedImports = function() {
          this.expect("{");
          var t = [];
          while (!this.match("}")) {
            t.push(this.parseImportSpecifier());
            if (!this.match("}")) {
              this.expect(",");
            }
          }
          this.expect("}");
          return t;
        };
        Parser.prototype.parseImportDefaultSpecifier = function() {
          var t = this.createNode();
          var i = this.parseIdentifierName();
          return this.finalize(t, new f.ImportDefaultSpecifier(i));
        };
        Parser.prototype.parseImportNamespaceSpecifier = function() {
          var t = this.createNode();
          this.expect("*");
          if (!this.matchContextualKeyword("as")) {
            this.throwError(c.Messages.NoAsAfterImportNamespace);
          }
          this.nextToken();
          var i = this.parseIdentifierName();
          return this.finalize(t, new f.ImportNamespaceSpecifier(i));
        };
        Parser.prototype.parseImportDeclaration = function() {
          if (this.context.inFunctionBody) {
            this.throwError(c.Messages.IllegalImportDeclaration);
          }
          var t = this.createNode();
          this.expectKeyword("import");
          var i;
          var s = [];
          if (8 === this.lookahead.type) {
            i = this.parseModuleSpecifier();
          } else {
            if (this.match("{")) {
              s = s.concat(this.parseNamedImports());
            } else if (this.match("*")) {
              s.push(this.parseImportNamespaceSpecifier());
            } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
              s.push(this.parseImportDefaultSpecifier());
              if (this.match(",")) {
                this.nextToken();
                if (this.match("*")) {
                  s.push(this.parseImportNamespaceSpecifier());
                } else if (this.match("{")) {
                  s = s.concat(this.parseNamedImports());
                } else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              }
            } else {
              this.throwUnexpectedToken(this.nextToken());
            }
            if (!this.matchContextualKeyword("from")) {
              this.throwError(this.lookahead.value ? c.Messages.UnexpectedToken : c.Messages.MissingFromClause, this.lookahead.value);
            }
            this.nextToken();
            i = this.parseModuleSpecifier();
          }
          this.consumeSemicolon();
          return this.finalize(t, new f.ImportDeclaration(s, i));
        };
        Parser.prototype.parseExportSpecifier = function() {
          var t = this.createNode();
          var i = this.parseIdentifierName();
          var s = i;
          if (this.matchContextualKeyword("as")) {
            this.nextToken();
            s = this.parseIdentifierName();
          }
          return this.finalize(t, new f.ExportSpecifier(i, s));
        };
        Parser.prototype.parseExportDeclaration = function() {
          if (this.context.inFunctionBody) {
            this.throwError(c.Messages.IllegalExportDeclaration);
          }
          var t = this.createNode();
          this.expectKeyword("export");
          var i;
          if (this.matchKeyword("default")) {
            this.nextToken();
            if (this.matchKeyword("function")) {
              var s = this.parseFunctionDeclaration(!0);
              i = this.finalize(t, new f.ExportDefaultDeclaration(s));
            } else if (this.matchKeyword("class")) {
              s = this.parseClassDeclaration(!0);
              i = this.finalize(t, new f.ExportDefaultDeclaration(s));
            } else if (this.matchContextualKeyword("async")) {
              s = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression();
              i = this.finalize(t, new f.ExportDefaultDeclaration(s));
            } else {
              if (this.matchContextualKeyword("from")) {
                this.throwError(c.Messages.UnexpectedToken, this.lookahead.value);
              }
              s = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
              this.consumeSemicolon();
              i = this.finalize(t, new f.ExportDefaultDeclaration(s));
            }
          } else if (this.match("*")) {
            this.nextToken();
            if (!this.matchContextualKeyword("from")) {
              this.throwError(this.lookahead.value ? c.Messages.UnexpectedToken : c.Messages.MissingFromClause, this.lookahead.value);
            }
            this.nextToken();
            var u = this.parseModuleSpecifier();
            this.consumeSemicolon();
            i = this.finalize(t, new f.ExportAllDeclaration(u));
          } else if (4 === this.lookahead.type) {
            s = void 0;
            switch (this.lookahead.value) {
             case "let":
             case "const":
              s = this.parseLexicalDeclaration({
                inFor: !1
              });
              break;

             case "var":
             case "class":
             case "function":
              s = this.parseStatementListItem();
              break;

             default:
              this.throwUnexpectedToken(this.lookahead);
            }
            i = this.finalize(t, new f.ExportNamedDeclaration(s, [], null));
          } else if (this.matchAsyncFunction()) {
            s = this.parseFunctionDeclaration();
            i = this.finalize(t, new f.ExportNamedDeclaration(s, [], null));
          } else {
            var h = [];
            var p = null;
            var m = !1;
            this.expect("{");
            while (!this.match("}")) {
              m = m || this.matchKeyword("default");
              h.push(this.parseExportSpecifier());
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            if (this.matchContextualKeyword("from")) {
              this.nextToken();
              p = this.parseModuleSpecifier();
              this.consumeSemicolon();
            } else if (m) {
              this.throwError(this.lookahead.value ? c.Messages.UnexpectedToken : c.Messages.MissingFromClause, this.lookahead.value);
            } else {
              this.consumeSemicolon();
            }
            i = this.finalize(t, new f.ExportNamedDeclaration(null, h, p));
          }
          return i;
        };
        return Parser;
      }();
      i.Parser = D;
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      i.assert = function assert(t, i) {
        if (!t) {
          throw new Error("ASSERT: " + i);
        }
      };
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var s = function() {
        function ErrorHandler() {
          this.errors = [];
          this.tolerant = !1;
        }
        ErrorHandler.prototype.recordError = function(t) {
          this.errors.push(t);
        };
        ErrorHandler.prototype.tolerate = function(t) {
          if (this.tolerant) {
            this.recordError(t);
          } else {
            throw t;
          }
        };
        ErrorHandler.prototype.constructError = function(t, i) {
          var s = new Error(t);
          try {
            throw s;
          } catch (t) {
            if (Object.create && Object.defineProperty) {
              s = Object.create(t);
              Object.defineProperty(s, "column", {
                value: i
              });
            }
          }
          return s;
        };
        ErrorHandler.prototype.createError = function(t, i, s, u) {
          var h = this.constructError("Line " + i + ": " + u, s);
          h.index = t;
          h.lineNumber = i;
          h.description = u;
          return h;
        };
        ErrorHandler.prototype.throwError = function(t, i, s, u) {
          throw this.createError(t, i, s, u);
        };
        ErrorHandler.prototype.tolerateError = function(t, i, s, u) {
          var h = this.createError(t, i, s, u);
          if (this.tolerant) {
            this.recordError(h);
          } else {
            throw h;
          }
        };
        return ErrorHandler;
      }();
      i.ErrorHandler = s;
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      i.Messages = {
        BadGetterArity: "Getter must not have any formal parameters",
        BadSetterArity: "Setter must have exactly one formal parameter",
        BadSetterRestParameter: "Setter function argument must not be a rest parameter",
        ConstructorIsAsync: "Class constructor may not be an async method",
        ConstructorSpecialMethod: "Class constructor may not be an accessor",
        DeclarationMissingInitializer: "Missing initializer in %0 declaration",
        DefaultRestParameter: "Unexpected token =",
        DuplicateBinding: "Duplicate binding %0",
        DuplicateConstructor: "A class may only have one constructor",
        DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
        ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
        GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
        IllegalBreak: "Illegal break statement",
        IllegalContinue: "Illegal continue statement",
        IllegalExportDeclaration: "Unexpected token",
        IllegalImportDeclaration: "Unexpected token",
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
        IllegalReturn: "Illegal return statement",
        InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
        InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
        InvalidLHSInAssignment: "Invalid left-hand side in assignment",
        InvalidLHSInForIn: "Invalid left-hand side in for-in",
        InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
        InvalidModuleSpecifier: "Unexpected token",
        InvalidRegExp: "Invalid regular expression",
        LetInLexicalBinding: "let is disallowed as a lexically bound name",
        MissingFromClause: "Unexpected token",
        MultipleDefaultsInSwitch: "More than one default clause in switch statement",
        NewlineAfterThrow: "Illegal newline after throw",
        NoAsAfterImportNamespace: "Unexpected token",
        NoCatchOrFinally: "Missing catch or finally after try",
        ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
        Redeclaration: "%0 '%1' has already been declared",
        StaticPrototype: "Classes may not have static property named prototype",
        StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
        StrictDelete: "Delete of an unqualified identifier in strict mode.",
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
        StrictFunctionName: "Function name may not be eval or arguments in strict mode",
        StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
        StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
        StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
        StrictModeWith: "Strict mode code may not include a with statement",
        StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
        StrictParamDupe: "Strict mode function may not have duplicate parameter names",
        StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
        StrictReservedWord: "Use of future reserved word in strict mode",
        StrictVarName: "Variable name may not be eval or arguments in strict mode",
        TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
        UnexpectedEOS: "Unexpected end of input",
        UnexpectedIdentifier: "Unexpected identifier",
        UnexpectedNumber: "Unexpected number",
        UnexpectedReserved: "Unexpected reserved word",
        UnexpectedString: "Unexpected string",
        UnexpectedTemplate: "Unexpected quasi %0",
        UnexpectedToken: "Unexpected token %0",
        UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
        UnknownLabel: "Undefined label '%0'",
        UnterminatedRegExp: "Invalid regular expression: missing /"
      };
    }, function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(9);
      var h = s(4);
      var c = s(11);
      function hexValue(t) {
        return "0123456789abcdef".indexOf(t.toLowerCase());
      }
      function octalValue(t) {
        return "01234567".indexOf(t);
      }
      var f = function() {
        function Scanner(t, i) {
          this.source = t;
          this.errorHandler = i;
          this.trackComment = !1;
          this.isModule = !1;
          this.length = t.length;
          this.index = 0;
          this.lineNumber = t.length > 0 ? 1 : 0;
          this.lineStart = 0;
          this.curlyStack = [];
        }
        Scanner.prototype.saveState = function() {
          return {
            index: this.index,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart
          };
        };
        Scanner.prototype.restoreState = function(t) {
          this.index = t.index;
          this.lineNumber = t.lineNumber;
          this.lineStart = t.lineStart;
        };
        Scanner.prototype.eof = function() {
          return this.index >= this.length;
        };
        Scanner.prototype.throwUnexpectedToken = function(t) {
          if (void 0 === t) {
            t = c.Messages.UnexpectedTokenIllegal;
          }
          return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, t);
        };
        Scanner.prototype.tolerateUnexpectedToken = function(t) {
          if (void 0 === t) {
            t = c.Messages.UnexpectedTokenIllegal;
          }
          this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, t);
        };
        Scanner.prototype.skipSingleLineComment = function(t) {
          var i = [];
          var s, u;
          if (this.trackComment) {
            i = [];
            s = this.index - t;
            u = {
              start: {
                line: this.lineNumber,
                column: this.index - this.lineStart - t
              },
              end: {}
            };
          }
          while (!this.eof()) {
            var c = this.source.charCodeAt(this.index);
            ++this.index;
            if (h.Character.isLineTerminator(c)) {
              if (this.trackComment) {
                u.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 1
                };
                i.push({
                  multiLine: !1,
                  slice: [ s + t, this.index - 1 ],
                  range: [ s, this.index - 1 ],
                  loc: u
                });
              }
              if (13 === c && 10 === this.source.charCodeAt(this.index)) {
                ++this.index;
              }
              ++this.lineNumber;
              this.lineStart = this.index;
              return i;
            }
          }
          if (this.trackComment) {
            u.end = {
              line: this.lineNumber,
              column: this.index - this.lineStart
            };
            i.push({
              multiLine: !1,
              slice: [ s + t, this.index ],
              range: [ s, this.index ],
              loc: u
            });
          }
          return i;
        };
        Scanner.prototype.skipMultiLineComment = function() {
          var t = [];
          var i, s;
          if (this.trackComment) {
            t = [];
            i = this.index - 2;
            s = {
              start: {
                line: this.lineNumber,
                column: this.index - this.lineStart - 2
              },
              end: {}
            };
          }
          while (!this.eof()) {
            var u = this.source.charCodeAt(this.index);
            if (h.Character.isLineTerminator(u)) {
              if (13 === u && 10 === this.source.charCodeAt(this.index + 1)) {
                ++this.index;
              }
              ++this.lineNumber;
              ++this.index;
              this.lineStart = this.index;
            } else if (42 === u) {
              if (47 === this.source.charCodeAt(this.index + 1)) {
                this.index += 2;
                if (this.trackComment) {
                  s.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  t.push({
                    multiLine: !0,
                    slice: [ i + 2, this.index - 2 ],
                    range: [ i, this.index ],
                    loc: s
                  });
                }
                return t;
              }
              ++this.index;
            } else {
              ++this.index;
            }
          }
          if (this.trackComment) {
            s.end = {
              line: this.lineNumber,
              column: this.index - this.lineStart
            };
            t.push({
              multiLine: !0,
              slice: [ i + 2, this.index ],
              range: [ i, this.index ],
              loc: s
            });
          }
          this.tolerateUnexpectedToken();
          return t;
        };
        Scanner.prototype.scanComments = function() {
          var t;
          if (this.trackComment) {
            t = [];
          }
          var i = 0 === this.index;
          while (!this.eof()) {
            var s = this.source.charCodeAt(this.index);
            if (h.Character.isWhiteSpace(s)) {
              ++this.index;
            } else if (h.Character.isLineTerminator(s)) {
              ++this.index;
              if (13 === s && 10 === this.source.charCodeAt(this.index)) {
                ++this.index;
              }
              ++this.lineNumber;
              this.lineStart = this.index;
              i = !0;
            } else if (47 === s) {
              if (47 === (s = this.source.charCodeAt(this.index + 1))) {
                this.index += 2;
                var u = this.skipSingleLineComment(2);
                if (this.trackComment) {
                  t = t.concat(u);
                }
                i = !0;
              } else if (42 === s) {
                this.index += 2;
                u = this.skipMultiLineComment();
                if (this.trackComment) {
                  t = t.concat(u);
                }
              } else {
                break;
              }
            } else if (i && 45 === s) {
              if (45 === this.source.charCodeAt(this.index + 1) && 62 === this.source.charCodeAt(this.index + 2)) {
                this.index += 3;
                u = this.skipSingleLineComment(3);
                if (this.trackComment) {
                  t = t.concat(u);
                }
              } else {
                break;
              }
            } else if (60 === s && !this.isModule) {
              if ("!--" === this.source.slice(this.index + 1, this.index + 4)) {
                this.index += 4;
                u = this.skipSingleLineComment(4);
                if (this.trackComment) {
                  t = t.concat(u);
                }
              } else {
                break;
              }
            } else {
              break;
            }
          }
          return t;
        };
        Scanner.prototype.isFutureReservedWord = function(t) {
          switch (t) {
           case "enum":
           case "export":
           case "import":
           case "super":
            return !0;

           default:
            return !1;
          }
        };
        Scanner.prototype.isStrictModeReservedWord = function(t) {
          switch (t) {
           case "implements":
           case "interface":
           case "package":
           case "private":
           case "protected":
           case "public":
           case "static":
           case "yield":
           case "let":
            return !0;

           default:
            return !1;
          }
        };
        Scanner.prototype.isRestrictedWord = function(t) {
          return "eval" === t || "arguments" === t;
        };
        Scanner.prototype.isKeyword = function(t) {
          switch (t.length) {
           case 2:
            return "if" === t || "in" === t || "do" === t;

           case 3:
            return "var" === t || "for" === t || "new" === t || "try" === t || "let" === t;

           case 4:
            return "this" === t || "else" === t || "case" === t || "void" === t || "with" === t || "enum" === t;

           case 5:
            return "while" === t || "break" === t || "catch" === t || "throw" === t || "const" === t || "yield" === t || "class" === t || "super" === t;

           case 6:
            return "return" === t || "typeof" === t || "delete" === t || "switch" === t || "export" === t || "import" === t;

           case 7:
            return "default" === t || "finally" === t || "extends" === t;

           case 8:
            return "function" === t || "continue" === t || "debugger" === t;

           case 10:
            return "instanceof" === t;

           default:
            return !1;
          }
        };
        Scanner.prototype.codePointAt = function(t) {
          var i = this.source.charCodeAt(t);
          if (i >= 55296 && i <= 56319) {
            var s = this.source.charCodeAt(t + 1);
            if (s >= 56320 && s <= 57343) {
              i = 1024 * (i - 55296) + s - 56320 + 65536;
            }
          }
          return i;
        };
        Scanner.prototype.scanHexEscape = function(t) {
          var i = "u" === t ? 4 : 2;
          var s = 0;
          for (var u = 0; u < i; ++u) {
            if (!this.eof() && h.Character.isHexDigit(this.source.charCodeAt(this.index))) {
              s = 16 * s + hexValue(this.source[this.index++]);
            } else {
              return null;
            }
          }
          return String.fromCharCode(s);
        };
        Scanner.prototype.scanUnicodeCodePointEscape = function() {
          var t = this.source[this.index];
          var i = 0;
          if ("}" === t) {
            this.throwUnexpectedToken();
          }
          while (!this.eof()) {
            t = this.source[this.index++];
            if (!h.Character.isHexDigit(t.charCodeAt(0))) {
              break;
            }
            i = 16 * i + hexValue(t);
          }
          if (i > 1114111 || "}" !== t) {
            this.throwUnexpectedToken();
          }
          return h.Character.fromCodePoint(i);
        };
        Scanner.prototype.getIdentifier = function() {
          var t = this.index++;
          while (!this.eof()) {
            var i = this.source.charCodeAt(this.index);
            if (92 === i) {
              this.index = t;
              return this.getComplexIdentifier();
            } else if (i >= 55296 && i < 57343) {
              this.index = t;
              return this.getComplexIdentifier();
            }
            if (h.Character.isIdentifierPart(i)) {
              ++this.index;
            } else {
              break;
            }
          }
          return this.source.slice(t, this.index);
        };
        Scanner.prototype.getComplexIdentifier = function() {
          var t = this.codePointAt(this.index);
          var i = h.Character.fromCodePoint(t);
          this.index += i.length;
          var s;
          if (92 === t) {
            if (117 !== this.source.charCodeAt(this.index)) {
              this.throwUnexpectedToken();
            }
            ++this.index;
            if ("{" === this.source[this.index]) {
              ++this.index;
              s = this.scanUnicodeCodePointEscape();
            } else if (null === (s = this.scanHexEscape("u")) || "\\" === s || !h.Character.isIdentifierStart(s.charCodeAt(0))) {
              this.throwUnexpectedToken();
            }
            i = s;
          }
          while (!this.eof()) {
            t = this.codePointAt(this.index);
            if (!h.Character.isIdentifierPart(t)) {
              break;
            }
            i += s = h.Character.fromCodePoint(t);
            this.index += s.length;
            if (92 === t) {
              i = i.substr(0, i.length - 1);
              if (117 !== this.source.charCodeAt(this.index)) {
                this.throwUnexpectedToken();
              }
              ++this.index;
              if ("{" === this.source[this.index]) {
                ++this.index;
                s = this.scanUnicodeCodePointEscape();
              } else if (null === (s = this.scanHexEscape("u")) || "\\" === s || !h.Character.isIdentifierPart(s.charCodeAt(0))) {
                this.throwUnexpectedToken();
              }
              i += s;
            }
          }
          return i;
        };
        Scanner.prototype.octalToDecimal = function(t) {
          var i = "0" !== t;
          var s = octalValue(t);
          if (!this.eof() && h.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
            i = !0;
            s = 8 * s + octalValue(this.source[this.index++]);
            if ("0123".indexOf(t) >= 0 && !this.eof() && h.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              s = 8 * s + octalValue(this.source[this.index++]);
            }
          }
          return {
            code: s,
            octal: i
          };
        };
        Scanner.prototype.scanIdentifier = function() {
          var t;
          var i = this.index;
          var s = 92 === this.source.charCodeAt(i) ? this.getComplexIdentifier() : this.getIdentifier();
          if (1 === s.length) {
            t = 3;
          } else if (this.isKeyword(s)) {
            t = 4;
          } else if ("null" === s) {
            t = 5;
          } else if ("true" === s || "false" === s) {
            t = 1;
          } else {
            t = 3;
          }
          if (3 !== t && i + s.length !== this.index) {
            var u = this.index;
            this.index = i;
            this.tolerateUnexpectedToken(c.Messages.InvalidEscapedReservedWord);
            this.index = u;
          }
          return {
            type: t,
            value: s,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: i,
            end: this.index
          };
        };
        Scanner.prototype.scanPunctuator = function() {
          var t = this.index;
          var i = this.source[this.index];
          switch (i) {
           case "(":
           case "{":
            if ("{" === i) {
              this.curlyStack.push("{");
            }
            ++this.index;
            break;

           case ".":
            ++this.index;
            if ("." === this.source[this.index] && "." === this.source[this.index + 1]) {
              this.index += 2;
              i = "...";
            }
            break;

           case "}":
            ++this.index;
            this.curlyStack.pop();
            break;

           case ")":
           case ";":
           case ",":
           case "[":
           case "]":
           case ":":
           case "?":
           case "~":
            ++this.index;
            break;

           default:
            if (">>>=" === (i = this.source.substr(this.index, 4))) {
              this.index += 4;
            } else if ("===" === (i = i.substr(0, 3)) || "!==" === i || ">>>" === i || "<<=" === i || ">>=" === i || "**=" === i) {
              this.index += 3;
            } else if ("&&" === (i = i.substr(0, 2)) || "||" === i || "==" === i || "!=" === i || "+=" === i || "-=" === i || "*=" === i || "/=" === i || "++" === i || "--" === i || "<<" === i || ">>" === i || "&=" === i || "|=" === i || "^=" === i || "%=" === i || "<=" === i || ">=" === i || "=>" === i || "**" === i) {
              this.index += 2;
            } else if ("<>=!+-*%&|^/".indexOf(i = this.source[this.index]) >= 0) {
              ++this.index;
            }
          }
          if (this.index === t) {
            this.throwUnexpectedToken();
          }
          return {
            type: 7,
            value: i,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: t,
            end: this.index
          };
        };
        Scanner.prototype.scanHexLiteral = function(t) {
          var i = "";
          while (!this.eof()) {
            if (!h.Character.isHexDigit(this.source.charCodeAt(this.index))) {
              break;
            }
            i += this.source[this.index++];
          }
          if (0 === i.length) {
            this.throwUnexpectedToken();
          }
          if (h.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
          }
          return {
            type: 6,
            value: parseInt("0x" + i, 16),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: t,
            end: this.index
          };
        };
        Scanner.prototype.scanBinaryLiteral = function(t) {
          var i = "";
          var s;
          while (!this.eof()) {
            if ("0" !== (s = this.source[this.index]) && "1" !== s) {
              break;
            }
            i += this.source[this.index++];
          }
          if (0 === i.length) {
            this.throwUnexpectedToken();
          }
          if (!this.eof()) {
            s = this.source.charCodeAt(this.index);
            if (h.Character.isIdentifierStart(s) || h.Character.isDecimalDigit(s)) {
              this.throwUnexpectedToken();
            }
          }
          return {
            type: 6,
            value: parseInt(i, 2),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: t,
            end: this.index
          };
        };
        Scanner.prototype.scanOctalLiteral = function(t, i) {
          var s = "";
          var u = !1;
          if (h.Character.isOctalDigit(t.charCodeAt(0))) {
            u = !0;
            s = "0" + this.source[this.index++];
          } else {
            ++this.index;
          }
          while (!this.eof()) {
            if (!h.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              break;
            }
            s += this.source[this.index++];
          }
          if (!u && 0 === s.length) {
            this.throwUnexpectedToken();
          }
          if (h.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || h.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
          }
          return {
            type: 6,
            value: parseInt(s, 8),
            octal: u,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: i,
            end: this.index
          };
        };
        Scanner.prototype.isImplicitOctalLiteral = function() {
          for (var t = this.index + 1; t < this.length; ++t) {
            var i = this.source[t];
            if ("8" === i || "9" === i) {
              return !1;
            }
            if (!h.Character.isOctalDigit(i.charCodeAt(0))) {
              return !0;
            }
          }
          return !0;
        };
        Scanner.prototype.scanNumericLiteral = function() {
          var t = this.index;
          var i = this.source[t];
          u.assert(h.Character.isDecimalDigit(i.charCodeAt(0)) || "." === i, "Numeric literal must start with a decimal digit or a decimal point");
          var s = "";
          if ("." !== i) {
            s = this.source[this.index++];
            i = this.source[this.index];
            if ("0" === s) {
              if ("x" === i || "X" === i) {
                ++this.index;
                return this.scanHexLiteral(t);
              }
              if ("b" === i || "B" === i) {
                ++this.index;
                return this.scanBinaryLiteral(t);
              }
              if ("o" === i || "O" === i) {
                return this.scanOctalLiteral(i, t);
              }
              if (i && h.Character.isOctalDigit(i.charCodeAt(0))) {
                if (this.isImplicitOctalLiteral()) {
                  return this.scanOctalLiteral(i, t);
                }
              }
            }
            while (h.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              s += this.source[this.index++];
            }
            i = this.source[this.index];
          }
          if ("." === i) {
            s += this.source[this.index++];
            while (h.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              s += this.source[this.index++];
            }
            i = this.source[this.index];
          }
          if ("e" === i || "E" === i) {
            s += this.source[this.index++];
            if ("+" === (i = this.source[this.index]) || "-" === i) {
              s += this.source[this.index++];
            }
            if (h.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              while (h.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                s += this.source[this.index++];
              }
            } else {
              this.throwUnexpectedToken();
            }
          }
          if (h.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
          }
          return {
            type: 6,
            value: parseFloat(s),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: t,
            end: this.index
          };
        };
        Scanner.prototype.scanStringLiteral = function() {
          var t = this.index;
          var i = this.source[t];
          u.assert("'" === i || '"' === i, "String literal must starts with a quote");
          ++this.index;
          var s = !1;
          var f = "";
          while (!this.eof()) {
            var p = this.source[this.index++];
            if (p === i) {
              i = "";
              break;
            } else if ("\\" === p) {
              if (!(p = this.source[this.index++]) || !h.Character.isLineTerminator(p.charCodeAt(0))) {
                switch (p) {
                 case "u":
                  if ("{" === this.source[this.index]) {
                    ++this.index;
                    f += this.scanUnicodeCodePointEscape();
                  } else {
                    var m = this.scanHexEscape(p);
                    if (null === m) {
                      this.throwUnexpectedToken();
                    }
                    f += m;
                  }
                  break;

                 case "x":
                  var x = this.scanHexEscape(p);
                  if (null === x) {
                    this.throwUnexpectedToken(c.Messages.InvalidHexEscapeSequence);
                  }
                  f += x;
                  break;

                 case "n":
                  f += "\n";
                  break;

                 case "r":
                  f += "\r";
                  break;

                 case "t":
                  f += "\t";
                  break;

                 case "b":
                  f += "\b";
                  break;

                 case "f":
                  f += "\f";
                  break;

                 case "v":
                  f += "\v";
                  break;

                 case "8":
                 case "9":
                  f += p;
                  this.tolerateUnexpectedToken();
                  break;

                 default:
                  if (p && h.Character.isOctalDigit(p.charCodeAt(0))) {
                    var v = this.octalToDecimal(p);
                    s = v.octal || s;
                    f += String.fromCharCode(v.code);
                  } else {
                    f += p;
                  }
                }
              } else {
                ++this.lineNumber;
                if ("\r" === p && "\n" === this.source[this.index]) {
                  ++this.index;
                }
                this.lineStart = this.index;
              }
            } else if (h.Character.isLineTerminator(p.charCodeAt(0))) {
              break;
            } else {
              f += p;
            }
          }
          if ("" !== i) {
            this.index = t;
            this.throwUnexpectedToken();
          }
          return {
            type: 8,
            value: f,
            octal: s,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: t,
            end: this.index
          };
        };
        Scanner.prototype.scanTemplate = function() {
          var t = "";
          var i = !1;
          var s = this.index;
          var u = "`" === this.source[s];
          var f = !1;
          var p = 2;
          ++this.index;
          while (!this.eof()) {
            var m = this.source[this.index++];
            if ("`" === m) {
              p = 1;
              f = !0;
              i = !0;
              break;
            } else if ("$" === m) {
              if ("{" === this.source[this.index]) {
                this.curlyStack.push("${");
                ++this.index;
                i = !0;
                break;
              }
              t += m;
            } else if ("\\" === m) {
              m = this.source[this.index++];
              if (!h.Character.isLineTerminator(m.charCodeAt(0))) {
                switch (m) {
                 case "n":
                  t += "\n";
                  break;

                 case "r":
                  t += "\r";
                  break;

                 case "t":
                  t += "\t";
                  break;

                 case "u":
                  if ("{" === this.source[this.index]) {
                    ++this.index;
                    t += this.scanUnicodeCodePointEscape();
                  } else {
                    var x = this.index;
                    var v = this.scanHexEscape(m);
                    if (null !== v) {
                      t += v;
                    } else {
                      this.index = x;
                      t += m;
                    }
                  }
                  break;

                 case "x":
                  var D = this.scanHexEscape(m);
                  if (null === D) {
                    this.throwUnexpectedToken(c.Messages.InvalidHexEscapeSequence);
                  }
                  t += D;
                  break;

                 case "b":
                  t += "\b";
                  break;

                 case "f":
                  t += "\f";
                  break;

                 case "v":
                  t += "\v";
                  break;

                 default:
                  if ("0" === m) {
                    if (h.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      this.throwUnexpectedToken(c.Messages.TemplateOctalLiteral);
                    }
                    t += "\0";
                  } else if (h.Character.isOctalDigit(m.charCodeAt(0))) {
                    this.throwUnexpectedToken(c.Messages.TemplateOctalLiteral);
                  } else {
                    t += m;
                  }
                }
              } else {
                ++this.lineNumber;
                if ("\r" === m && "\n" === this.source[this.index]) {
                  ++this.index;
                }
                this.lineStart = this.index;
              }
            } else if (h.Character.isLineTerminator(m.charCodeAt(0))) {
              ++this.lineNumber;
              if ("\r" === m && "\n" === this.source[this.index]) {
                ++this.index;
              }
              this.lineStart = this.index;
              t += "\n";
            } else {
              t += m;
            }
          }
          if (!i) {
            this.throwUnexpectedToken();
          }
          if (!u) {
            this.curlyStack.pop();
          }
          return {
            type: 10,
            value: this.source.slice(s + 1, this.index - p),
            cooked: t,
            head: u,
            tail: f,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: s,
            end: this.index
          };
        };
        Scanner.prototype.testRegExp = function(t, i) {
          var s = t;
          var u = this;
          if (i.indexOf("u") >= 0) {
            s = s.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, (function(t, i, s) {
              var h = parseInt(i || s, 16);
              if (h > 1114111) {
                u.throwUnexpectedToken(c.Messages.InvalidRegExp);
              }
              if (h <= 65535) {
                return String.fromCharCode(h);
              }
              return "￿";
            })).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "￿");
          }
          try {
            return new RegExp(t, i);
          } catch (t) {
            return null;
          }
        };
        Scanner.prototype.scanRegExpBody = function() {
          var t = this.source[this.index];
          u.assert("/" === t, "Regular expression literal must start with a slash");
          var i = this.source[this.index++];
          var s = !1;
          var f = !1;
          while (!this.eof()) {
            i += t = this.source[this.index++];
            if ("\\" === t) {
              t = this.source[this.index++];
              if (h.Character.isLineTerminator(t.charCodeAt(0))) {
                this.throwUnexpectedToken(c.Messages.UnterminatedRegExp);
              }
              i += t;
            } else if (h.Character.isLineTerminator(t.charCodeAt(0))) {
              this.throwUnexpectedToken(c.Messages.UnterminatedRegExp);
            } else if (s) {
              if ("]" === t) {
                s = !1;
              }
            } else if ("/" === t) {
              f = !0;
              break;
            } else if ("[" === t) {
              s = !0;
            }
          }
          if (!f) {
            this.throwUnexpectedToken(c.Messages.UnterminatedRegExp);
          }
          return i.substr(1, i.length - 2);
        };
        Scanner.prototype.scanRegExpFlags = function() {
          var t = "";
          var i = "";
          while (!this.eof()) {
            var s = this.source[this.index];
            if (!h.Character.isIdentifierPart(s.charCodeAt(0))) {
              break;
            }
            ++this.index;
            if ("\\" === s && !this.eof()) {
              if ("u" === (s = this.source[this.index])) {
                ++this.index;
                var u = this.index;
                var c = this.scanHexEscape("u");
                if (null !== c) {
                  i += c;
                  for (t += "\\u"; u < this.index; ++u) {
                    t += this.source[u];
                  }
                } else {
                  this.index = u;
                  i += "u";
                  t += "\\u";
                }
                this.tolerateUnexpectedToken();
              } else {
                t += "\\";
                this.tolerateUnexpectedToken();
              }
            } else {
              i += s;
              t += s;
            }
          }
          return i;
        };
        Scanner.prototype.scanRegExp = function() {
          var t = this.index;
          var i = this.scanRegExpBody();
          var s = this.scanRegExpFlags();
          return {
            type: 9,
            value: "",
            pattern: i,
            flags: s,
            regex: this.testRegExp(i, s),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: t,
            end: this.index
          };
        };
        Scanner.prototype.lex = function() {
          if (this.eof()) {
            return {
              type: 2,
              value: "",
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start: this.index,
              end: this.index
            };
          }
          var t = this.source.charCodeAt(this.index);
          if (h.Character.isIdentifierStart(t)) {
            return this.scanIdentifier();
          }
          if (40 === t || 41 === t || 59 === t) {
            return this.scanPunctuator();
          }
          if (39 === t || 34 === t) {
            return this.scanStringLiteral();
          }
          if (46 === t) {
            if (h.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
              return this.scanNumericLiteral();
            }
            return this.scanPunctuator();
          }
          if (h.Character.isDecimalDigit(t)) {
            return this.scanNumericLiteral();
          }
          if (96 === t || 125 === t && "${" === this.curlyStack[this.curlyStack.length - 1]) {
            return this.scanTemplate();
          }
          if (t >= 55296 && t < 57343) {
            if (h.Character.isIdentifierStart(this.codePointAt(this.index))) {
              return this.scanIdentifier();
            }
          }
          return this.scanPunctuator();
        };
        return Scanner;
      }();
      i.Scanner = f;
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      i.TokenName = {};
      i.TokenName[1] = "Boolean";
      i.TokenName[2] = "<end>";
      i.TokenName[3] = "Identifier";
      i.TokenName[4] = "Keyword";
      i.TokenName[5] = "Null";
      i.TokenName[6] = "Numeric";
      i.TokenName[7] = "Punctuator";
      i.TokenName[8] = "String";
      i.TokenName[9] = "RegularExpression";
      i.TokenName[10] = "Template";
    }, function(t, i) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      i.XHTMLEntities = {
        quot: '"',
        amp: "&",
        apos: "'",
        gt: ">",
        nbsp: " ",
        iexcl: "¡",
        cent: "¢",
        pound: "£",
        curren: "¤",
        yen: "¥",
        brvbar: "¦",
        sect: "§",
        uml: "¨",
        copy: "©",
        ordf: "ª",
        laquo: "«",
        not: "¬",
        shy: "­",
        reg: "®",
        macr: "¯",
        deg: "°",
        plusmn: "±",
        sup2: "²",
        sup3: "³",
        acute: "´",
        micro: "µ",
        para: "¶",
        middot: "·",
        cedil: "¸",
        sup1: "¹",
        ordm: "º",
        raquo: "»",
        frac14: "¼",
        frac12: "½",
        frac34: "¾",
        iquest: "¿",
        Agrave: "À",
        Aacute: "Á",
        Acirc: "Â",
        Atilde: "Ã",
        Auml: "Ä",
        Aring: "Å",
        AElig: "Æ",
        Ccedil: "Ç",
        Egrave: "È",
        Eacute: "É",
        Ecirc: "Ê",
        Euml: "Ë",
        Igrave: "Ì",
        Iacute: "Í",
        Icirc: "Î",
        Iuml: "Ï",
        ETH: "Ð",
        Ntilde: "Ñ",
        Ograve: "Ò",
        Oacute: "Ó",
        Ocirc: "Ô",
        Otilde: "Õ",
        Ouml: "Ö",
        times: "×",
        Oslash: "Ø",
        Ugrave: "Ù",
        Uacute: "Ú",
        Ucirc: "Û",
        Uuml: "Ü",
        Yacute: "Ý",
        THORN: "Þ",
        szlig: "ß",
        agrave: "à",
        aacute: "á",
        acirc: "â",
        atilde: "ã",
        auml: "ä",
        aring: "å",
        aelig: "æ",
        ccedil: "ç",
        egrave: "è",
        eacute: "é",
        ecirc: "ê",
        euml: "ë",
        igrave: "ì",
        iacute: "í",
        icirc: "î",
        iuml: "ï",
        eth: "ð",
        ntilde: "ñ",
        ograve: "ò",
        oacute: "ó",
        ocirc: "ô",
        otilde: "õ",
        ouml: "ö",
        divide: "÷",
        oslash: "ø",
        ugrave: "ù",
        uacute: "ú",
        ucirc: "û",
        uuml: "ü",
        yacute: "ý",
        thorn: "þ",
        yuml: "ÿ",
        OElig: "Œ",
        oelig: "œ",
        Scaron: "Š",
        scaron: "š",
        Yuml: "Ÿ",
        fnof: "ƒ",
        circ: "ˆ",
        tilde: "˜",
        Alpha: "Α",
        Beta: "Β",
        Gamma: "Γ",
        Delta: "Δ",
        Epsilon: "Ε",
        Zeta: "Ζ",
        Eta: "Η",
        Theta: "Θ",
        Iota: "Ι",
        Kappa: "Κ",
        Lambda: "Λ",
        Mu: "Μ",
        Nu: "Ν",
        Xi: "Ξ",
        Omicron: "Ο",
        Pi: "Π",
        Rho: "Ρ",
        Sigma: "Σ",
        Tau: "Τ",
        Upsilon: "Υ",
        Phi: "Φ",
        Chi: "Χ",
        Psi: "Ψ",
        Omega: "Ω",
        alpha: "α",
        beta: "β",
        gamma: "γ",
        delta: "δ",
        epsilon: "ε",
        zeta: "ζ",
        eta: "η",
        theta: "θ",
        iota: "ι",
        kappa: "κ",
        lambda: "λ",
        mu: "μ",
        nu: "ν",
        xi: "ξ",
        omicron: "ο",
        pi: "π",
        rho: "ρ",
        sigmaf: "ς",
        sigma: "σ",
        tau: "τ",
        upsilon: "υ",
        phi: "φ",
        chi: "χ",
        psi: "ψ",
        omega: "ω",
        thetasym: "ϑ",
        upsih: "ϒ",
        piv: "ϖ",
        ensp: " ",
        emsp: " ",
        thinsp: " ",
        zwnj: "‌",
        zwj: "‍",
        lrm: "‎",
        rlm: "‏",
        ndash: "–",
        mdash: "—",
        lsquo: "‘",
        rsquo: "’",
        sbquo: "‚",
        ldquo: "“",
        rdquo: "”",
        bdquo: "„",
        dagger: "†",
        Dagger: "‡",
        bull: "•",
        hellip: "…",
        permil: "‰",
        prime: "′",
        Prime: "″",
        lsaquo: "‹",
        rsaquo: "›",
        oline: "‾",
        frasl: "⁄",
        euro: "€",
        image: "ℑ",
        weierp: "℘",
        real: "ℜ",
        trade: "™",
        alefsym: "ℵ",
        larr: "←",
        uarr: "↑",
        rarr: "→",
        darr: "↓",
        harr: "↔",
        crarr: "↵",
        lArr: "⇐",
        uArr: "⇑",
        rArr: "⇒",
        dArr: "⇓",
        hArr: "⇔",
        forall: "∀",
        part: "∂",
        exist: "∃",
        empty: "∅",
        nabla: "∇",
        isin: "∈",
        notin: "∉",
        ni: "∋",
        prod: "∏",
        sum: "∑",
        minus: "−",
        lowast: "∗",
        radic: "√",
        prop: "∝",
        infin: "∞",
        ang: "∠",
        and: "∧",
        or: "∨",
        cap: "∩",
        cup: "∪",
        int: "∫",
        there4: "∴",
        sim: "∼",
        cong: "≅",
        asymp: "≈",
        ne: "≠",
        equiv: "≡",
        le: "≤",
        ge: "≥",
        sub: "⊂",
        sup: "⊃",
        nsub: "⊄",
        sube: "⊆",
        supe: "⊇",
        oplus: "⊕",
        otimes: "⊗",
        perp: "⊥",
        sdot: "⋅",
        lceil: "⌈",
        rceil: "⌉",
        lfloor: "⌊",
        rfloor: "⌋",
        loz: "◊",
        spades: "♠",
        clubs: "♣",
        hearts: "♥",
        diams: "♦",
        lang: "⟨",
        rang: "⟩"
      };
    }, function(t, i, s) {
      Object.defineProperty(i, "__esModule", {
        value: !0
      });
      var u = s(10);
      var h = s(12);
      var c = s(13);
      var f = function() {
        function Reader() {
          this.values = [];
          this.curly = this.paren = -1;
        }
        Reader.prototype.beforeFunctionExpression = function(t) {
          return [ "(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "**", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==" ].indexOf(t) >= 0;
        };
        Reader.prototype.isRegexStart = function() {
          var t = this.values[this.values.length - 1];
          var i = null !== t;
          switch (t) {
           case "this":
           case "]":
            i = !1;
            break;

           case ")":
            var s = this.values[this.paren - 1];
            i = "if" === s || "while" === s || "for" === s || "with" === s;
            break;

           case "}":
            i = !1;
            if ("function" === this.values[this.curly - 3]) {
              i = (u = this.values[this.curly - 4]) ? !this.beforeFunctionExpression(u) : !1;
            } else if ("function" === this.values[this.curly - 4]) {
              var u;
              i = (u = this.values[this.curly - 5]) ? !this.beforeFunctionExpression(u) : !0;
            }
          }
          return i;
        };
        Reader.prototype.push = function(t) {
          if (7 === t.type || 4 === t.type) {
            if ("{" === t.value) {
              this.curly = this.values.length;
            } else if ("(" === t.value) {
              this.paren = this.values.length;
            }
            this.values.push(t.value);
          } else {
            this.values.push(null);
          }
        };
        return Reader;
      }();
      var p = function() {
        function Tokenizer(t, i) {
          this.errorHandler = new u.ErrorHandler;
          this.errorHandler.tolerant = i ? "boolean" == typeof i.tolerant && i.tolerant : !1;
          this.scanner = new h.Scanner(t, this.errorHandler);
          this.scanner.trackComment = i ? "boolean" == typeof i.comment && i.comment : !1;
          this.trackRange = i ? "boolean" == typeof i.range && i.range : !1;
          this.trackLoc = i ? "boolean" == typeof i.loc && i.loc : !1;
          this.buffer = [];
          this.reader = new f;
        }
        Tokenizer.prototype.errors = function() {
          return this.errorHandler.errors;
        };
        Tokenizer.prototype.getNextToken = function() {
          if (0 === this.buffer.length) {
            var t = this.scanner.scanComments();
            if (this.scanner.trackComment) {
              for (var i = 0; i < t.length; ++i) {
                var s = t[i];
                var u = this.scanner.source.slice(s.slice[0], s.slice[1]);
                var h = {
                  type: s.multiLine ? "BlockComment" : "LineComment",
                  value: u
                };
                if (this.trackRange) {
                  h.range = s.range;
                }
                if (this.trackLoc) {
                  h.loc = s.loc;
                }
                this.buffer.push(h);
              }
            }
            if (!this.scanner.eof()) {
              var f = void 0;
              if (this.trackLoc) {
                f = {
                  start: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  },
                  end: {}
                };
              }
              var p = "/" === this.scanner.source[this.scanner.index] && this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.lex();
              this.reader.push(p);
              var m = {
                type: c.TokenName[p.type],
                value: this.scanner.source.slice(p.start, p.end)
              };
              if (this.trackRange) {
                m.range = [ p.start, p.end ];
              }
              if (this.trackLoc) {
                f.end = {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
                m.loc = f;
              }
              if (9 === p.type) {
                m.regex = {
                  pattern: p.pattern,
                  flags: p.flags
                };
              }
              this.buffer.push(m);
            }
          }
          return this.buffer.shift();
        };
        return Tokenizer;
      }();
      i.Tokenizer = p;
    } ]);
  }));
}(p);

var m = p.exports;

var x = {};

var v = {};

var D = {};

D.byteLength = function byteLength(t) {
  var i = getLens(t);
  var s = i[1];
  return 3 * (i[0] + s) / 4 - s;
};

D.toByteArray = function toByteArray(t) {
  var i;
  var s = getLens(t);
  var u = s[0];
  var h = s[1];
  var c = new S(function _byteLength(t, i, s) {
    return 3 * (i + s) / 4 - s;
  }(0, u, h));
  var f = 0;
  var p = h > 0 ? u - 4 : u;
  var m;
  for (m = 0; m < p; m += 4) {
    i = g[t.charCodeAt(m)] << 18 | g[t.charCodeAt(m + 1)] << 12 | g[t.charCodeAt(m + 2)] << 6 | g[t.charCodeAt(m + 3)];
    c[f++] = i >> 16 & 255;
    c[f++] = i >> 8 & 255;
    c[f++] = 255 & i;
  }
  if (2 === h) {
    i = g[t.charCodeAt(m)] << 2 | g[t.charCodeAt(m + 1)] >> 4;
    c[f++] = 255 & i;
  }
  if (1 === h) {
    i = g[t.charCodeAt(m)] << 10 | g[t.charCodeAt(m + 1)] << 4 | g[t.charCodeAt(m + 2)] >> 2;
    c[f++] = i >> 8 & 255;
    c[f++] = 255 & i;
  }
  return c;
};

D.fromByteArray = function fromByteArray(t) {
  var i;
  var s = t.length;
  var u = s % 3;
  var h = [];
  var c = 16383;
  for (var f = 0, p = s - u; f < p; f += c) {
    h.push(encodeChunk(t, f, f + c > p ? p : f + c));
  }
  if (1 === u) {
    h.push(y[(i = t[s - 1]) >> 2] + y[i << 4 & 63] + "==");
  } else if (2 === u) {
    h.push(y[(i = (t[s - 2] << 8) + t[s - 1]) >> 10] + y[i >> 4 & 63] + y[i << 2 & 63] + "=");
  }
  return h.join("");
};

var y = [];

var g = [];

var S = "undefined" != typeof Uint8Array ? Uint8Array : Array;

var C = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

for (var A = 0; A < 64; ++A) {
  y[A] = C[A];
  g[C.charCodeAt(A)] = A;
}

g["-".charCodeAt(0)] = 62;

g["_".charCodeAt(0)] = 63;

function getLens(t) {
  var i = t.length;
  if (i % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var s = t.indexOf("=");
  if (-1 === s) {
    s = i;
  }
  return [ s, s === i ? 0 : 4 - s % 4 ];
}

function encodeChunk(t, i, s) {
  var u = [];
  for (var h = i; h < s; h += 3) {
    u.push(y[(c = (t[h] << 16 & 16711680) + (t[h + 1] << 8 & 65280) + (255 & t[h + 2])) >> 18 & 63] + y[c >> 12 & 63] + y[c >> 6 & 63] + y[63 & c]);
  }
  var c;
  return u.join("");
}

var w = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ w.read = function(t, i, s, u, h) {
  var c, f;
  var p = 8 * h - u - 1;
  var m = (1 << p) - 1;
  var x = m >> 1;
  var v = -7;
  var D = s ? h - 1 : 0;
  var y = s ? -1 : 1;
  var g = t[i + D];
  D += y;
  c = g & (1 << -v) - 1;
  g >>= -v;
  v += p;
  for (;v > 0; c = 256 * c + t[i + D], D += y, v -= 8) {}
  f = c & (1 << -v) - 1;
  c >>= -v;
  v += u;
  for (;v > 0; f = 256 * f + t[i + D], D += y, v -= 8) {}
  if (0 === c) {
    c = 1 - x;
  } else if (c === m) {
    return f ? NaN : 1 / 0 * (g ? -1 : 1);
  } else {
    f += Math.pow(2, u);
    c -= x;
  }
  return (g ? -1 : 1) * f * Math.pow(2, c - u);
};

w.write = function(t, i, s, u, h, c) {
  var f, p, m;
  var x = 8 * c - h - 1;
  var v = (1 << x) - 1;
  var D = v >> 1;
  var y = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var g = u ? 0 : c - 1;
  var S = u ? 1 : -1;
  var C = i < 0 || 0 === i && 1 / i < 0 ? 1 : 0;
  i = Math.abs(i);
  if (isNaN(i) || i === 1 / 0) {
    p = isNaN(i) ? 1 : 0;
    f = v;
  } else {
    f = Math.floor(Math.log(i) / Math.LN2);
    if (i * (m = Math.pow(2, -f)) < 1) {
      f--;
      m *= 2;
    }
    if (f + D >= 1) {
      i += y / m;
    } else {
      i += y * Math.pow(2, 1 - D);
    }
    if (i * m >= 2) {
      f++;
      m /= 2;
    }
    if (f + D >= v) {
      p = 0;
      f = v;
    } else if (f + D >= 1) {
      p = (i * m - 1) * Math.pow(2, h);
      f += D;
    } else {
      p = i * Math.pow(2, D - 1) * Math.pow(2, h);
      f = 0;
    }
  }
  for (;h >= 8; t[s + g] = 255 & p, g += S, p /= 256, h -= 8) {}
  f = f << h | p;
  x += h;
  for (;x > 0; t[s + g] = 255 & f, g += S, f /= 256, x -= 8) {}
  t[s + g - S] |= 128 * C;
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ !function(t) {
  var i = D;
  var s = w;
  var u = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = Buffer;
  t.SlowBuffer = function SlowBuffer(t) {
    if (+t != t) {
      t = 0;
    }
    return Buffer.alloc(+t);
  };
  t.INSPECT_MAX_BYTES = 50;
  var h = 2147483647;
  t.kMaxLength = h;
  if (!(Buffer.TYPED_ARRAY_SUPPORT = function typedArraySupport() {
    try {
      var t = new Uint8Array(1);
      var i = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(i, Uint8Array.prototype);
      Object.setPrototypeOf(t, i);
      return 42 === t.foo();
    } catch (t) {
      return !1;
    }
  }()) && "undefined" != typeof console && "function" == typeof console.error) {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (!Buffer.isBuffer(this)) {
        return;
      }
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (!Buffer.isBuffer(this)) {
        return;
      }
      return this.byteOffset;
    }
  });
  function createBuffer(t) {
    if (t > h) {
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    var i = new Uint8Array(t);
    Object.setPrototypeOf(i, Buffer.prototype);
    return i;
  }
  function Buffer(t, i, s) {
    if ("number" == typeof t) {
      if ("string" == typeof i) {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(t);
    }
    return from(t, i, s);
  }
  Buffer.poolSize = 8192;
  function from(t, i, s) {
    if ("string" == typeof t) {
      return function fromString(t, i) {
        if ("string" != typeof i || "" === i) {
          i = "utf8";
        }
        if (!Buffer.isEncoding(i)) {
          throw new TypeError("Unknown encoding: " + i);
        }
        var s = 0 | byteLength(t, i);
        var u = createBuffer(s);
        var h = u.write(t, i);
        if (h !== s) {
          u = u.slice(0, h);
        }
        return u;
      }(t, i);
    }
    if (ArrayBuffer.isView(t)) {
      return function fromArrayView(t) {
        if (isInstance(t, Uint8Array)) {
          var i = new Uint8Array(t);
          return fromArrayBuffer(i.buffer, i.byteOffset, i.byteLength);
        }
        return fromArrayLike(t);
      }(t);
    }
    if (null == t) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    if (isInstance(t, ArrayBuffer) || t && isInstance(t.buffer, ArrayBuffer)) {
      return fromArrayBuffer(t, i, s);
    }
    if ("undefined" != typeof SharedArrayBuffer && (isInstance(t, SharedArrayBuffer) || t && isInstance(t.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(t, i, s);
    }
    if ("number" == typeof t) {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var u = t.valueOf && t.valueOf();
    if (null != u && u !== t) {
      return Buffer.from(u, i, s);
    }
    var h = function fromObject(t) {
      if (Buffer.isBuffer(t)) {
        var i = 0 | checked(t.length);
        var s = createBuffer(i);
        if (0 === s.length) {
          return s;
        }
        t.copy(s, 0, 0, i);
        return s;
      }
      if (void 0 !== t.length) {
        if ("number" != typeof t.length || numberIsNaN(t.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(t);
      }
      if ("Buffer" === t.type && Array.isArray(t.data)) {
        return fromArrayLike(t.data);
      }
    }(t);
    if (h) {
      return h;
    }
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) {
      return Buffer.from(t[Symbol.toPrimitive]("string"), i, s);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
  }
  Buffer.from = function(t, i, s) {
    return from(t, i, s);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(t) {
    if ("number" != typeof t) {
      throw new TypeError('"size" argument must be of type number');
    } else if (t < 0) {
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
  }
  Buffer.alloc = function(t, i, s) {
    return function alloc(t, i, s) {
      assertSize(t);
      if (t <= 0) {
        return createBuffer(t);
      }
      if (void 0 !== i) {
        return "string" == typeof s ? createBuffer(t).fill(i, s) : createBuffer(t).fill(i);
      }
      return createBuffer(t);
    }(t, i, s);
  };
  function allocUnsafe(t) {
    assertSize(t);
    return createBuffer(t < 0 ? 0 : 0 | checked(t));
  }
  Buffer.allocUnsafe = function(t) {
    return allocUnsafe(t);
  };
  Buffer.allocUnsafeSlow = function(t) {
    return allocUnsafe(t);
  };
  function fromArrayLike(t) {
    var i = t.length < 0 ? 0 : 0 | checked(t.length);
    var s = createBuffer(i);
    for (var u = 0; u < i; u += 1) {
      s[u] = 255 & t[u];
    }
    return s;
  }
  function fromArrayBuffer(t, i, s) {
    if (i < 0 || t.byteLength < i) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (t.byteLength < i + (s || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var u;
    if (void 0 === i && void 0 === s) {
      u = new Uint8Array(t);
    } else if (void 0 === s) {
      u = new Uint8Array(t, i);
    } else {
      u = new Uint8Array(t, i, s);
    }
    Object.setPrototypeOf(u, Buffer.prototype);
    return u;
  }
  function checked(t) {
    if (t >= h) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
    }
    return 0 | t;
  }
  Buffer.isBuffer = function isBuffer(t) {
    return null != t && !0 === t._isBuffer && t !== Buffer.prototype;
  };
  Buffer.compare = function compare(t, i) {
    if (isInstance(t, Uint8Array)) {
      t = Buffer.from(t, t.offset, t.byteLength);
    }
    if (isInstance(i, Uint8Array)) {
      i = Buffer.from(i, i.offset, i.byteLength);
    }
    if (!Buffer.isBuffer(t) || !Buffer.isBuffer(i)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (t === i) {
      return 0;
    }
    var s = t.length;
    var u = i.length;
    for (var h = 0, c = Math.min(s, u); h < c; ++h) {
      if (t[h] !== i[h]) {
        s = t[h];
        u = i[h];
        break;
      }
    }
    if (s < u) {
      return -1;
    }
    if (u < s) {
      return 1;
    }
    return 0;
  };
  Buffer.isEncoding = function isEncoding(t) {
    switch (String(t).toLowerCase()) {
     case "hex":
     case "utf8":
     case "utf-8":
     case "ascii":
     case "latin1":
     case "binary":
     case "base64":
     case "ucs2":
     case "ucs-2":
     case "utf16le":
     case "utf-16le":
      return !0;

     default:
      return !1;
    }
  };
  Buffer.concat = function concat(t, i) {
    if (!Array.isArray(t)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (0 === t.length) {
      return Buffer.alloc(0);
    }
    var s;
    if (void 0 === i) {
      i = 0;
      for (s = 0; s < t.length; ++s) {
        i += t[s].length;
      }
    }
    var u = Buffer.allocUnsafe(i);
    var h = 0;
    for (s = 0; s < t.length; ++s) {
      var c = t[s];
      if (isInstance(c, Uint8Array)) {
        if (h + c.length > u.length) {
          if (!Buffer.isBuffer(c)) {
            c = Buffer.from(c);
          }
          c.copy(u, h);
        } else {
          Uint8Array.prototype.set.call(u, c, h);
        }
      } else if (!Buffer.isBuffer(c)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        c.copy(u, h);
      }
      h += c.length;
    }
    return u;
  };
  function byteLength(t, i) {
    if (Buffer.isBuffer(t)) {
      return t.length;
    }
    if (ArrayBuffer.isView(t) || isInstance(t, ArrayBuffer)) {
      return t.byteLength;
    }
    if ("string" != typeof t) {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
    }
    var s = t.length;
    var u = arguments.length > 2 && !0 === arguments[2];
    if (!u && 0 === s) {
      return 0;
    }
    var h = !1;
    for (;;) {
      switch (i) {
       case "ascii":
       case "latin1":
       case "binary":
        return s;

       case "utf8":
       case "utf-8":
        return utf8ToBytes(t).length;

       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return 2 * s;

       case "hex":
        return s >>> 1;

       case "base64":
        return base64ToBytes(t).length;

       default:
        if (h) {
          return u ? -1 : utf8ToBytes(t).length;
        }
        i = ("" + i).toLowerCase();
        h = !0;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(t, i, s) {
    var u = !1;
    if (void 0 === i || i < 0) {
      i = 0;
    }
    if (i > this.length) {
      return "";
    }
    if (void 0 === s || s > this.length) {
      s = this.length;
    }
    if (s <= 0) {
      return "";
    }
    if ((s >>>= 0) <= (i >>>= 0)) {
      return "";
    }
    if (!t) {
      t = "utf8";
    }
    while (1) {
      switch (t) {
       case "hex":
        return hexSlice(this, i, s);

       case "utf8":
       case "utf-8":
        return utf8Slice(this, i, s);

       case "ascii":
        return asciiSlice(this, i, s);

       case "latin1":
       case "binary":
        return latin1Slice(this, i, s);

       case "base64":
        return base64Slice(this, i, s);

       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return utf16leSlice(this, i, s);

       default:
        if (u) {
          throw new TypeError("Unknown encoding: " + t);
        }
        t = (t + "").toLowerCase();
        u = !0;
      }
    }
  }
  Buffer.prototype._isBuffer = !0;
  function swap(t, i, s) {
    var u = t[i];
    t[i] = t[s];
    t[s] = u;
  }
  Buffer.prototype.swap16 = function swap16() {
    var t = this.length;
    if (t % 2 != 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < t; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    var t = this.length;
    if (t % 4 != 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < t; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    var t = this.length;
    if (t % 8 != 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < t; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString() {
    var t = this.length;
    if (0 === t) {
      return "";
    }
    if (0 === arguments.length) {
      return utf8Slice(this, 0, t);
    }
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(t) {
    if (!Buffer.isBuffer(t)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (this === t) {
      return !0;
    }
    return 0 === Buffer.compare(this, t);
  };
  Buffer.prototype.inspect = function inspect() {
    var i = "";
    var s = t.INSPECT_MAX_BYTES;
    i = this.toString("hex", 0, s).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > s) {
      i += " ... ";
    }
    return "<Buffer " + i + ">";
  };
  if (u) {
    Buffer.prototype[u] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(t, i, s, u, h) {
    if (isInstance(t, Uint8Array)) {
      t = Buffer.from(t, t.offset, t.byteLength);
    }
    if (!Buffer.isBuffer(t)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
    }
    if (void 0 === i) {
      i = 0;
    }
    if (void 0 === s) {
      s = t ? t.length : 0;
    }
    if (void 0 === u) {
      u = 0;
    }
    if (void 0 === h) {
      h = this.length;
    }
    if (i < 0 || s > t.length || u < 0 || h > this.length) {
      throw new RangeError("out of range index");
    }
    if (u >= h && i >= s) {
      return 0;
    }
    if (u >= h) {
      return -1;
    }
    if (i >= s) {
      return 1;
    }
    if (this === t) {
      return 0;
    }
    var c = (h >>>= 0) - (u >>>= 0);
    var f = (s >>>= 0) - (i >>>= 0);
    var p = Math.min(c, f);
    var m = this.slice(u, h);
    var x = t.slice(i, s);
    for (var v = 0; v < p; ++v) {
      if (m[v] !== x[v]) {
        c = m[v];
        f = x[v];
        break;
      }
    }
    if (c < f) {
      return -1;
    }
    if (f < c) {
      return 1;
    }
    return 0;
  };
  function bidirectionalIndexOf(t, i, s, u, h) {
    if (0 === t.length) {
      return -1;
    }
    if ("string" == typeof s) {
      u = s;
      s = 0;
    } else if (s > 2147483647) {
      s = 2147483647;
    } else if (s < -2147483648) {
      s = -2147483648;
    }
    if (numberIsNaN(s = +s)) {
      s = h ? 0 : t.length - 1;
    }
    if (s < 0) {
      s = t.length + s;
    }
    if (s >= t.length) {
      if (h) {
        return -1;
      } else {
        s = t.length - 1;
      }
    } else if (s < 0) {
      if (h) {
        s = 0;
      } else {
        return -1;
      }
    }
    if ("string" == typeof i) {
      i = Buffer.from(i, u);
    }
    if (Buffer.isBuffer(i)) {
      if (0 === i.length) {
        return -1;
      }
      return arrayIndexOf(t, i, s, u, h);
    } else if ("number" == typeof i) {
      i &= 255;
      if ("function" == typeof Uint8Array.prototype.indexOf) {
        if (h) {
          return Uint8Array.prototype.indexOf.call(t, i, s);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(t, i, s);
        }
      }
      return arrayIndexOf(t, [ i ], s, u, h);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(t, i, s, u, h) {
    var c = 1;
    var f = t.length;
    var p = i.length;
    if (void 0 !== u) {
      if ("ucs2" === (u = String(u).toLowerCase()) || "ucs-2" === u || "utf16le" === u || "utf-16le" === u) {
        if (t.length < 2 || i.length < 2) {
          return -1;
        }
        c = 2;
        f /= 2;
        p /= 2;
        s /= 2;
      }
    }
    function read(t, i) {
      if (1 === c) {
        return t[i];
      } else {
        return t.readUInt16BE(i * c);
      }
    }
    var m;
    if (h) {
      var x = -1;
      for (m = s; m < f; m++) {
        if (read(t, m) === read(i, -1 === x ? 0 : m - x)) {
          if (-1 === x) {
            x = m;
          }
          if (m - x + 1 === p) {
            return x * c;
          }
        } else {
          if (-1 !== x) {
            m -= m - x;
          }
          x = -1;
        }
      }
    } else {
      if (s + p > f) {
        s = f - p;
      }
      for (m = s; m >= 0; m--) {
        var v = !0;
        for (var D = 0; D < p; D++) {
          if (read(t, m + D) !== read(i, D)) {
            v = !1;
            break;
          }
        }
        if (v) {
          return m;
        }
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(t, i, s) {
    return -1 !== this.indexOf(t, i, s);
  };
  Buffer.prototype.indexOf = function indexOf(t, i, s) {
    return bidirectionalIndexOf(this, t, i, s, !0);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(t, i, s) {
    return bidirectionalIndexOf(this, t, i, s, !1);
  };
  function hexWrite(t, i, s, u) {
    s = Number(s) || 0;
    var h = t.length - s;
    if (!u) {
      u = h;
    } else if ((u = Number(u)) > h) {
      u = h;
    }
    var c = i.length;
    if (u > c / 2) {
      u = c / 2;
    }
    var f;
    for (f = 0; f < u; ++f) {
      var p = parseInt(i.substr(2 * f, 2), 16);
      if (numberIsNaN(p)) {
        return f;
      }
      t[s + f] = p;
    }
    return f;
  }
  function utf8Write(t, i, s, u) {
    return blitBuffer(utf8ToBytes(i, t.length - s), t, s, u);
  }
  function asciiWrite(t, i, s, u) {
    return blitBuffer(function asciiToBytes(t) {
      var i = [];
      for (var s = 0; s < t.length; ++s) {
        i.push(255 & t.charCodeAt(s));
      }
      return i;
    }(i), t, s, u);
  }
  function base64Write(t, i, s, u) {
    return blitBuffer(base64ToBytes(i), t, s, u);
  }
  function ucs2Write(t, i, s, u) {
    return blitBuffer(function utf16leToBytes(t, i) {
      var s, u;
      var h = [];
      for (var c = 0; c < t.length; ++c) {
        if ((i -= 2) < 0) {
          break;
        }
        u = (s = t.charCodeAt(c)) >> 8;
        h.push(s % 256);
        h.push(u);
      }
      return h;
    }(i, t.length - s), t, s, u);
  }
  Buffer.prototype.write = function write(t, i, s, u) {
    if (void 0 === i) {
      u = "utf8";
      s = this.length;
      i = 0;
    } else if (void 0 === s && "string" == typeof i) {
      u = i;
      s = this.length;
      i = 0;
    } else if (isFinite(i)) {
      i >>>= 0;
      if (isFinite(s)) {
        s >>>= 0;
        if (void 0 === u) {
          u = "utf8";
        }
      } else {
        u = s;
        s = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var h = this.length - i;
    if (void 0 === s || s > h) {
      s = h;
    }
    if (t.length > 0 && (s < 0 || i < 0) || i > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!u) {
      u = "utf8";
    }
    var c = !1;
    for (;;) {
      switch (u) {
       case "hex":
        return hexWrite(this, t, i, s);

       case "utf8":
       case "utf-8":
        return utf8Write(this, t, i, s);

       case "ascii":
       case "latin1":
       case "binary":
        return asciiWrite(this, t, i, s);

       case "base64":
        return base64Write(this, t, i, s);

       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return ucs2Write(this, t, i, s);

       default:
        if (c) {
          throw new TypeError("Unknown encoding: " + u);
        }
        u = ("" + u).toLowerCase();
        c = !0;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(t, s, u) {
    if (0 === s && u === t.length) {
      return i.fromByteArray(t);
    } else {
      return i.fromByteArray(t.slice(s, u));
    }
  }
  function utf8Slice(t, i, s) {
    s = Math.min(t.length, s);
    var u = [];
    var h = i;
    while (h < s) {
      var f = t[h];
      var p = null;
      var m = f > 239 ? 4 : f > 223 ? 3 : f > 191 ? 2 : 1;
      if (h + m <= s) {
        var x = void 0, v = void 0, D = void 0, y = void 0;
        switch (m) {
         case 1:
          if (f < 128) {
            p = f;
          }
          break;

         case 2:
          if (128 == (192 & (x = t[h + 1]))) {
            if ((y = (31 & f) << 6 | 63 & x) > 127) {
              p = y;
            }
          }
          break;

         case 3:
          v = t[h + 2];
          if (128 == (192 & (x = t[h + 1])) && 128 == (192 & v)) {
            if ((y = (15 & f) << 12 | (63 & x) << 6 | 63 & v) > 2047 && (y < 55296 || y > 57343)) {
              p = y;
            }
          }
          break;

         case 4:
          v = t[h + 2];
          D = t[h + 3];
          if (128 == (192 & (x = t[h + 1])) && 128 == (192 & v) && 128 == (192 & D)) {
            if ((y = (15 & f) << 18 | (63 & x) << 12 | (63 & v) << 6 | 63 & D) > 65535 && y < 1114112) {
              p = y;
            }
          }
        }
      }
      if (null === p) {
        p = 65533;
        m = 1;
      } else if (p > 65535) {
        u.push((p -= 65536) >>> 10 & 1023 | 55296);
        p = 56320 | 1023 & p;
      }
      u.push(p);
      h += m;
    }
    return function decodeCodePointsArray(t) {
      var i = t.length;
      if (i <= c) {
        return String.fromCharCode.apply(String, t);
      }
      var s = "";
      var u = 0;
      while (u < i) {
        s += String.fromCharCode.apply(String, t.slice(u, u += c));
      }
      return s;
    }(u);
  }
  var c = 4096;
  function asciiSlice(t, i, s) {
    var u = "";
    s = Math.min(t.length, s);
    for (var h = i; h < s; ++h) {
      u += String.fromCharCode(127 & t[h]);
    }
    return u;
  }
  function latin1Slice(t, i, s) {
    var u = "";
    s = Math.min(t.length, s);
    for (var h = i; h < s; ++h) {
      u += String.fromCharCode(t[h]);
    }
    return u;
  }
  function hexSlice(t, i, s) {
    var u = t.length;
    if (!i || i < 0) {
      i = 0;
    }
    if (!s || s < 0 || s > u) {
      s = u;
    }
    var h = "";
    for (var c = i; c < s; ++c) {
      h += m[t[c]];
    }
    return h;
  }
  function utf16leSlice(t, i, s) {
    var u = t.slice(i, s);
    var h = "";
    for (var c = 0; c < u.length - 1; c += 2) {
      h += String.fromCharCode(u[c] + 256 * u[c + 1]);
    }
    return h;
  }
  Buffer.prototype.slice = function slice(t, i) {
    var s = this.length;
    if ((t = ~~t) < 0) {
      if ((t += s) < 0) {
        t = 0;
      }
    } else if (t > s) {
      t = s;
    }
    if ((i = void 0 === i ? s : ~~i) < 0) {
      if ((i += s) < 0) {
        i = 0;
      }
    } else if (i > s) {
      i = s;
    }
    if (i < t) {
      i = t;
    }
    var u = this.subarray(t, i);
    Object.setPrototypeOf(u, Buffer.prototype);
    return u;
  };
  function checkOffset(t, i, s) {
    if (t % 1 != 0 || t < 0) {
      throw new RangeError("offset is not uint");
    }
    if (t + i > s) {
      throw new RangeError("Trying to access beyond buffer length");
    }
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(t, i, s) {
    t >>>= 0;
    i >>>= 0;
    if (!s) {
      checkOffset(t, i, this.length);
    }
    var u = this[t];
    var h = 1;
    var c = 0;
    while (++c < i && (h *= 256)) {
      u += this[t + c] * h;
    }
    return u;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(t, i, s) {
    t >>>= 0;
    i >>>= 0;
    if (!s) {
      checkOffset(t, i, this.length);
    }
    var u = this[t + --i];
    var h = 1;
    while (i > 0 && (h *= 256)) {
      u += this[t + --i] * h;
    }
    return u;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 1, this.length);
    }
    return this[t];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 2, this.length);
    }
    return this[t] | this[t + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 2, this.length);
    }
    return this[t] << 8 | this[t + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 4, this.length);
    }
    return (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 4, this.length);
    }
    return 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
  };
  Buffer.prototype.readBigUInt64LE = defineBigIntMethod((function readBigUInt64LE(t) {
    validateNumber(t >>>= 0, "offset");
    var i = this[t];
    var s = this[t + 7];
    if (void 0 === i || void 0 === s) {
      boundsError(t, this.length - 8);
    }
    var u = i + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24;
    var h = this[++t] + 256 * this[++t] + 65536 * this[++t] + s * 2 ** 24;
    return BigInt(u) + (BigInt(h) << BigInt(32));
  }));
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod((function readBigUInt64BE(t) {
    validateNumber(t >>>= 0, "offset");
    var i = this[t];
    var s = this[t + 7];
    if (void 0 === i || void 0 === s) {
      boundsError(t, this.length - 8);
    }
    var u = i * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t];
    var h = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + s;
    return (BigInt(u) << BigInt(32)) + BigInt(h);
  }));
  Buffer.prototype.readIntLE = function readIntLE(t, i, s) {
    t >>>= 0;
    i >>>= 0;
    if (!s) {
      checkOffset(t, i, this.length);
    }
    var u = this[t];
    var h = 1;
    var c = 0;
    while (++c < i && (h *= 256)) {
      u += this[t + c] * h;
    }
    if (u >= (h *= 128)) {
      u -= Math.pow(2, 8 * i);
    }
    return u;
  };
  Buffer.prototype.readIntBE = function readIntBE(t, i, s) {
    t >>>= 0;
    i >>>= 0;
    if (!s) {
      checkOffset(t, i, this.length);
    }
    var u = i;
    var h = 1;
    var c = this[t + --u];
    while (u > 0 && (h *= 256)) {
      c += this[t + --u] * h;
    }
    if (c >= (h *= 128)) {
      c -= Math.pow(2, 8 * i);
    }
    return c;
  };
  Buffer.prototype.readInt8 = function readInt8(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 1, this.length);
    }
    if (!(128 & this[t])) {
      return this[t];
    }
    return -1 * (255 - this[t] + 1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 2, this.length);
    }
    var s = this[t] | this[t + 1] << 8;
    return 32768 & s ? 4294901760 | s : s;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 2, this.length);
    }
    var s = this[t + 1] | this[t] << 8;
    return 32768 & s ? 4294901760 | s : s;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 4, this.length);
    }
    return this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 4, this.length);
    }
    return this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
  };
  Buffer.prototype.readBigInt64LE = defineBigIntMethod((function readBigInt64LE(t) {
    validateNumber(t >>>= 0, "offset");
    var i = this[t];
    var s = this[t + 7];
    if (void 0 === i || void 0 === s) {
      boundsError(t, this.length - 8);
    }
    return (BigInt(this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (s << 24)) << BigInt(32)) + BigInt(i + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24);
  }));
  Buffer.prototype.readBigInt64BE = defineBigIntMethod((function readBigInt64BE(t) {
    validateNumber(t >>>= 0, "offset");
    var i = this[t];
    var s = this[t + 7];
    if (void 0 === i || void 0 === s) {
      boundsError(t, this.length - 8);
    }
    var u = (i << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
    return (BigInt(u) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + s);
  }));
  Buffer.prototype.readFloatLE = function readFloatLE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 4, this.length);
    }
    return s.read(this, t, !0, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 4, this.length);
    }
    return s.read(this, t, !1, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 8, this.length);
    }
    return s.read(this, t, !0, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(t, i) {
    t >>>= 0;
    if (!i) {
      checkOffset(t, 8, this.length);
    }
    return s.read(this, t, !1, 52, 8);
  };
  function checkInt(t, i, s, u, h, c) {
    if (!Buffer.isBuffer(t)) {
      throw new TypeError('"buffer" argument must be a Buffer instance');
    }
    if (i > h || i < c) {
      throw new RangeError('"value" argument is out of bounds');
    }
    if (s + u > t.length) {
      throw new RangeError("Index out of range");
    }
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(t, i, s, u) {
    t = +t;
    i >>>= 0;
    s >>>= 0;
    if (!u) {
      checkInt(this, t, i, s, Math.pow(2, 8 * s) - 1, 0);
    }
    var h = 1;
    var c = 0;
    this[i] = 255 & t;
    while (++c < s && (h *= 256)) {
      this[i + c] = t / h & 255;
    }
    return i + s;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(t, i, s, u) {
    t = +t;
    i >>>= 0;
    s >>>= 0;
    if (!u) {
      checkInt(this, t, i, s, Math.pow(2, 8 * s) - 1, 0);
    }
    var h = s - 1;
    var c = 1;
    this[i + h] = 255 & t;
    while (--h >= 0 && (c *= 256)) {
      this[i + h] = t / c & 255;
    }
    return i + s;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 1, 255, 0);
    }
    this[i] = 255 & t;
    return i + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 2, 65535, 0);
    }
    this[i] = 255 & t;
    this[i + 1] = t >>> 8;
    return i + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 2, 65535, 0);
    }
    this[i] = t >>> 8;
    this[i + 1] = 255 & t;
    return i + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 4, 4294967295, 0);
    }
    this[i + 3] = t >>> 24;
    this[i + 2] = t >>> 16;
    this[i + 1] = t >>> 8;
    this[i] = 255 & t;
    return i + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 4, 4294967295, 0);
    }
    this[i] = t >>> 24;
    this[i + 1] = t >>> 16;
    this[i + 2] = t >>> 8;
    this[i + 3] = 255 & t;
    return i + 4;
  };
  function wrtBigUInt64LE(t, i, s, u, h) {
    checkIntBI(i, u, h, t, s, 7);
    var c = Number(i & BigInt(4294967295));
    t[s++] = c;
    t[s++] = c >>= 8;
    t[s++] = c >>= 8;
    t[s++] = c >>= 8;
    var f = Number(i >> BigInt(32) & BigInt(4294967295));
    t[s++] = f;
    t[s++] = f >>= 8;
    t[s++] = f >>= 8;
    t[s++] = f >>= 8;
    return s;
  }
  function wrtBigUInt64BE(t, i, s, u, h) {
    checkIntBI(i, u, h, t, s, 7);
    var c = Number(i & BigInt(4294967295));
    t[s + 7] = c;
    t[s + 6] = c >>= 8;
    t[s + 5] = c >>= 8;
    t[s + 4] = c >>= 8;
    var f = Number(i >> BigInt(32) & BigInt(4294967295));
    t[s + 3] = f;
    t[s + 2] = f >>= 8;
    t[s + 1] = f >>= 8;
    t[s] = f >>= 8;
    return s + 8;
  }
  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod((function writeBigUInt64LE(t, i = 0) {
    return wrtBigUInt64LE(this, t, i, BigInt(0), BigInt("0xffffffffffffffff"));
  }));
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod((function writeBigUInt64BE(t, i = 0) {
    return wrtBigUInt64BE(this, t, i, BigInt(0), BigInt("0xffffffffffffffff"));
  }));
  Buffer.prototype.writeIntLE = function writeIntLE(t, i, s, u) {
    t = +t;
    i >>>= 0;
    if (!u) {
      var h = Math.pow(2, 8 * s - 1);
      checkInt(this, t, i, s, h - 1, -h);
    }
    var c = 0;
    var f = 1;
    var p = 0;
    this[i] = 255 & t;
    while (++c < s && (f *= 256)) {
      if (t < 0 && 0 === p && 0 !== this[i + c - 1]) {
        p = 1;
      }
      this[i + c] = (t / f >> 0) - p & 255;
    }
    return i + s;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(t, i, s, u) {
    t = +t;
    i >>>= 0;
    if (!u) {
      var h = Math.pow(2, 8 * s - 1);
      checkInt(this, t, i, s, h - 1, -h);
    }
    var c = s - 1;
    var f = 1;
    var p = 0;
    this[i + c] = 255 & t;
    while (--c >= 0 && (f *= 256)) {
      if (t < 0 && 0 === p && 0 !== this[i + c + 1]) {
        p = 1;
      }
      this[i + c] = (t / f >> 0) - p & 255;
    }
    return i + s;
  };
  Buffer.prototype.writeInt8 = function writeInt8(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 1, 127, -128);
    }
    if (t < 0) {
      t = 255 + t + 1;
    }
    this[i] = 255 & t;
    return i + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 2, 32767, -32768);
    }
    this[i] = 255 & t;
    this[i + 1] = t >>> 8;
    return i + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 2, 32767, -32768);
    }
    this[i] = t >>> 8;
    this[i + 1] = 255 & t;
    return i + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 4, 2147483647, -2147483648);
    }
    this[i] = 255 & t;
    this[i + 1] = t >>> 8;
    this[i + 2] = t >>> 16;
    this[i + 3] = t >>> 24;
    return i + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(t, i, s) {
    t = +t;
    i >>>= 0;
    if (!s) {
      checkInt(this, t, i, 4, 2147483647, -2147483648);
    }
    if (t < 0) {
      t = 4294967295 + t + 1;
    }
    this[i] = t >>> 24;
    this[i + 1] = t >>> 16;
    this[i + 2] = t >>> 8;
    this[i + 3] = 255 & t;
    return i + 4;
  };
  Buffer.prototype.writeBigInt64LE = defineBigIntMethod((function writeBigInt64LE(t, i = 0) {
    return wrtBigUInt64LE(this, t, i, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }));
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod((function writeBigInt64BE(t, i = 0) {
    return wrtBigUInt64BE(this, t, i, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }));
  function checkIEEE754(t, i, s, u, h, c) {
    if (s + u > t.length) {
      throw new RangeError("Index out of range");
    }
    if (s < 0) {
      throw new RangeError("Index out of range");
    }
  }
  function writeFloat(t, i, u, h, c) {
    i = +i;
    u >>>= 0;
    if (!c) {
      checkIEEE754(t, 0, u, 4);
    }
    s.write(t, i, u, h, 23, 4);
    return u + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(t, i, s) {
    return writeFloat(this, t, i, !0, s);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(t, i, s) {
    return writeFloat(this, t, i, !1, s);
  };
  function writeDouble(t, i, u, h, c) {
    i = +i;
    u >>>= 0;
    if (!c) {
      checkIEEE754(t, 0, u, 8);
    }
    s.write(t, i, u, h, 52, 8);
    return u + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(t, i, s) {
    return writeDouble(this, t, i, !0, s);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(t, i, s) {
    return writeDouble(this, t, i, !1, s);
  };
  Buffer.prototype.copy = function copy(t, i, s, u) {
    if (!Buffer.isBuffer(t)) {
      throw new TypeError("argument should be a Buffer");
    }
    if (!s) {
      s = 0;
    }
    if (!u && 0 !== u) {
      u = this.length;
    }
    if (i >= t.length) {
      i = t.length;
    }
    if (!i) {
      i = 0;
    }
    if (u > 0 && u < s) {
      u = s;
    }
    if (u === s) {
      return 0;
    }
    if (0 === t.length || 0 === this.length) {
      return 0;
    }
    if (i < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (s < 0 || s >= this.length) {
      throw new RangeError("Index out of range");
    }
    if (u < 0) {
      throw new RangeError("sourceEnd out of bounds");
    }
    if (u > this.length) {
      u = this.length;
    }
    if (t.length - i < u - s) {
      u = t.length - i + s;
    }
    var h = u - s;
    if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) {
      this.copyWithin(i, s, u);
    } else {
      Uint8Array.prototype.set.call(t, this.subarray(s, u), i);
    }
    return h;
  };
  Buffer.prototype.fill = function fill(t, i, s, u) {
    if ("string" == typeof t) {
      if ("string" == typeof i) {
        u = i;
        i = 0;
        s = this.length;
      } else if ("string" == typeof s) {
        u = s;
        s = this.length;
      }
      if (void 0 !== u && "string" != typeof u) {
        throw new TypeError("encoding must be a string");
      }
      if ("string" == typeof u && !Buffer.isEncoding(u)) {
        throw new TypeError("Unknown encoding: " + u);
      }
      if (1 === t.length) {
        var h = t.charCodeAt(0);
        if ("utf8" === u && h < 128 || "latin1" === u) {
          t = h;
        }
      }
    } else if ("number" == typeof t) {
      t &= 255;
    } else if ("boolean" == typeof t) {
      t = Number(t);
    }
    if (i < 0 || this.length < i || this.length < s) {
      throw new RangeError("Out of range index");
    }
    if (s <= i) {
      return this;
    }
    i >>>= 0;
    s = void 0 === s ? this.length : s >>> 0;
    if (!t) {
      t = 0;
    }
    var c;
    if ("number" == typeof t) {
      for (c = i; c < s; ++c) {
        this[c] = t;
      }
    } else {
      var f = Buffer.isBuffer(t) ? t : Buffer.from(t, u);
      var p = f.length;
      if (0 === p) {
        throw new TypeError('The value "' + t + '" is invalid for argument "value"');
      }
      for (c = 0; c < s - i; ++c) {
        this[c + i] = f[c % p];
      }
    }
    return this;
  };
  var f = {};
  function E(t, i, s) {
    f[t] = class NodeError extends s {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: i.apply(this, arguments),
          writable: !0,
          configurable: !0
        });
        this.name = `${this.name} [${t}]`;
        delete this.name;
      }
      get code() {
        return t;
      }
      set code(t) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: t,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${t}]: ${this.message}`;
      }
    };
  }
  E("ERR_BUFFER_OUT_OF_BOUNDS", (function(t) {
    if (t) {
      return `${t} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }), RangeError);
  E("ERR_INVALID_ARG_TYPE", (function(t, i) {
    return `The "${t}" argument must be of type number. Received type ${typeof i}`;
  }), TypeError);
  E("ERR_OUT_OF_RANGE", (function(t, i, s) {
    var u = `The value of "${t}" is out of range.`;
    var h = s;
    if (Number.isInteger(s) && Math.abs(s) > 2 ** 32) {
      h = addNumericalSeparator(String(s));
    } else if ("bigint" == typeof s) {
      h = String(s);
      if (s > BigInt(2) ** BigInt(32) || s < -(BigInt(2) ** BigInt(32))) {
        h = addNumericalSeparator(h);
      }
      h += "n";
    }
    return u += ` It must be ${i}. Received ${h}`;
  }), RangeError);
  function addNumericalSeparator(t) {
    var i = "";
    var s = t.length;
    var u = "-" === t[0] ? 1 : 0;
    for (;s >= u + 4; s -= 3) {
      i = `_${t.slice(s - 3, s)}${i}`;
    }
    return `${t.slice(0, s)}${i}`;
  }
  function checkIntBI(t, i, s, u, h, c) {
    if (t > s || t < i) {
      var p = "bigint" == typeof i ? "n" : "";
      var m;
      if (c > 3) {
        if (0 === i || i === BigInt(0)) {
          m = `>= 0${p} and < 2${p} ** ${8 * (c + 1)}${p}`;
        } else {
          m = `>= -(2${p} ** ${8 * (c + 1) - 1}${p}) and < 2 ** ${8 * (c + 1) - 1}${p}`;
        }
      } else {
        m = `>= ${i}${p} and <= ${s}${p}`;
      }
      throw new f.ERR_OUT_OF_RANGE("value", m, t);
    }
    !function checkBounds(t, i, s) {
      validateNumber(i, "offset");
      if (void 0 === t[i] || void 0 === t[i + s]) {
        boundsError(i, t.length - (s + 1));
      }
    }(u, h, c);
  }
  function validateNumber(t, i) {
    if ("number" != typeof t) {
      throw new f.ERR_INVALID_ARG_TYPE(i, "number", t);
    }
  }
  function boundsError(t, i, s) {
    if (Math.floor(t) !== t) {
      validateNumber(t, s);
      throw new f.ERR_OUT_OF_RANGE(s || "offset", "an integer", t);
    }
    if (i < 0) {
      throw new f.ERR_BUFFER_OUT_OF_BOUNDS;
    }
    throw new f.ERR_OUT_OF_RANGE(s || "offset", `>= ${s ? 1 : 0} and <= ${i}`, t);
  }
  var p = /[^+/0-9A-Za-z-_]/g;
  function utf8ToBytes(t, i) {
    i = i || 1 / 0;
    var s;
    var u = t.length;
    var h = null;
    var c = [];
    for (var f = 0; f < u; ++f) {
      if ((s = t.charCodeAt(f)) > 55295 && s < 57344) {
        if (!h) {
          if (s > 56319) {
            if ((i -= 3) > -1) {
              c.push(239, 191, 189);
            }
            continue;
          } else if (f + 1 === u) {
            if ((i -= 3) > -1) {
              c.push(239, 191, 189);
            }
            continue;
          }
          h = s;
          continue;
        }
        if (s < 56320) {
          if ((i -= 3) > -1) {
            c.push(239, 191, 189);
          }
          h = s;
          continue;
        }
        s = 65536 + (h - 55296 << 10 | s - 56320);
      } else if (h) {
        if ((i -= 3) > -1) {
          c.push(239, 191, 189);
        }
      }
      h = null;
      if (s < 128) {
        if ((i -= 1) < 0) {
          break;
        }
        c.push(s);
      } else if (s < 2048) {
        if ((i -= 2) < 0) {
          break;
        }
        c.push(s >> 6 | 192, 63 & s | 128);
      } else if (s < 65536) {
        if ((i -= 3) < 0) {
          break;
        }
        c.push(s >> 12 | 224, s >> 6 & 63 | 128, 63 & s | 128);
      } else if (s < 1114112) {
        if ((i -= 4) < 0) {
          break;
        }
        c.push(s >> 18 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, 63 & s | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return c;
  }
  function base64ToBytes(t) {
    return i.toByteArray(function base64clean(t) {
      if ((t = (t = t.split("=")[0]).trim().replace(p, "")).length < 2) {
        return "";
      }
      while (t.length % 4 != 0) {
        t += "=";
      }
      return t;
    }(t));
  }
  function blitBuffer(t, i, s, u) {
    var h;
    for (h = 0; h < u; ++h) {
      if (h + s >= i.length || h >= t.length) {
        break;
      }
      i[h + s] = t[h];
    }
    return h;
  }
  function isInstance(t, i) {
    return t instanceof i || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === i.name;
  }
  function numberIsNaN(t) {
    return t != t;
  }
  var m = function() {
    var t = "0123456789abcdef";
    var i = new Array(256);
    for (var s = 0; s < 16; ++s) {
      var u = 16 * s;
      for (var h = 0; h < 16; ++h) {
        i[u + h] = t[s] + t[h];
      }
    }
    return i;
  }();
  function defineBigIntMethod(t) {
    return "undefined" == typeof BigInt ? BufferBigIntNotDefined : t;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
}(v);

x.isArray = function isArray$3(t) {
  if (Array.isArray) {
    return Array.isArray(t);
  }
  return "[object Array]" === objectToString(t);
};

x.isBoolean = function isBoolean(t) {
  return "boolean" == typeof t;
};

x.isNull = function isNull(t) {
  return null === t;
};

x.isNullOrUndefined = function isNullOrUndefined(t) {
  return null == t;
};

x.isNumber = function isNumber$2(t) {
  return "number" == typeof t;
};

x.isString = function isString$2(t) {
  return "string" == typeof t;
};

x.isSymbol = function isSymbol(t) {
  return "symbol" == typeof t;
};

x.isUndefined = function isUndefined(t) {
  return void 0 === t;
};

x.isRegExp = function isRegExp(t) {
  return "[object RegExp]" === objectToString(t);
};

x.isObject = function isObject$3(t) {
  return "object" == typeof t && null !== t;
};

x.isDate = function isDate(t) {
  return "[object Date]" === objectToString(t);
};

x.isError = function isError(t) {
  return "[object Error]" === objectToString(t) || t instanceof Error;
};

x.isFunction = function isFunction$1(t) {
  return "function" == typeof t;
};

x.isPrimitive = function isPrimitive(t) {
  return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t;
};

x.isBuffer = v.Buffer.isBuffer;

function objectToString(t) {
  return Object.prototype.toString.call(t);
}

var F = 32;

var B = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];

var b;

var log10 = t => t < 1e5 ? t < 100 ? t < 10 ? 0 : 1 : t < 1e4 ? t < 1e3 ? 2 : 3 : 4 : t < 1e7 ? t < 1e6 ? 5 : 6 : t < 1e9 ? t < 1e8 ? 7 : 8 : 9;

function alphabeticalCompare(t, i) {
  if (t === i) {
    return 0;
  }
  if (~~t === t && ~~i === i) {
    if (0 === t || 0 === i) {
      return t < i ? -1 : 1;
    }
    if (t < 0 || i < 0) {
      if (i >= 0) {
        return -1;
      }
      if (t >= 0) {
        return 1;
      }
      t = -t;
      i = -i;
    }
    var s = log10(t);
    var u = log10(i);
    var h = 0;
    if (s < u) {
      t *= B[u - s - 1];
      i /= 10;
      h = -1;
    } else if (s > u) {
      i *= B[s - u - 1];
      t /= 10;
      h = 1;
    }
    if (t === i) {
      return h;
    }
    return t < i ? -1 : 1;
  }
  var c = String(t);
  var f = String(i);
  if (c === f) {
    return 0;
  }
  return c < f ? -1 : 1;
}

function makeAscendingRun(t, i, s, u) {
  var h = i + 1;
  if (h === s) {
    return 1;
  }
  if (u(t[h++], t[i]) < 0) {
    while (h < s && u(t[h], t[h - 1]) < 0) {
      h++;
    }
    reverseRun(t, i, h);
    reverseRun(b, i, h);
  } else {
    while (h < s && u(t[h], t[h - 1]) >= 0) {
      h++;
    }
  }
  return h - i;
}

function reverseRun(t, i, s) {
  s--;
  while (i < s) {
    var u = t[i];
    t[i++] = t[s];
    t[s--] = u;
  }
}

function binaryInsertionSort(t, i, s, u, h) {
  if (u === i) {
    u++;
  }
  for (;u < s; u++) {
    var c = t[u];
    var f = b[u];
    var p = i;
    var m = u;
    while (p < m) {
      var x = p + m >>> 1;
      if (h(c, t[x]) < 0) {
        m = x;
      } else {
        p = x + 1;
      }
    }
    var v = u - p;
    switch (v) {
     case 3:
      t[p + 3] = t[p + 2];
      b[p + 3] = b[p + 2];

     case 2:
      t[p + 2] = t[p + 1];
      b[p + 2] = b[p + 1];

     case 1:
      t[p + 1] = t[p];
      b[p + 1] = b[p];
      break;

     default:
      while (v > 0) {
        t[p + v] = t[p + v - 1];
        b[p + v] = b[p + v - 1];
        v--;
      }
    }
    t[p] = c;
    b[p] = f;
  }
}

function gallopLeft(t, i, s, u, h, c) {
  var f = 0;
  var p = 0;
  var m = 1;
  if (c(t, i[s + h]) > 0) {
    p = u - h;
    while (m < p && c(t, i[s + h + m]) > 0) {
      f = m;
      if ((m = 1 + (m << 1)) <= 0) {
        m = p;
      }
    }
    if (m > p) {
      m = p;
    }
    f += h;
    m += h;
  } else {
    p = h + 1;
    while (m < p && c(t, i[s + h - m]) <= 0) {
      f = m;
      if ((m = 1 + (m << 1)) <= 0) {
        m = p;
      }
    }
    if (m > p) {
      m = p;
    }
    var x = f;
    f = h - m;
    m = h - x;
  }
  f++;
  while (f < m) {
    var v = f + (m - f >>> 1);
    if (c(t, i[s + v]) > 0) {
      f = v + 1;
    } else {
      m = v;
    }
  }
  return m;
}

function gallopRight(t, i, s, u, h, c) {
  var f = 0;
  var p = 0;
  var m = 1;
  if (c(t, i[s + h]) < 0) {
    p = h + 1;
    while (m < p && c(t, i[s + h - m]) < 0) {
      f = m;
      if ((m = 1 + (m << 1)) <= 0) {
        m = p;
      }
    }
    if (m > p) {
      m = p;
    }
    var x = f;
    f = h - m;
    m = h - x;
  } else {
    p = u - h;
    while (m < p && c(t, i[s + h + m]) >= 0) {
      f = m;
      if ((m = 1 + (m << 1)) <= 0) {
        m = p;
      }
    }
    if (m > p) {
      m = p;
    }
    f += h;
    m += h;
  }
  f++;
  while (f < m) {
    var v = f + (m - f >>> 1);
    if (c(t, i[s + v]) < 0) {
      m = v;
    } else {
      f = v + 1;
    }
  }
  return m;
}

class TimSort {
  constructor(t, i) {
    this.array = t;
    this.compare = i;
    var {length: s} = t;
    this.length = s;
    this.minGallop = 7;
    this.tmpStorageLength = s < 512 ? s >>> 1 : 256;
    this.tmp = new Array(this.tmpStorageLength);
    this.tmpIndex = new Array(this.tmpStorageLength);
    this.stackLength = s < 120 ? 5 : s < 1542 ? 10 : s < 119151 ? 19 : 40;
    this.runStart = new Array(this.stackLength);
    this.runLength = new Array(this.stackLength);
    this.stackSize = 0;
  }
  pushRun(t, i) {
    this.runStart[this.stackSize] = t;
    this.runLength[this.stackSize] = i;
    this.stackSize += 1;
  }
  mergeRuns() {
    while (this.stackSize > 1) {
      var t = this.stackSize - 2;
      if (t >= 1 && this.runLength[t - 1] <= this.runLength[t] + this.runLength[t + 1] || t >= 2 && this.runLength[t - 2] <= this.runLength[t] + this.runLength[t - 1]) {
        if (this.runLength[t - 1] < this.runLength[t + 1]) {
          t--;
        }
      } else if (this.runLength[t] > this.runLength[t + 1]) {
        break;
      }
      this.mergeAt(t);
    }
  }
  forceMergeRuns() {
    while (this.stackSize > 1) {
      var t = this.stackSize - 2;
      if (t > 0 && this.runLength[t - 1] < this.runLength[t + 1]) {
        t--;
      }
      this.mergeAt(t);
    }
  }
  mergeAt(t) {
    var {compare: i} = this;
    var {array: s} = this;
    var u = this.runStart[t];
    var h = this.runLength[t];
    var c = this.runStart[t + 1];
    var f = this.runLength[t + 1];
    this.runLength[t] = h + f;
    if (t === this.stackSize - 3) {
      this.runStart[t + 1] = this.runStart[t + 2];
      this.runLength[t + 1] = this.runLength[t + 2];
    }
    this.stackSize--;
    var p = gallopRight(s[c], s, u, h, 0, i);
    if (0 === (h -= p)) {
      return;
    }
    if (0 === (f = gallopLeft(s[(u += p) + h - 1], s, c, f, f - 1, i))) {
      return;
    }
    if (h <= f) {
      this.mergeLow(u, h, c, f);
    } else {
      this.mergeHigh(u, h, c, f);
    }
  }
  mergeLow(t, i, s, u) {
    var {compare: h} = this;
    var {array: c} = this;
    var {tmp: f} = this;
    var {tmpIndex: p} = this;
    var m = 0;
    for (m = 0; m < i; m++) {
      f[m] = c[t + m];
      p[m] = b[t + m];
    }
    var x = 0;
    var v = s;
    var D = t;
    c[D] = c[v];
    b[D] = b[v];
    D++;
    v++;
    if (0 == --u) {
      for (m = 0; m < i; m++) {
        c[D + m] = f[x + m];
        b[D + m] = p[x + m];
      }
      return;
    }
    if (1 === i) {
      for (m = 0; m < u; m++) {
        c[D + m] = c[v + m];
        b[D + m] = b[v + m];
      }
      c[D + u] = f[x];
      b[D + u] = p[x];
      return;
    }
    var {minGallop: y} = this;
    while (1) {
      var g = 0;
      var S = 0;
      var C = !1;
      do {
        if (h(c[v], f[x]) < 0) {
          c[D] = c[v];
          b[D] = b[v];
          D++;
          v++;
          S++;
          g = 0;
          if (0 == --u) {
            C = !0;
            break;
          }
        } else {
          c[D] = f[x];
          b[D] = p[x];
          D++;
          x++;
          g++;
          S = 0;
          if (1 == --i) {
            C = !0;
            break;
          }
        }
      } while ((g | S) < y);
      if (C) {
        break;
      }
      do {
        if (0 !== (g = gallopRight(c[v], f, x, i, 0, h))) {
          for (m = 0; m < g; m++) {
            c[D + m] = f[x + m];
            b[D + m] = p[x + m];
          }
          D += g;
          x += g;
          if ((i -= g) <= 1) {
            C = !0;
            break;
          }
        }
        c[D] = c[v];
        b[D] = b[v];
        D++;
        v++;
        if (0 == --u) {
          C = !0;
          break;
        }
        if (0 !== (S = gallopLeft(f[x], c, v, u, 0, h))) {
          for (m = 0; m < S; m++) {
            c[D + m] = c[v + m];
            b[D + m] = b[v + m];
          }
          D += S;
          v += S;
          if (0 === (u -= S)) {
            C = !0;
            break;
          }
        }
        c[D] = f[x];
        b[D] = p[x];
        D++;
        x++;
        if (1 == --i) {
          C = !0;
          break;
        }
        y--;
      } while (g >= 7 || S >= 7);
      if (C) {
        break;
      }
      if (y < 0) {
        y = 0;
      }
      y += 2;
    }
    this.minGallop = y;
    if (y < 1) {
      this.minGallop = 1;
    }
    if (1 === i) {
      for (m = 0; m < u; m++) {
        c[D + m] = c[v + m];
        b[D + m] = b[v + m];
      }
      c[D + u] = f[x];
      b[D + u] = p[x];
    } else if (0 === i) {
      throw new Error("mergeLow preconditions were not respected");
    } else {
      for (m = 0; m < i; m++) {
        c[D + m] = f[x + m];
        b[D + m] = p[x + m];
      }
    }
  }
  mergeHigh(t, i, s, u) {
    var {compare: h} = this;
    var {array: c} = this;
    var {tmp: f} = this;
    var {tmpIndex: p} = this;
    var m = 0;
    for (m = 0; m < u; m++) {
      f[m] = c[s + m];
      p[m] = b[s + m];
    }
    var x = t + i - 1;
    var v = u - 1;
    var D = s + u - 1;
    var y = 0;
    var g = 0;
    c[D] = c[x];
    b[D] = b[x];
    D--;
    x--;
    if (0 == --i) {
      y = D - (u - 1);
      for (m = 0; m < u; m++) {
        c[y + m] = f[m];
        b[y + m] = p[m];
      }
      return;
    }
    if (1 === u) {
      g = (D -= i) + 1;
      y = (x -= i) + 1;
      for (m = i - 1; m >= 0; m--) {
        c[g + m] = c[y + m];
        b[g + m] = b[y + m];
      }
      c[D] = f[v];
      b[D] = p[v];
      return;
    }
    var {minGallop: S} = this;
    while (1) {
      var C = 0;
      var A = 0;
      var w = !1;
      do {
        if (h(f[v], c[x]) < 0) {
          c[D] = c[x];
          b[D] = b[x];
          D--;
          x--;
          C++;
          A = 0;
          if (0 == --i) {
            w = !0;
            break;
          }
        } else {
          c[D] = f[v];
          b[D] = p[v];
          D--;
          v--;
          A++;
          C = 0;
          if (1 == --u) {
            w = !0;
            break;
          }
        }
      } while ((C | A) < S);
      if (w) {
        break;
      }
      do {
        if (0 !== (C = i - gallopRight(f[v], c, t, i, i - 1, h))) {
          i -= C;
          g = (D -= C) + 1;
          y = (x -= C) + 1;
          for (m = C - 1; m >= 0; m--) {
            c[g + m] = c[y + m];
            b[g + m] = b[y + m];
          }
          if (0 === i) {
            w = !0;
            break;
          }
        }
        c[D] = f[v];
        b[D] = p[v];
        D--;
        v--;
        if (1 == --u) {
          w = !0;
          break;
        }
        if (0 !== (A = u - gallopLeft(c[x], f, 0, u, u - 1, h))) {
          u -= A;
          g = (D -= A) + 1;
          y = (v -= A) + 1;
          for (m = 0; m < A; m++) {
            c[g + m] = f[y + m];
            b[g + m] = p[y + m];
          }
          if (u <= 1) {
            w = !0;
            break;
          }
        }
        c[D] = c[x];
        b[D] = b[x];
        D--;
        x--;
        if (0 == --i) {
          w = !0;
          break;
        }
        S--;
      } while (C >= 7 || A >= 7);
      if (w) {
        break;
      }
      if (S < 0) {
        S = 0;
      }
      S += 2;
    }
    this.minGallop = S;
    if (S < 1) {
      this.minGallop = 1;
    }
    if (1 === u) {
      g = (D -= i) + 1;
      y = (x -= i) + 1;
      for (m = i - 1; m >= 0; m--) {
        c[g + m] = c[y + m];
        b[g + m] = b[y + m];
      }
      c[D] = f[v];
      b[D] = p[v];
    } else if (0 === u) {
      throw new Error("mergeHigh preconditions were not respected");
    } else {
      y = D - (u - 1);
      for (m = 0; m < u; m++) {
        c[y + m] = f[m];
        b[y + m] = p[m];
      }
    }
  }
}

var k = {
  sort: function sort$1(t, i, s, u) {
    if (!Array.isArray(t)) {
      throw new TypeError(`The "array" argument must be an array. Received ${t}`);
    }
    b = [];
    var {length: h} = t;
    var c = 0;
    while (c < h) {
      b[c] = c++;
    }
    if (!i) {
      i = alphabeticalCompare;
    } else if ("function" != typeof i) {
      u = s;
      s = i;
      i = alphabeticalCompare;
    }
    if (!s) {
      s = 0;
    }
    if (!u) {
      u = h;
    }
    var f = u - s;
    if (f < 2) {
      return b;
    }
    var p = 0;
    if (f < F) {
      binaryInsertionSort(t, s, u, s + (p = makeAscendingRun(t, s, u, i)), i);
      return b;
    }
    var m = new TimSort(t, i);
    var x = function minRunLength(t) {
      var i = 0;
      while (t >= F) {
        i |= 1 & t;
        t >>= 1;
      }
      return t + i;
    }(f);
    do {
      if ((p = makeAscendingRun(t, s, u, i)) < x) {
        var v = f;
        if (v > x) {
          v = x;
        }
        binaryInsertionSort(t, s, s + v, s + p, i);
        p = v;
      }
      m.pushRun(s, p);
      m.mergeRuns();
      f -= p;
      s += p;
    } while (0 !== f);
    m.forceMergeRuns();
    return b;
  }
};

var I = Object.prototype.hasOwnProperty;

var hasOwnProperty = (t, i) => I.call(t, i);

var {isObject: T, isArray: P, isString: N, isNumber: L} = x;

var M = "before";

var U = "after-prop";

var O = "after-colon";

var R = "after-value";

var X = "after";

var J = "before-all";

var _ = "after-all";

var z = [ M, U, O, R, X ];

var j = [ M, J, _ ].map(Symbol.for);

var K = void 0;

var symbol$1 = (t, i) => Symbol.for(t + ":" + i);

var define$1 = (t, i, s) => Object.defineProperty(t, i, {
  value: s,
  writable: !0,
  configurable: !0
});

var copy_comments_by_kind = (t, i, s, u, h, c) => {
  var f = symbol$1(h, u);
  if (!hasOwnProperty(i, f)) {
    return;
  }
  var p = s === u ? f : symbol$1(h, s);
  define$1(t, p, i[f]);
  if (c) {
    delete i[f];
  }
};

var copy_comments$1 = (t, i, s, u, h) => {
  z.forEach((c => {
    copy_comments_by_kind(t, i, s, u, c, h);
  }));
};

var assign_non_prop_comments$1 = (t, i) => {
  j.forEach((s => {
    var u = i[s];
    if (u) {
      define$1(t, s, u);
    }
  }));
};

var G = {
  SYMBOL_PREFIXES: z,
  PREFIX_BEFORE: M,
  PREFIX_AFTER_PROP: U,
  PREFIX_AFTER_COLON: O,
  PREFIX_AFTER_VALUE: R,
  PREFIX_AFTER: X,
  PREFIX_BEFORE_ALL: J,
  PREFIX_AFTER_ALL: _,
  BRACKET_OPEN: "[",
  BRACKET_CLOSE: "]",
  CURLY_BRACKET_OPEN: "{",
  CURLY_BRACKET_CLOSE: "}",
  COLON: ":",
  COMMA: ",",
  MINUS: "-",
  EMPTY: "",
  UNDEFINED: K,
  symbol: symbol$1,
  define: define$1,
  copy_comments: copy_comments$1,
  swap_comments: (t, i, s) => {
    if (i === s) {
      return;
    }
    z.forEach((u => {
      var h = symbol$1(u, s);
      if (!hasOwnProperty(t, h)) {
        copy_comments_by_kind(t, t, s, i, u, !0);
        return;
      }
      var c = t[h];
      delete t[h];
      copy_comments_by_kind(t, t, s, i, u, !0);
      define$1(t, symbol$1(u, i), c);
    }));
  },
  assign_non_prop_comments: assign_non_prop_comments$1,
  assign(t, i, s) {
    if (!T(t)) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    if (!T(i)) {
      return t;
    }
    if (s === K) {
      s = Object.keys(i);
      assign_non_prop_comments$1(t, i);
    } else if (!P(s)) {
      throw new TypeError("keys must be array or undefined");
    } else if (0 === s.length) {
      assign_non_prop_comments$1(t, i);
    }
    return ((t, i, s) => {
      s.forEach((s => {
        if (!N(s) && !L(s)) {
          return;
        }
        if (!hasOwnProperty(i, s)) {
          return;
        }
        t[s] = i[s];
        copy_comments$1(t, i, s, s);
      }));
      return t;
    })(t, i, s);
  }
};

var {isArray: H} = x;

var {sort: $} = k;

var {SYMBOL_PREFIXES: W, UNDEFINED: q, symbol: V, copy_comments: Y, swap_comments: Q} = G;

var move_comment = (t, i, s, u, h) => {
  Y(t, i, s + u, s, h);
};

var move_comments = (t, i, s, u, h, c) => {
  if (h > 0) {
    var f = u;
    while (f-- > 0) {
      move_comment(t, i, s + f, h, c);
    }
    return;
  }
  var p = 0;
  while (p < u) {
    var m = p++;
    move_comment(t, i, s + m, h, c);
  }
};

var remove_comments$1 = (t, i) => {
  W.forEach((s => {
    var u = V(s, i);
    delete t[u];
  }));
};

var Z = {
  CommentArray: class CommentArray extends Array {
    splice(...t) {
      var {length: i} = this;
      var s = super.splice(...t);
      var [u, h, ...c] = t;
      if (u < 0) {
        u += i;
      }
      if (1 === arguments.length) {
        h = i - u;
      } else {
        h = Math.min(i - u, h);
      }
      var {length: f} = c;
      var p = u + h;
      move_comments(this, this, p, i - p, f - h, !0);
      return s;
    }
    slice(...t) {
      var {length: i} = this;
      var s = super.slice(...t);
      if (!s.length) {
        return new CommentArray;
      }
      var [u, h] = t;
      if (h === q) {
        h = i;
      } else if (h < 0) {
        h += i;
      }
      if (u < 0) {
        u += i;
      } else if (u === q) {
        u = 0;
      }
      move_comments(s, this, u, h - u, -u);
      return s;
    }
    unshift(...t) {
      var {length: i} = this;
      var s = super.unshift(...t);
      var {length: u} = t;
      if (u > 0) {
        move_comments(this, this, 0, i, u, !0);
      }
      return s;
    }
    shift() {
      var t = super.shift();
      var {length: i} = this;
      remove_comments$1(this, 0);
      move_comments(this, this, 1, i, -1, !0);
      return t;
    }
    reverse() {
      super.reverse();
      (t => {
        var {length: i} = t;
        var s = 0;
        var u = i / 2;
        for (;s < u; s++) {
          Q(t, s, i - s - 1);
        }
      })(this);
      return this;
    }
    pop() {
      var t = super.pop();
      remove_comments$1(this, this.length);
      return t;
    }
    concat(...t) {
      var {length: i} = this;
      var s = super.concat(...t);
      if (!t.length) {
        return s;
      }
      move_comments(s, this, 0, this.length, 0);
      t.forEach((t => {
        var u = i;
        i += H(t) ? t.length : 1;
        if (!(t instanceof CommentArray)) {
          return;
        }
        move_comments(s, t, 0, t.length, u);
      }));
      return s;
    }
    sort(...t) {
      var i = $(this, ...t.slice(0, 1));
      var s = Object.create(null);
      i.forEach(((t, i) => {
        if (t === i) {
          return;
        }
        var u = ((t, i) => {
          var s = i;
          while (s in t) {
            s = t[s];
          }
          return s;
        })(s, t);
        if (u === i) {
          return;
        }
        s[i] = u;
        Q(this, i, u);
      }));
      return this;
    }
  }
};

var ee = m;

var {CommentArray: te} = Z;

var {PREFIX_BEFORE: re, PREFIX_AFTER_PROP: ie, PREFIX_AFTER_COLON: ne, PREFIX_AFTER_VALUE: se, PREFIX_AFTER: ae, PREFIX_BEFORE_ALL: oe, PREFIX_AFTER_ALL: ue, BRACKET_OPEN: he, BRACKET_CLOSE: ce, CURLY_BRACKET_OPEN: le, CURLY_BRACKET_CLOSE: fe, COLON: pe, COMMA: de, MINUS: me, EMPTY: xe, UNDEFINED: ve, define: De, assign_non_prop_comments: ye} = G;

var tokenize$1 = t => ee.tokenize(t, {
  comment: !0,
  loc: !0
});

var Ee = [];

var ge = null;

var Se = null;

var Ce = [];

var Ae;

var we = !1;

var Fe = !1;

var Be = null;

var be = null;

var ke = null;

var Ie;

var Te = null;

var clean$1 = () => {
  Ce.length = Ee.length = 0;
  be = null;
  Ae = ve;
};

var symbolFor = t => Symbol.for(Ae !== ve ? t + pe + Ae : t);

var transform = (t, i) => Te ? Te(t, i) : i;

var unexpected = () => {
  var t = new SyntaxError(`Unexpected token ${ke.value.slice(0, 1)}`);
  Object.assign(t, ke.loc.start);
  throw t;
};

var unexpected_end = () => {
  var t = new SyntaxError("Unexpected end of JSON input");
  Object.assign(t, be ? be.loc.end : {
    line: 1,
    column: 0
  });
  throw t;
};

var next = () => {
  var t = Be[++Ie];
  Fe = ke && t && ke.loc.end.line === t.loc.start.line || !1;
  be = ke;
  ke = t;
};

var type = () => {
  if (!ke) {
    unexpected_end();
  }
  return "Punctuator" === ke.type ? ke.value : ke.type;
};

var is = t => type() === t;

var expect = t => {
  if (!is(t)) {
    unexpected();
  }
};

var set_comments_host = t => {
  Ee.push(ge);
  ge = t;
};

var restore_comments_host = () => {
  ge = Ee.pop();
};

var assign_after_comments = () => {
  if (!Se) {
    return;
  }
  var t = [];
  for (var i of Se) {
    if (i.inline) {
      t.push(i);
    } else {
      break;
    }
  }
  var {length: s} = t;
  if (!s) {
    return;
  }
  if (s === Se.length) {
    Se = null;
  } else {
    Se.splice(0, s);
  }
  De(ge, symbolFor(ae), t);
};

var assign_comments = t => {
  if (!Se) {
    return;
  }
  De(ge, symbolFor(t), Se);
  Se = null;
};

var parse_comments = t => {
  var i = [];
  while (ke && (is("LineComment") || is("BlockComment"))) {
    var s = {
      ...ke,
      inline: Fe
    };
    i.push(s);
    next();
  }
  if (we) {
    return;
  }
  if (!i.length) {
    return;
  }
  if (t) {
    De(ge, symbolFor(t), i);
    return;
  }
  Se = i;
};

var set_prop = (t, i) => {
  if (i) {
    Ce.push(Ae);
  }
  Ae = t;
};

var restore_prop = () => {
  Ae = Ce.pop();
};

var parse_array = () => {
  var t = new te;
  set_comments_host(t);
  set_prop(ve, !0);
  var i = !1;
  var s = 0;
  parse_comments();
  while (!is(ce)) {
    if (i) {
      assign_comments(se);
      expect(de);
      next();
      parse_comments();
      assign_after_comments();
      if (is(ce)) {
        break;
      }
    }
    i = !0;
    set_prop(s);
    assign_comments(re);
    t[s] = transform(s, walk());
    s++;
    parse_comments();
  }
  if (i) {
    assign_comments(ae);
  }
  next();
  Ae = void 0;
  if (!i) {
    assign_comments(re);
  }
  restore_comments_host();
  restore_prop();
  return t;
};

function walk() {
  var t = type();
  if (t === le) {
    next();
    return (() => {
      var t = {};
      set_comments_host(t);
      set_prop(ve, !0);
      var i = !1;
      var s;
      parse_comments();
      while (!is(fe)) {
        if (i) {
          assign_comments(se);
          expect(de);
          next();
          parse_comments();
          assign_after_comments();
          if (is(fe)) {
            break;
          }
        }
        i = !0;
        expect("String");
        s = JSON.parse(ke.value);
        set_prop(s);
        assign_comments(re);
        next();
        parse_comments(ie);
        expect(pe);
        next();
        parse_comments(ne);
        t[s] = transform(s, walk());
        parse_comments();
      }
      if (i) {
        assign_comments(ae);
      }
      next();
      Ae = void 0;
      if (!i) {
        assign_comments(re);
      }
      restore_comments_host();
      restore_prop();
      return t;
    })();
  }
  if (t === he) {
    next();
    return parse_array();
  }
  var i = xe;
  if (t === me) {
    next();
    t = type();
    i = me;
  }
  var s;
  switch (t) {
   case "String":
   case "Boolean":
   case "Null":
   case "Numeric":
    s = ke.value;
    next();
    return JSON.parse(i + s);
  }
}

var Pe = {
  parse: (t, i, s) => {
    clean$1();
    Be = tokenize$1(t);
    Te = i;
    we = s;
    if (!Be.length) {
      unexpected_end();
    }
    Ie = -1;
    next();
    set_comments_host({});
    parse_comments(oe);
    var u = walk();
    parse_comments(ue);
    if (ke) {
      unexpected();
    }
    if (!s && null !== u) {
      if (!(h = u, Object(h) === h)) {
        u = new Object(u);
      }
      ye(u, ge);
    }
    var h;
    restore_comments_host();
    u = transform("", u);
    (() => {
      clean$1();
      Be.length = 0;
      Se = ge = Be = be = ke = Te = null;
    })();
    return u;
  },
  tokenize: tokenize$1
};

/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ var Ne = "";

var Le;

var Me = function repeat$1(t, i) {
  if ("string" != typeof t) {
    throw new TypeError("expected a string");
  }
  if (1 === i) {
    return t;
  }
  if (2 === i) {
    return t + t;
  }
  var s = t.length * i;
  if (Le !== t || void 0 === Le) {
    Le = t;
    Ne = "";
  } else if (Ne.length >= s) {
    return Ne.substr(0, s);
  }
  while (s > Ne.length && i > 1) {
    if (1 & i) {
      Ne += t;
    }
    i >>= 1;
    t += t;
  }
  return Ne = (Ne += t).substr(0, s);
};

var {isArray: Ue, isObject: Oe, isFunction: Re, isNumber: Xe, isString: Je} = x;

var _e = Me;

var {PREFIX_BEFORE_ALL: ze, PREFIX_BEFORE: je, PREFIX_AFTER_PROP: Ke, PREFIX_AFTER_COLON: Ge, PREFIX_AFTER_VALUE: He, PREFIX_AFTER: $e, PREFIX_AFTER_ALL: We, BRACKET_OPEN: qe, BRACKET_CLOSE: Ve, CURLY_BRACKET_OPEN: Ye, CURLY_BRACKET_CLOSE: Qe, COLON: Ze, COMMA: et, EMPTY: tt, UNDEFINED: rt} = G;

var it = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

var nt = "\n";

var st = "null";

var BEFORE = t => `${je}:${t}`;

var AFTER_VALUE = t => `${He}:${t}`;

var AFTER = t => `${$e}:${t}`;

var at = {
  "\b": "\\b",
  "\t": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};

var quote = t => `"${(t => {
  it.lastIndex = 0;
  if (!it.test(t)) {
    return t;
  }
  return t.replace(it, (t => {
    var i = at[t];
    return "string" == typeof i ? i : t;
  }));
})(t)}"`;

var process_comments = (t, i, s, u) => {
  var h = t[Symbol.for(i)];
  if (!h || !h.length) {
    return tt;
  }
  var c = !1;
  var f = h.reduce(((t, {inline: i, type: u, value: h}) => t + (i ? " " : nt + s) + ((t, i) => i ? `//${t}` : `/*${t}*/`)(h, c = "LineComment" === u)), tt);
  return u || c ? f + nt + s : f;
};

var ot = null;

var ut = tt;

var join = (t, i, s) => t ? i ? t + i.trim() + nt + s : t.trimRight() + nt + s : i ? i.trimRight() + nt + s : tt;

var join_content = (t, i, s) => {
  var u = process_comments(i, je, s + ut, !0);
  return join(u, t, s);
};

var object_stringify = (t, i) => {
  if (!t) {
    return "null";
  }
  var s = i + ut;
  var u = tt;
  var h = tt;
  var c = !0;
  (Ue(ot) ? ot : Object.keys(t)).forEach((i => {
    var f = stringify$1(i, t, s);
    if (f === rt) {
      return;
    }
    if (!c) {
      u += et;
    }
    c = !1;
    var p = join(h, process_comments(t, BEFORE(i), s), s);
    u += p || nt + s;
    u += quote(i) + process_comments(t, `${Ke}:${i}`, s) + Ze + process_comments(t, (t => `${Ge}:${t}`)(i), s) + " " + f + process_comments(t, AFTER_VALUE(i), s);
    h = process_comments(t, AFTER(i), s);
  }));
  u += join(h, process_comments(t, $e, s), s);
  return Ye + join_content(u, t, i) + Qe;
};

function stringify$1(t, i, s) {
  var u = i[t];
  if (Oe(u) && Re(u.toJSON)) {
    u = u.toJSON(t);
  }
  if (Re(ot)) {
    u = ot.call(i, t, u);
  }
  switch (typeof u) {
   case "string":
    return quote(u);

   case "number":
    return Number.isFinite(u) ? String(u) : st;

   case "boolean":
   case "null":
    return String(u);

   case "object":
    return Ue(u) ? ((t, i) => {
      var s = i + ut;
      var {length: u} = t;
      var h = tt;
      var c = tt;
      for (var f = 0; f < u; f++) {
        if (0 !== f) {
          h += et;
        }
        h += join(c, process_comments(t, BEFORE(f), s), s) || nt + s;
        h += stringify$1(f, t, s) || st;
        h += process_comments(t, AFTER_VALUE(f), s);
        c = process_comments(t, AFTER(f), s);
      }
      h += join(c, process_comments(t, $e, s), s);
      return qe + join_content(h, t, i) + Ve;
    })(u, s) : object_stringify(u, s);
  }
}

var {toString: ht} = Object.prototype;

var ct = [ "[object Number]", "[object String]", "[object Boolean]" ];

var {parse: lt, tokenize: ft} = Pe;

var stringify = (t, i, s) => {
  var u = (t => Je(t) ? t : Xe(t) ? _e(" ", t) : tt)(s);
  if (!u) {
    return JSON.stringify(t, i);
  }
  if (!Re(i) && !Ue(i)) {
    i = null;
  }
  ot = i;
  ut = u;
  var h = (t => {
    if ("object" != typeof t) {
      return !1;
    }
    var i = ht.call(t);
    return ct.includes(i);
  })(t) ? JSON.stringify(t) : stringify$1("", {
    "": t
  }, tt);
  (() => {
    ot = null;
    ut = tt;
  })();
  return Oe(t) ? process_comments(t, ze, tt).trimLeft() + h + process_comments(t, We, tt).trimRight() : h;
};

var {CommentArray: pt} = Z;

var {assign: dt} = G;

var mt = {
  parse: lt,
  stringify,
  tokenize: ft,
  CommentArray: pt,
  assign: dt
};

function hasGraphQLSP(t) {
  if (!t.compilerOptions) {
    console.warn("Missing compilerOptions object in tsconfig.json.");
    return !1;
  }
  if (!t.compilerOptions.plugins) {
    console.warn("Missing plugins array in tsconfig.json.");
    return !1;
  }
  var i = t.compilerOptions.plugins.find((t => "@0no-co/graphqlsp" === t.name));
  if (!i) {
    console.warn("Missing @0no-co/graphqlsp plugin in tsconfig.json.");
    return !1;
  }
  if (!i.schema) {
    console.warn("Missing schema property in @0no-co/graphqlsp plugin in tsconfig.json.");
    return !1;
  }
  if (!i.tadaOutputLocation) {
    console.warn("Missing tadaOutputLocation property in @0no-co/graphqlsp plugin in tsconfig.json.");
    return !1;
  }
  return !0;
}

var loadSchema = async (u, h) => {
  var c;
  var f;
  try {
    if ("object" == typeof h) {
      c = new URL(h.url);
      f = {
        headers: h.headers
      };
    } else {
      c = new URL(h);
    }
  } catch (t) {}
  if (c) {
    var p = await fetch(c.toString(), {
      method: "POST",
      headers: f ? {
        ...f.headers || {},
        "Content-Type": "application/json"
      } : {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query: s.getIntrospectionQuery({
          descriptions: !0,
          schemaDescription: !1,
          inputValueDeprecation: !1,
          directiveIsRepeatable: !1,
          specifiedByUrl: !1
        })
      })
    });
    if (p.ok) {
      var m = await p.json();
      if (m.data) {
        var x = m.data;
        try {
          return s.buildClientSchema(x);
        } catch (t) {
          console.error(`Got schema error for ${t.message}`);
        }
      } else {
        console.error(`Got invalid response ${JSON.stringify(m)}`);
      }
    } else {
      console.error(`Got invalid response ${await p.text()}`);
    }
  } else if ("string" == typeof h) {
    var v = ".json" === i.extname(h);
    var D = i.resolve(u, h);
    var y = await t.promises.readFile(D, "utf-8");
    var g = v ? JSON.parse(y) : s.buildSchema(y);
    return "__schema" in g ? s.buildClientSchema(g) : g;
  }
};

var xt = [ "/* eslint-disable */", "/* prettier-ignore */" ].join("\n") + "\n";

var vt = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * It will automatically be used by `gql.tada` to infer the types of your GraphQL documents.", " * If you need to reuse this data or update your `scalars`, update `tadaOutputLocation` to", " * instead save to a .ts instead of a .d.ts file.", " */" ].join("\n");

var Dt = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * You may import it to create a `graphql()` tag function with `gql.tada`", " * by importing it and passing it to `initGraphQLTada<>()`.", " *", " * @example", " * ```", " * import { initGraphQLTada } from 'gql.tada';", " * import type { introspection } from './introspection';", " *", " * export const graphql = initGraphQLTada<{", " *   introspection: typeof introspection;", " *   scalars: {", " *     DateTime: string;", " *     Json: any;", " *   };", " * }>();", " * ```", " */" ].join("\n");

var yt = ((t, i) => new o(t, i))("gql.tada");

yt.version(process.env.npm_package_version || "0.0.0");

module.exports = async function main() {
  yt.command("generate-schema <target>").describe("Generate a GraphQL schema from a URL or introspection file, this will be generated from the parameters to this command.").option("--header", "Pass a header to be used when fetching the introspection.").option("--output", 'A specialised location to output the schema to, by default we\'ll output the schema to the "schema" defined in your "tsconfig".').example("generate-schema https://example.com --header 'Authorization: Bearer token'").example("generate-schema ./introspection.json").action((async (u, h) => {
    var c = process.cwd();
    var f;
    try {
      f = new URL(u);
    } catch (t) {}
    var p;
    if (f) {
      var m = (Array.isArray(h.header) ? h.header : [ h.header ]).reduce(((t, i) => {
        if (!i) {
          return t;
        }
        var s = i.split(":");
        return {
          ...t,
          [s[0]]: s[1]
        };
      }), {});
      var x = await fetch(f.toString(), {
        method: "POST",
        headers: {
          ...m,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query: s.getIntrospectionQuery({
            descriptions: !0,
            schemaDescription: !1,
            inputValueDeprecation: !1,
            directiveIsRepeatable: !1,
            specifiedByUrl: !1
          })
        })
      });
      if (x.ok) {
        var v = await x.text();
        try {
          var D = JSON.parse(v);
          if (D.data) {
            p = D.data;
          } else {
            console.error(`Got invalid response ${JSON.stringify(D)}`);
            return;
          }
        } catch (t) {
          console.error(`Got invalid JSON ${v}`);
          return;
        }
      } else {
        console.error(`Got invalid response ${await x.text()}`);
        return;
      }
    } else {
      var y = i.resolve(c, u);
      var g = await t.promises.readFile(y, "utf-8");
      try {
        p = JSON.parse(g);
      } catch (t) {
        console.error(`Got invalid JSON ${g}`);
        return;
      }
    }
    var S = s.buildClientSchema(p);
    var C = h.output;
    if (!C) {
      var A = process.cwd();
      var w = i.resolve(A, "tsconfig.json");
      if (!t.existsSync(w)) {
        console.error("Could not find a tsconfig in the working-directory.");
        return;
      }
      var F = await t.promises.readFile(w, "utf-8");
      var B;
      try {
        B = mt.parse(F);
      } catch (t) {
        console.error(t);
        return;
      }
      if (!hasGraphQLSP(B)) {
        console.error('Could not find a "@0no-co/graphqlsp" plugin in your tsconfig.');
        return;
      }
      var b = B.compilerOptions.plugins.find((t => "@0no-co/graphqlsp" === t.name));
      C = b.schema;
      if (!b.schema.endsWith(".graphql")) {
        console.error(`Found "${b.schema}" which is not a path to a GraphQL Schema.`);
        return;
      }
    }
    await t.promises.writeFile(i.resolve(c, C), s.printSchema(S), "utf-8");
  })).command("generate-output").describe('Generate the gql.tada types file, this will look for your "tsconfig.json" and use the "@0no-co/graphqlsp" configuration to generate the file.').action((async () => {
    var h = process.cwd();
    var c = i.resolve(h, "tsconfig.json");
    if (!t.existsSync(c)) {
      console.error("Missing tsconfig.json");
      return;
    }
    var f = await t.promises.readFile(c, "utf-8");
    var p;
    try {
      p = mt.parse(f);
    } catch (t) {
      console.error(t);
      return;
    }
    if (!hasGraphQLSP(p)) {
      return;
    }
    var m = p.compilerOptions.plugins.find((t => "@0no-co/graphqlsp" === t.name));
    await async function ensureTadaIntrospection(h, c) {
      var f = process.cwd();
      await (async () => {
        try {
          var p = await loadSchema(f, h);
          if (!p) {
            console.error("Something went wrong while trying to load the schema.");
            return;
          }
          var m = s.introspectionFromSchema(p, {
            descriptions: !1
          });
          var x = u.minifyIntrospectionQuery(m, {
            includeDirectives: !1,
            includeEnums: !0,
            includeInputs: !0,
            includeScalars: !0
          });
          var v = JSON.stringify(x, null, 2);
          var D = i.resolve(f, c);
          var y;
          if (/\.d\.ts$/.test(c)) {
            y = [ xt, vt, `export type introspection = ${v};\n`, "import * as gqlTada from 'gql.tada';\n", "declare module 'gql.tada' {", "  interface setupSchema {", "    introspection: introspection", "  }", "}" ].join("\n");
          } else if (".ts" === i.extname(c)) {
            y = [ xt, Dt, `const introspection = ${v} as const;\n`, "export { introspection };" ].join("\n");
          } else {
            console.warn("Invalid file extension for tadaOutputLocation.");
            return;
          }
          await t.promises.writeFile(D, y);
        } catch (t) {
          console.error("Something went wrong while writing the introspection file", t);
        }
      })();
    }(m.schema, m.tadaOutputLocation);
  }));
  yt.parse(process.argv);
};
//# sourceMappingURL=gql-tada-cli.js.map
