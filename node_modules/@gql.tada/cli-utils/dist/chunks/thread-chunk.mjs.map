{"version":3,"file":"thread-chunk.mjs","sources":["../../src/commands/generate-persisted/thread.ts"],"sourcesContent":["import * as path from 'node:path';\nimport { print } from '@0no-co/graphql.web';\nimport { Project, ts } from 'ts-morph';\n\nimport type { FragmentDefinitionNode } from '@0no-co/graphql.web';\nimport type { GraphQLSPConfig } from '@gql.tada/internal';\n\nimport {\n  init,\n  findAllPersistedCallExpressions,\n  getDocumentReferenceFromTypeQuery,\n  getDocumentReferenceFromDocumentNode,\n  unrollTadaFragments,\n} from '@0no-co/graphqlsp/api';\n\nimport { createPluginInfo, getFilePosition } from '../../ts';\nimport { expose } from '../../threads';\n\nimport type { PersistedSignal, PersistedWarning } from './types';\n\nexport interface PersistedParams {\n  rootPath: string;\n  configPath: string;\n  pluginConfig: GraphQLSPConfig;\n}\n\nasync function* _runPersisted(params: PersistedParams): AsyncIterableIterator<PersistedSignal> {\n  init({ typescript: ts as any });\n\n  const projectPath = path.dirname(params.configPath);\n  const project = new Project({ tsConfigFilePath: params.configPath });\n  const pluginInfo = createPluginInfo(project, params.pluginConfig, projectPath);\n\n  // Filter source files by whether they're under the relevant root path\n  const sourceFiles = project.getSourceFiles().filter((sourceFile) => {\n    const filePath = path.resolve(projectPath, sourceFile.getFilePath());\n    const relative = path.relative(params.rootPath, filePath);\n    return !relative.startsWith('..');\n  });\n\n  yield {\n    kind: 'FILE_COUNT',\n    fileCount: sourceFiles.length,\n  };\n\n  for (const { compilerNode: sourceFile } of sourceFiles) {\n    const filePath = sourceFile.fileName;\n    const documents: Record<string, string> = {};\n    const warnings: PersistedWarning[] = [];\n\n    const calls = findAllPersistedCallExpressions(sourceFile);\n    for (const call of calls) {\n      const position = getFilePosition(sourceFile, call.getStart());\n      const hashArg = call.arguments[0];\n      const docArg = call.arguments[1];\n      const typeQuery = call.typeArguments && call.typeArguments[0];\n      if (!hashArg || !ts.isStringLiteral(hashArg)) {\n        warnings.push({\n          message:\n            '\"graphql.persisted\" must be called with a string literal as the first argument.',\n          file: filePath,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      } else if (!docArg && !typeQuery) {\n        warnings.push({\n          message:\n            '\"graphql.persisted\" is missing a document.\\n' +\n            'This may be passed as a generic such as `graphql.persisted<typeof document>` or as the second argument.',\n          file: filePath,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      let foundNode: ts.CallExpression | null = null;\n      let referencingNode: ts.Node = call;\n      if (docArg && (ts.isCallExpression(docArg) || ts.isIdentifier(docArg))) {\n        const result = getDocumentReferenceFromDocumentNode(docArg, filePath, pluginInfo);\n        foundNode = result.node;\n        referencingNode = docArg;\n      } else if (typeQuery && ts.isTypeQueryNode(typeQuery)) {\n        const result = getDocumentReferenceFromTypeQuery(typeQuery, filePath, pluginInfo);\n        foundNode = result.node;\n        referencingNode = typeQuery;\n      }\n\n      if (!foundNode) {\n        warnings.push({\n          message:\n            `Could not find reference for \"${referencingNode.getText()}\".\\n` +\n            'If this is unexpected, please file an issue describing your case.',\n          file: filePath,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      if (\n        !foundNode ||\n        !ts.isCallExpression(foundNode) ||\n        (!ts.isNoSubstitutionTemplateLiteral(foundNode.arguments[0]) &&\n          !ts.isStringLiteral(foundNode.arguments[0]))\n      ) {\n        warnings.push({\n          message:\n            `The referenced document of \"${referencingNode.getText()}\" contains no document string literal.\\n` +\n            'If this is unexpected, please file an issue describing your case.',\n          file: filePath,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      const fragments: FragmentDefinitionNode[] = [];\n      const operation = foundNode.arguments[0].getText().slice(1, -1);\n      if (foundNode.arguments[1] && ts.isArrayLiteralExpression(foundNode.arguments[1])) {\n        unrollTadaFragments(foundNode.arguments[1], fragments, pluginInfo);\n      }\n\n      let document = operation;\n      for (const fragment of fragments) document += '\\n\\n' + print(fragment);\n      documents[hashArg.getText().slice(1, -1)] = document;\n    }\n\n    yield {\n      kind: 'FILE_PERSISTED',\n      filePath,\n      documents,\n      warnings,\n    };\n  }\n}\n\nexport const runPersisted = expose(_runPersisted);\n"],"names":["runPersisted","expose","async","_runPersisted","params","init","typescript","ts","projectPath","path","dirname","configPath","project","Project","tsConfigFilePath","pluginInfo","createPluginInfo","pluginConfig","sourceFiles","getSourceFiles","filter","sourceFile","filePath","resolve","getFilePath","relative","rootPath","startsWith","kind","fileCount","length","compilerNode","fileName","documents","warnings","calls","findAllPersistedCallExpressions","call","position","getFilePosition","getStart","hashArg","arguments","docArg","typeQuery","typeArguments","isStringLiteral","push","message","file","line","col","foundNode","referencingNode","isCallExpression","isIdentifier","getDocumentReferenceFromDocumentNode","node","isTypeQueryNode","getDocumentReferenceFromTypeQuery","getText","isNoSubstitutionTemplateLiteral","fragments","operation","slice","isArrayLiteralExpression","unrollTadaFragments","document","fragment","print"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA0IaA,IAAeC,GAhH5BC,gBAAgBC,cAAcC;EAC5BC,EAAK;IAAEC,YAAYC;;EAEnB,IAAMC,IAAcC,EAAKC,QAAQN,EAAOO;EACxC,IAAMC,IAAU,IAAIC,EAAQ;IAAEC,kBAAkBV,EAAOO;;EACvD,IAAMI,IAAaC,EAAiBJ,GAASR,EAAOa,cAAcT;EAGlE,IAAMU,IAAcN,EAAQO,iBAAiBC,QAAQC;IACnD,IAAMC,IAAWb,EAAKc,QAAQf,GAAaa,EAAWG;IAEtD,QADiBf,EAAKgB,SAASrB,EAAOsB,UAAUJ,GAC/BK,WAAW;AAAK;QAG7B;IACJC,MAAM;IACNC,WAAWX,EAAYY;;EAGzB,KAAK,KAAQC,cAAcV,MAAgBH,GAAa;IACtD,IAAMI,IAAWD,EAAWW;IAC5B,IAAMC,IAAoC,CAAA;IAC1C,IAAMC,IAA+B;IAErC,IAAMC,IAAQC,EAAgCf;IAC9C,KAAK,IAAMgB,KAAQF,GAAO;MACxB,IAAMG,IAAWC,EAAgBlB,GAAYgB,EAAKG;MAClD,IAAMC,IAAUJ,EAAKK,UAAU;MAC/B,IAAMC,IAASN,EAAKK,UAAU;MAC9B,IAAME,IAAYP,EAAKQ,iBAAiBR,EAAKQ,cAAc;MAC3D,KAAKJ,MAAYlC,EAAGuC,gBAAgBL,IAAU;QAC5CP,EAASa,KAAK;UACZC,SACE;UACFC,MAAM3B;UACN4B,MAAMZ,EAASY;UACfC,KAAKb,EAASa;;QAEhB;AACF,aAAO,KAAKR,MAAWC,GAAW;QAChCV,EAASa,KAAK;UACZC,SACE;UAEFC,MAAM3B;UACN4B,MAAMZ,EAASY;UACfC,KAAKb,EAASa;;QAEhB;AACF;MAEA,IAAIC,IAAsC;MAC1C,IAAIC,IAA2BhB;MAC/B,IAAIM,MAAWpC,EAAG+C,iBAAiBX,MAAWpC,EAAGgD,aAAaZ,KAAU;QAEtES,IADeI,EAAqCb,GAAQrB,GAAUP,GACnD0C;QACnBJ,IAAkBV;AACnB,aAAM,IAAIC,KAAarC,EAAGmD,gBAAgBd,IAAY;QAErDQ,IADeO,EAAkCf,GAAWtB,GAAUP,GACnD0C;QACnBJ,IAAkBT;AACpB;MAEA,KAAKQ,GAAW;QACdlB,EAASa,KAAK;UACZC,SACG,iCAAgCK,EAAgBO;UAEnDX,MAAM3B;UACN4B,MAAMZ,EAASY;UACfC,KAAKb,EAASa;;QAEhB;AACF;MAEA,KACGC,MACA7C,EAAG+C,iBAAiBF,OACnB7C,EAAGsD,gCAAgCT,EAAUV,UAAU,QACtDnC,EAAGuC,gBAAgBM,EAAUV,UAAU,KAC1C;QACAR,EAASa,KAAK;UACZC,SACG,+BAA8BK,EAAgBO;UAEjDX,MAAM3B;UACN4B,MAAMZ,EAASY;UACfC,KAAKb,EAASa;;QAEhB;AACF;MAEA,IAAMW,IAAsC;MAC5C,IAAMC,IAAYX,EAAUV,UAAU,GAAGkB,UAAUI,MAAM,IAAI;MAC7D,IAAIZ,EAAUV,UAAU,MAAMnC,EAAG0D,yBAAyBb,EAAUV,UAAU;QAC5EwB,EAAoBd,EAAUV,UAAU,IAAIoB,GAAW/C;;MAGzD,IAAIoD,IAAWJ;MACf,KAAK,IAAMK,KAAYN;QAAWK,KAAY,SAASE,MAAMD;;MAC7DnC,EAAUQ,EAAQmB,UAAUI,MAAM,IAAI,MAAMG;AAC9C;UAEM;MACJvC,MAAM;MACNN;MACAW;MACAC;;AAEJ;AACF;;"}