import { isMainThread as e, parentPort as r, Worker as n, SHARE_ENV as a } from "node:worker_threads";

var getFilePosition = (e, r, n) => {
  var a = {
    line: 1,
    col: 1,
    endLine: void 0,
    endColumn: void 0
  };
  if (r) {
    var t = e.getLineAndCharacterOfPosition(r);
    a.line = t.line + 1;
    a.col = t.character + 1;
    if (n) {
      t = e.getLineAndCharacterOfPosition(r + n - 1);
      a.endLine = t.line + 1;
      a.endColumn = t.character + 1;
    }
  }
  return a;
};

var t = r;

if (!e && !t) {
  throw new ReferenceError("Failed to receive parent message port");
}

var i = function(e) {
  e.Start = "START";
  e.Close = "CLOSE";
  e.Pull = "PULL";
  return e;
}(i || {});

var s = function(e) {
  e.Next = "NEXT";
  e.Throw = "THROW";
  e.Return = "RETURN";
  return e;
}(s || {});

var o = {
  env: a,
  stderr: !1,
  stdout: !1,
  stdin: !1
};

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

function expose(r) {
  if (e) {
    var a = function captureStack() {
      var e = new Error;
      var r = Error.prepareStackTrace;
      try {
        var n;
        Error.prepareStackTrace = (e, r) => n = r;
        Error.captureStackTrace(e);
        if (!e.stack) {
          throw e;
        }
        return n && n.slice(2) || [];
      } finally {
        Error.prepareStackTrace = r;
      }
    }()[0];
    var d = a && a.getFileName();
    if (!d) {
      throw new ReferenceError("Captured stack trace is empty");
    }
    return function main(e) {
      var r;
      var a = 0;
      return (...t) => {
        if (!r) {
          (r = new n(e, o)).unref();
        }
        var d = 0 | ++a;
        var u = [];
        var c = !1;
        var l = !1;
        var v = !1;
        var f;
        var p;
        function cleanup() {
          l = !0;
          f = void 0;
          p = void 0;
          r.removeListener("message", receiveMessage);
          r.removeListener("error", receiveError);
        }
        function sendMessage(e) {
          r.postMessage({
            id: d,
            kind: e
          });
        }
        function receiveError(e) {
          cleanup();
          u.length = 1;
          u[0] = {
            id: d,
            kind: s.Throw,
            data: e
          };
        }
        function receiveMessage(e) {
          var r = e && "object" == typeof e && "kind" in e ? e : null;
          if (!r) {
            return;
          } else if (p && r.kind === s.Throw) {
            p(r.data);
            cleanup();
          } else if (f && r.kind === s.Return) {
            f({
              done: !0,
              value: r.data
            });
            cleanup();
          } else if (f && r.kind === s.Next) {
            v = !1;
            f({
              done: !1,
              value: r.data
            });
          } else if (r.kind === s.Throw || r.kind === s.Return) {
            u.push(r);
            cleanup();
          } else if (r.kind === s.Next) {
            u.push(r);
            v = !1;
          }
        }
        return {
          async next() {
            if (!c) {
              c = !0;
              r.addListener("message", receiveMessage);
              r.addListener("error", receiveError);
              r.postMessage({
                id: d,
                kind: i.Start,
                data: t
              });
            }
            if (l && !u.length) {
              return {
                done: !0
              };
            } else if (!l && !v && u.length <= 1) {
              v = !0;
              sendMessage(i.Pull);
            }
            var e = u.shift();
            if (e && e.kind === s.Throw) {
              cleanup();
              throw e.data;
            } else if (e && e.kind === s.Return) {
              cleanup();
              return {
                value: e.data,
                done: !0
              };
            } else if (e && e.kind === s.Next) {
              return {
                value: e.data,
                done: !1
              };
            } else {
              return new Promise(((e, r) => {
                f = r => {
                  f = void 0;
                  p = void 0;
                  e(r);
                };
                p = e => {
                  f = void 0;
                  p = void 0;
                  r(e);
                };
              }));
            }
          },
          async return() {
            if (!l) {
              cleanup();
              sendMessage(i.Close);
            }
            return {
              done: !0
            };
          },
          [asyncIteratorSymbol()]() {
            return this;
          }
        };
      };
    }(d.startsWith("file://") ? new URL(d) : d);
  } else {
    t.addListener("message", (e => {
      var n = e && "object" == typeof e && "kind" in e ? e : null;
      if (n) {
        !function thread(e, r) {
          if (e.kind !== i.Start) {
            return;
          }
          var n = e.id;
          var a = r(...e.data);
          var o = !1;
          var d = !1;
          var u = !1;
          function cleanup() {
            o = !0;
            t.removeListener("message", receiveMessage);
          }
          async function sendMessage(e, r) {
            try {
              t.postMessage({
                id: n,
                kind: e,
                data: r
              });
            } catch (e) {
              cleanup();
              if (a.throw) {
                var i = await a.throw();
                if (!1 === i.done && a.return) {
                  i = await a.return();
                  sendMessage(s.Return, i.value);
                } else {
                  sendMessage(s.Return, i.value);
                }
              } else {
                sendMessage(s.Return);
              }
            }
          }
          async function receiveMessage(e) {
            var r = e && "object" == typeof e && "kind" in e ? e : null;
            var n;
            if (!r) {
              return;
            } else if (r.kind === i.Close) {
              cleanup();
              if (a.return) {
                a.return();
              }
            } else if (r.kind === i.Pull && u) {
              d = !0;
            } else if (r.kind === i.Pull) {
              for (d = u = !0; d && !o; ) {
                try {
                  if ((n = await a.next()).done) {
                    cleanup();
                    if (a.return) {
                      n = await a.return();
                    }
                    sendMessage(s.Return, n.value);
                  } else {
                    d = !1;
                    sendMessage(s.Next, n.value);
                  }
                } catch (e) {
                  cleanup();
                  sendMessage(s.Throw, e);
                }
              }
              u = !1;
            }
          }
          t.addListener("message", receiveMessage);
        }(n, r);
      }
    }));
    return r;
  }
}

export { expose as e, getFilePosition as g };
//# sourceMappingURL=index-chunk.mjs.map
