var e = require("node:worker_threads");

var r = e.parentPort;

if (!e.isMainThread && !r) {
  throw new ReferenceError("Failed to receive parent message port");
}

var n = function(e) {
  e.Start = "START";
  e.Close = "CLOSE";
  e.Pull = "PULL";
  return e;
}(n || {});

var a = function(e) {
  e.Next = "NEXT";
  e.Throw = "THROW";
  e.Return = "RETURN";
  return e;
}(a || {});

var t = {
  env: e.SHARE_ENV,
  stderr: !1,
  stdout: !1,
  stdin: !1
};

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

exports.expose = function expose(i) {
  if (e.isMainThread) {
    var s = function captureStack() {
      var e = new Error;
      var r = Error.prepareStackTrace;
      try {
        var n;
        Error.prepareStackTrace = (e, r) => n = r;
        Error.captureStackTrace(e);
        if (!e.stack) {
          throw e;
        }
        return n && n.slice(2) || [];
      } finally {
        Error.prepareStackTrace = r;
      }
    }()[0];
    var o = s && s.getFileName();
    if (!o) {
      throw new ReferenceError("Captured stack trace is empty");
    }
    return function main(r) {
      var i;
      var s = 0;
      return (...o) => {
        if (!i) {
          (i = new e.Worker(r, t)).unref();
        }
        var d = 0 | ++s;
        var u = [];
        var c = !1;
        var l = !1;
        var v = !1;
        var f;
        var p;
        function cleanup() {
          l = !0;
          f = void 0;
          p = void 0;
          i.removeListener("message", receiveMessage);
          i.removeListener("error", receiveError);
        }
        function sendMessage(e) {
          i.postMessage({
            id: d,
            kind: e
          });
        }
        function receiveError(e) {
          cleanup();
          u.length = 1;
          u[0] = {
            id: d,
            kind: a.Throw,
            data: e
          };
        }
        function receiveMessage(e) {
          var r = e && "object" == typeof e && "kind" in e ? e : null;
          if (!r) {
            return;
          } else if (p && r.kind === a.Throw) {
            p(r.data);
            cleanup();
          } else if (f && r.kind === a.Return) {
            f({
              done: !0,
              value: r.data
            });
            cleanup();
          } else if (f && r.kind === a.Next) {
            v = !1;
            f({
              done: !1,
              value: r.data
            });
          } else if (r.kind === a.Throw || r.kind === a.Return) {
            u.push(r);
            cleanup();
          } else if (r.kind === a.Next) {
            u.push(r);
            v = !1;
          }
        }
        return {
          async next() {
            if (!c) {
              c = !0;
              i.addListener("message", receiveMessage);
              i.addListener("error", receiveError);
              i.postMessage({
                id: d,
                kind: n.Start,
                data: o
              });
            }
            if (l && !u.length) {
              return {
                done: !0
              };
            } else if (!l && !v && u.length <= 1) {
              v = !0;
              sendMessage(n.Pull);
            }
            var e = u.shift();
            if (e && e.kind === a.Throw) {
              cleanup();
              throw e.data;
            } else if (e && e.kind === a.Return) {
              cleanup();
              return {
                value: e.data,
                done: !0
              };
            } else if (e && e.kind === a.Next) {
              return {
                value: e.data,
                done: !1
              };
            } else {
              return new Promise(((e, r) => {
                f = r => {
                  f = void 0;
                  p = void 0;
                  e(r);
                };
                p = e => {
                  f = void 0;
                  p = void 0;
                  r(e);
                };
              }));
            }
          },
          async return() {
            if (!l) {
              cleanup();
              sendMessage(n.Close);
            }
            return {
              done: !0
            };
          },
          [asyncIteratorSymbol()]() {
            return this;
          }
        };
      };
    }(o.startsWith("file://") ? new URL(o) : o);
  } else {
    r.addListener("message", (e => {
      var t = e && "object" == typeof e && "kind" in e ? e : null;
      if (t) {
        !function thread(e, t) {
          if (e.kind !== n.Start) {
            return;
          }
          var i = e.id;
          var s = t(...e.data);
          var o = !1;
          var d = !1;
          var u = !1;
          function cleanup() {
            o = !0;
            r.removeListener("message", receiveMessage);
          }
          async function sendMessage(e, n) {
            try {
              r.postMessage({
                id: i,
                kind: e,
                data: n
              });
            } catch (e) {
              cleanup();
              if (s.throw) {
                var t = await s.throw();
                if (!1 === t.done && s.return) {
                  t = await s.return();
                  sendMessage(a.Return, t.value);
                } else {
                  sendMessage(a.Return, t.value);
                }
              } else {
                sendMessage(a.Return);
              }
            }
          }
          async function receiveMessage(e) {
            var r = e && "object" == typeof e && "kind" in e ? e : null;
            var t;
            if (!r) {
              return;
            } else if (r.kind === n.Close) {
              cleanup();
              if (s.return) {
                s.return();
              }
            } else if (r.kind === n.Pull && u) {
              d = !0;
            } else if (r.kind === n.Pull) {
              for (d = u = !0; d && !o; ) {
                try {
                  if ((t = await s.next()).done) {
                    cleanup();
                    if (s.return) {
                      t = await s.return();
                    }
                    sendMessage(a.Return, t.value);
                  } else {
                    d = !1;
                    sendMessage(a.Next, t.value);
                  }
                } catch (e) {
                  cleanup();
                  sendMessage(a.Throw, e);
                }
              }
              u = !1;
            }
          }
          r.addListener("message", receiveMessage);
        }(t, i);
      }
    }));
    return i;
  }
};

exports.getFilePosition = (e, r, n) => {
  var a = {
    line: 1,
    col: 1,
    endLine: void 0,
    endColumn: void 0
  };
  if (r) {
    var t = e.getLineAndCharacterOfPosition(r);
    a.line = t.line + 1;
    a.col = t.character + 1;
    if (n) {
      t = e.getLineAndCharacterOfPosition(r + n - 1);
      a.endLine = t.line + 1;
      a.endColumn = t.character + 1;
    }
  }
  return a;
};
//# sourceMappingURL=index-chunk.js.map
