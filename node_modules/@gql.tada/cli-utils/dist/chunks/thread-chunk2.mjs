import * as e from "node:path";

import { TypeFormatFlags as r, ts as i, Project as a, ScriptKind as t, TypeFlags as n } from "ts-morph";

import { init as o } from "@0no-co/graphqlsp/api";

import { e as l, g as s } from "./index-chunk.mjs";

var d = l((async function* _runTurbo(r) {
  o({
    typescript: i
  });
  var l = e.dirname(r.configPath);
  var d = new a({
    tsConfigFilePath: r.configPath,
    skipAddingFilesFromTsConfig: !0
  });
  d.createSourceFile("__gql-tada-override__.d.ts", c, {
    overwrite: !0,
    scriptKind: t.TS
  });
  d.addSourceFilesFromTsConfig(r.configPath);
  var f = d.getSourceFiles().filter((i => {
    var a = e.resolve(l, i.getFilePath());
    return !e.relative(r.rootPath, a).startsWith("..");
  }));
  yield {
    kind: "FILE_COUNT",
    fileCount: f.length
  };
  var u = d.getTypeChecker().compilerObject;
  for (var {compilerNode: g} of f) {
    var m = g.fileName;
    var v = {};
    var h = [];
    var y = findAllCallExpressions(g, r.pluginConfig);
    for (var T of y) {
      var S = u.getTypeAtLocation(T);
      var C = u.getTypeAtLocation(T.arguments[0]);
      if (!S.symbol || "TadaDocumentNode" !== S.symbol.getEscapedName()) {
        var F = s(g, T.getStart());
        h.push({
          message: 'The discovered document is not of type "TadaDocumentNode".\nIf this is unexpected, please file an issue describing your case.',
          file: m,
          line: F.line,
          col: F.col
        });
        continue;
      }
      v["value" in C && "string" == typeof C.value && 0 == (C.flags & n.StringLiteral) ? JSON.stringify(C.value) : u.typeToString(C, T, p)] = u.typeToString(S, T, p);
    }
    yield {
      kind: "FILE_TURBO",
      filePath: m,
      cache: v,
      warnings: h
    };
  }
}));

var p = r.NoTruncation | r.NoTypeReduction | r.InTypeAlias | r.UseFullyQualifiedType | r.GenerateNamesForShadowedTypeParams | r.UseAliasDefinedOutsideCurrentScope | r.AllowUniqueESSymbolType | r.WriteTypeArgumentsOfSignature;

var c = "\nimport * as _gqlTada from 'gql.tada';\ndeclare module 'gql.tada' {\n  interface setupCache {\n    readonly __cacheDisabled: true;\n  }\n}\n".trim();

function findAllCallExpressions(e, r) {
  var a = [];
  var t = new Set([ r.template, "graphql", "gql" ].filter(Boolean));
  !function find(e) {
    if (i.isCallExpression(e) && t.has(e.expression.getText())) {
      a.push(e);
      return;
    } else {
      i.forEachChild(e, find);
    }
  }(e);
  return a;
}

export { d as runTurbo };
//# sourceMappingURL=thread-chunk2.mjs.map
