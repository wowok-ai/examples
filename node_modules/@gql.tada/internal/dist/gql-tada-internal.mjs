import { ModuleResolutionKind as e, JsxEmit as r, ScriptTarget as t, createSourceFile as a, createProgram as n, createModuleResolutionCache as i, resolveModuleName as o, parseConfigFileTextToJson as s } from "typescript";

import * as l from "node:path";

import u, { posix as d } from "node:path";

import { buildClientSchema as c, buildSchema as f, executeSync as p } from "graphql";

import { Kind as v, GraphQLError as m, parse as h, print as y, OperationTypeNode as E } from "@0no-co/graphql.web";

import * as k from "node:fs/promises";

import g from "node:fs/promises";

import { createRequire as N } from "node:module";

var T = {
  rootDir: "/",
  moduleResolution: e.Bundler,
  skipLibCheck: !0,
  skipDefaultLibCheck: !0,
  allowImportingTsExtensions: !0,
  allowSyntheticDefaultImports: !0,
  resolvePackageJsonExports: !0,
  resolvePackageJsonImports: !0,
  resolveJsonModule: !0,
  esModuleInterop: !0,
  jsx: r.Preserve,
  target: t.Latest,
  checkJs: !1,
  allowJs: !0,
  strict: !0,
  noEmit: !0,
  noLib: !1,
  disableReferencedProjectLoad: !0,
  disableSourceOfProjectReferenceRedirect: !0,
  disableSizeLimit: !0,
  disableSolutionSearching: !0
};

let b = class File {
  constructor(e, r) {
    this.cache = function createTargetCache() {
      return {
        [t[t.ES3]]: null,
        [t[t.ES5]]: null,
        [t[t.ES2015]]: null,
        [t[t.ES2016]]: null,
        [t[t.ES2017]]: null,
        [t[t.ES2018]]: null,
        [t[t.ES2019]]: null,
        [t[t.ES2020]]: null,
        [t[t.ES2021]]: null,
        [t[t.ES2022]]: null,
        [t[t.Latest]]: null,
        [t[t.JSON]]: null
      };
    }();
    this.name = normalize(e);
    if ("string" == typeof r) {
      this.text = r || "\n";
      this.data = null;
    } else {
      this.text = null;
      this.data = r;
    }
  }
  toSourceFile(e) {
    var r = "object" == typeof e ? e.languageVersion : e;
    return function getTargetCache(e, r) {
      return e[t[r]] || null;
    }(this.cache, r) || function setTargetCache(e, r, a) {
      e[t[r]] = a;
      return a;
    }(this.cache, r, a(this.name, this.toString(), e));
  }
  toBuffer() {
    return this.data || (this.data = (new TextEncoder).encode(this.text));
  }
  toString() {
    return this.text || (this.text = (new TextDecoder).decode(this.data));
  }
};

class Directory {
  constructor() {
    this.children = Object.create(null);
    this.files = Object.create(null);
  }
  getOrCreateDirectory(e) {
    return this.children[e] || (this.children[e] = new Directory);
  }
}

function normalize(e) {
  return d.normalize(!e.startsWith(d.sep) ? d.sep + e : e);
}

function split$1(e) {
  return e !== d.sep ? e.split(d.sep).slice(1) : [];
}

var w = d.sep;

var I = "function" == typeof require ? require.resolve : N(import.meta.url).resolve;

async function importModule(e, r) {
  var t = `${r}/package.json`;
  var a = I(t, {
    paths: [ "node_modules", ...I.paths(t) || [] ]
  });
  if (!a) {
    throw new Error(`Failed to resolve "${r}"`);
  }
  var n = u.dirname(a);
  var i = `/node_modules/${r}/`;
  await async function walk(r) {
    for (var t of await g.readdir(r)) {
      var a = u.join(r, t);
      if ((await g.stat(a)).isDirectory()) {
        await walk(a);
      } else {
        var o = u.join(u.relative(n, r), t);
        var s = await g.readFile(a, {
          encoding: "utf8"
        });
        e.writeFile(i + o.split(u.sep).join("/"), s, !1);
      }
    }
  }(n);
}

async function importLib(e) {
  var r = "typescript/package.json";
  var t = I(r, {
    paths: [ "node_modules", ...I.paths(r) || [] ]
  });
  if (!t) {
    throw new Error("Failed to resolve typescript");
  }
  var a = u.join(u.dirname(t), "lib");
  var n = (await Promise.all([ "lib.es5.d.ts", "lib.es2015.symbol.d.ts", "lib.es2015.collection.d.ts", "lib.es2015.iterable.d.ts" ].map((e => g.readFile(u.resolve(a, e), {
    encoding: "utf8"
  }))))).join("\n");
  e.writeFile(e.getDefaultLibFileName(T), n, !1);
}

async function resolveModuleFile(e) {
  var r = e.indexOf("/");
  var t = e.slice(0, r);
  var a = e.slice(r);
  var n = `${t}/package.json`;
  var i = I(n, {
    paths: [ "node_modules", ...I.paths(n) || [] ]
  });
  if (!i) {
    throw new Error(`Failed to resolve "${t}"`);
  }
  var o = u.join(u.dirname(i), a);
  return g.readFile(o, {
    encoding: "utf8"
  });
}

var A = "lib.d.ts";

var createProgram = (e, r) => n(e, T, r);

function createVirtualHost() {
  var e = i(w, normalize, T);
  var r = new Directory;
  r.files[A] = new b(A, "");
  return {
    getCanonicalFileName: normalize,
    getDefaultLibFileName: () => w + A,
    getCurrentDirectory: () => w,
    getNewLine: () => "\n",
    getModuleResolutionCache: () => e,
    useCaseSensitiveFileNames: () => !0,
    fileExists(e) {
      var t = split$1(normalize(e));
      var a = r;
      for (var n = 0; n < t.length - 1; n++) {
        if (!(a = a.children[t[n]])) {
          return !1;
        }
      }
      return !!a.files[t[t.length - 1]];
    },
    directoryExists(e) {
      var t = split$1(normalize(e));
      if (!t.length) {
        return !0;
      }
      var a = r;
      for (var n = 0; n < t.length - 1; n++) {
        if (!(a = a.children[t[n]])) {
          return !1;
        }
      }
      return !!a.children[t[t.length - 1]];
    },
    writeFile(e, t) {
      var a = normalize(e);
      var n = split$1(a);
      var i = r;
      for (var o = 0; o < n.length - 1; o++) {
        i = i.getOrCreateDirectory(n[o]);
      }
      i.files[n[n.length - 1]] = new b(a, t);
    },
    getDirectories(e) {
      var t = split$1(normalize(e));
      var a = r;
      for (var n = 0; n < t.length; n++) {
        if (!(a = a.children[t[n]])) {
          return [];
        }
      }
      return Object.keys(a.children);
    },
    readFile(e) {
      var t = split$1(normalize(e));
      var a = r;
      for (var n = 0; n < t.length - 1; n++) {
        if (!(a = a.children[t[n]])) {
          return;
        }
      }
      var i = a.files[t[t.length - 1]];
      return i && i.toString();
    },
    getSourceFile(e, t) {
      var a = split$1(normalize(e));
      var n = r;
      for (var i = 0; i < a.length - 1; i++) {
        if (!(n = n.children[a[i]])) {
          return;
        }
      }
      var o = n.files[a[a.length - 1]];
      return o && o.toSourceFile(t);
    },
    resolveModuleNames(r, t) {
      var a = [];
      for (var n of r) {
        var i = o(n, t, T, this, e);
        a.push(i.resolvedModule);
      }
      return a;
    }
  };
}

var teardownPlaceholder = () => {};

var S = teardownPlaceholder;

function start(e) {
  return {
    tag: 0,
    0: e
  };
}

function push(e) {
  return {
    tag: 1,
    0: e
  };
}

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

var identity = e => e;

function filter(e) {
  return r => t => {
    var a = S;
    r((r => {
      if (0 === r) {
        t(0);
      } else if (0 === r.tag) {
        a = r[0];
        t(r);
      } else if (!e(r[0])) {
        a(0);
      } else {
        t(r);
      }
    }));
  };
}

function map(e) {
  return r => t => r((r => {
    if (0 === r || 0 === r.tag) {
      t(r);
    } else {
      t(push(e(r[0])));
    }
  }));
}

function mergeMap(e) {
  return r => t => {
    var a = [];
    var n = S;
    var i = !1;
    var o = !1;
    r((r => {
      if (o) {} else if (0 === r) {
        o = !0;
        if (!a.length) {
          t(0);
        }
      } else if (0 === r.tag) {
        n = r[0];
      } else {
        i = !1;
        !function applyInnerSource(e) {
          var r = S;
          e((e => {
            if (0 === e) {
              if (a.length) {
                var s = a.indexOf(r);
                if (s > -1) {
                  (a = a.slice()).splice(s, 1);
                }
                if (!a.length) {
                  if (o) {
                    t(0);
                  } else if (!i) {
                    i = !0;
                    n(0);
                  }
                }
              }
            } else if (0 === e.tag) {
              a.push(r = e[0]);
              r(0);
            } else if (a.length) {
              t(e);
              r(0);
            }
          }));
        }(e(r[0]));
        if (!i) {
          i = !0;
          n(0);
        }
      }
    }));
    t(start((e => {
      if (1 === e) {
        if (!o) {
          o = !0;
          n(1);
        }
        for (var r = 0, t = a, s = a.length; r < s; r++) {
          t[r](1);
        }
        a.length = 0;
      } else {
        if (!o && !i) {
          i = !0;
          n(0);
        } else {
          i = !1;
        }
        for (var l = 0, u = a, d = a.length; l < d; l++) {
          u[l](0);
        }
      }
    })));
  };
}

function merge(e) {
  return function mergeAll(e) {
    return mergeMap(identity)(e);
  }(O(e));
}

function onEnd(e) {
  return r => t => {
    var a = !1;
    r((r => {
      if (a) {} else if (0 === r) {
        a = !0;
        t(0);
        e();
      } else if (0 === r.tag) {
        var n = r[0];
        t(start((r => {
          if (1 === r) {
            a = !0;
            n(1);
            e();
          } else {
            n(r);
          }
        })));
      } else {
        t(r);
      }
    }));
  };
}

function onPush(e) {
  return r => t => {
    var a = !1;
    r((r => {
      if (a) {} else if (0 === r) {
        a = !0;
        t(0);
      } else if (0 === r.tag) {
        var n = r[0];
        t(start((e => {
          if (1 === e) {
            a = !0;
          }
          n(e);
        })));
      } else {
        e(r[0]);
        t(r);
      }
    }));
  };
}

function onStart(e) {
  return r => t => r((r => {
    if (0 === r) {
      t(0);
    } else if (0 === r.tag) {
      t(r);
      e();
    } else {
      t(r);
    }
  }));
}

function share(e) {
  var r = [];
  var t = S;
  var a = !1;
  return n => {
    r.push(n);
    if (1 === r.length) {
      e((e => {
        if (0 === e) {
          for (var n = 0, i = r, o = r.length; n < o; n++) {
            i[n](0);
          }
          r.length = 0;
        } else if (0 === e.tag) {
          t = e[0];
        } else {
          a = !1;
          for (var s = 0, l = r, u = r.length; s < u; s++) {
            l[s](e);
          }
        }
      }));
    }
    n(start((e => {
      if (1 === e) {
        var i = r.indexOf(n);
        if (i > -1) {
          (r = r.slice()).splice(i, 1);
        }
        if (!r.length) {
          t(1);
        }
      } else if (!a) {
        a = !0;
        t(0);
      }
    })));
  };
}

function switchMap(e) {
  return r => t => {
    var a = S;
    var n = S;
    var i = !1;
    var o = !1;
    var s = !1;
    var l = !1;
    r((r => {
      if (l) {} else if (0 === r) {
        l = !0;
        if (!s) {
          t(0);
        }
      } else if (0 === r.tag) {
        a = r[0];
      } else {
        if (s) {
          n(1);
          n = S;
        }
        if (!i) {
          i = !0;
          a(0);
        } else {
          i = !1;
        }
        !function applyInnerSource(e) {
          s = !0;
          e((e => {
            if (!s) {} else if (0 === e) {
              s = !1;
              if (l) {
                t(0);
              } else if (!i) {
                i = !0;
                a(0);
              }
            } else if (0 === e.tag) {
              o = !1;
              (n = e[0])(0);
            } else {
              t(e);
              if (!o) {
                n(0);
              } else {
                o = !1;
              }
            }
          }));
        }(e(r[0]));
      }
    }));
    t(start((e => {
      if (1 === e) {
        if (!l) {
          l = !0;
          a(1);
        }
        if (s) {
          s = !1;
          n(1);
        }
      } else {
        if (!l && !i) {
          i = !0;
          a(0);
        }
        if (s && !o) {
          o = !0;
          n(0);
        }
      }
    })));
  };
}

function take(e) {
  return r => t => {
    var a = S;
    var n = !1;
    var i = 0;
    r((r => {
      if (n) {} else if (0 === r) {
        n = !0;
        t(0);
      } else if (0 === r.tag) {
        if (e <= 0) {
          n = !0;
          t(0);
          r[0](1);
        } else {
          a = r[0];
        }
      } else if (i++ < e) {
        t(r);
        if (!n && i >= e) {
          n = !0;
          t(0);
          a(1);
        }
      } else {
        t(r);
      }
    }));
    t(start((r => {
      if (1 === r && !n) {
        n = !0;
        a(1);
      } else if (0 === r && !n && i < e) {
        a(0);
      }
    })));
  };
}

function takeUntil(e) {
  return r => t => {
    var a = S;
    var n = S;
    var i = !1;
    r((r => {
      if (i) {} else if (0 === r) {
        i = !0;
        n(1);
        t(0);
      } else if (0 === r.tag) {
        a = r[0];
        e((e => {
          if (0 === e) {} else if (0 === e.tag) {
            (n = e[0])(0);
          } else {
            i = !0;
            n(1);
            a(1);
            t(0);
          }
        }));
      } else {
        t(r);
      }
    }));
    t(start((e => {
      if (1 === e && !i) {
        i = !0;
        a(1);
        n(1);
      } else if (!i) {
        a(0);
      }
    })));
  };
}

function takeWhile(e, r) {
  return t => a => {
    var n = S;
    var i = !1;
    t((t => {
      if (i) {} else if (0 === t) {
        i = !0;
        a(0);
      } else if (0 === t.tag) {
        n = t[0];
        a(t);
      } else if (!e(t[0])) {
        i = !0;
        if (r) {
          a(t);
        }
        a(0);
        n(1);
      } else {
        a(t);
      }
    }));
  };
}

function fromAsyncIterable(e) {
  return r => {
    var t = e[asyncIteratorSymbol()] && e[asyncIteratorSymbol()]() || e;
    var a = !1;
    var n = !1;
    var i = !1;
    var o;
    r(start((async e => {
      if (1 === e) {
        a = !0;
        if (t.return) {
          t.return();
        }
      } else if (n) {
        i = !0;
      } else {
        for (i = n = !0; i && !a; ) {
          if ((o = await t.next()).done) {
            a = !0;
            if (t.return) {
              await t.return();
            }
            r(0);
          } else {
            try {
              i = !1;
              r(push(o.value));
            } catch (e) {
              if (t.throw) {
                if (a = !!(await t.throw(e)).done) {
                  r(0);
                }
              } else {
                throw e;
              }
            }
          }
        }
        n = !1;
      }
    })));
  };
}

var O = function fromIterable(e) {
  if (e[Symbol.asyncIterator]) {
    return fromAsyncIterable(e);
  }
  return r => {
    var t = e[Symbol.iterator]();
    var a = !1;
    var n = !1;
    var i = !1;
    var o;
    r(start((e => {
      if (1 === e) {
        a = !0;
        if (t.return) {
          t.return();
        }
      } else if (n) {
        i = !0;
      } else {
        for (i = n = !0; i && !a; ) {
          if ((o = t.next()).done) {
            a = !0;
            if (t.return) {
              t.return();
            }
            r(0);
          } else {
            try {
              i = !1;
              r(push(o.value));
            } catch (e) {
              if (t.throw) {
                if (a = !!t.throw(e).done) {
                  r(0);
                }
              } else {
                throw e;
              }
            }
          }
        }
        n = !1;
      }
    })));
  };
};

function fromValue(e) {
  return r => {
    var t = !1;
    r(start((a => {
      if (1 === a) {
        t = !0;
      } else if (!t) {
        t = !0;
        r(push(e));
        r(0);
      }
    })));
  };
}

function make(e) {
  return r => {
    var t = !1;
    var a = e({
      next(e) {
        if (!t) {
          r(push(e));
        }
      },
      complete() {
        if (!t) {
          t = !0;
          r(0);
        }
      }
    });
    r(start((e => {
      if (1 === e && !t) {
        t = !0;
        a();
      }
    })));
  };
}

function makeSubject() {
  var e;
  var r;
  return {
    source: share(make((t => {
      e = t.next;
      r = t.complete;
      return teardownPlaceholder;
    }))),
    next(r) {
      if (e) {
        e(r);
      }
    },
    complete() {
      if (r) {
        r();
      }
    }
  };
}

function subscribe(e) {
  return r => {
    var t = S;
    var a = !1;
    r((r => {
      if (0 === r) {
        a = !0;
      } else if (0 === r.tag) {
        (t = r[0])(0);
      } else if (!a) {
        e(r[0]);
        t(0);
      }
    }));
    return {
      unsubscribe() {
        if (!a) {
          a = !0;
          t(1);
        }
      }
    };
  };
}

function toPromise(e) {
  return new Promise((r => {
    var t = S;
    var a;
    e((e => {
      if (0 === e) {
        Promise.resolve(a).then(r);
      } else if (0 === e.tag) {
        (t = e[0])(0);
      } else {
        a = e[0];
        t(0);
      }
    }));
  }));
}

var rehydrateGraphQlError = e => {
  if (e && e.message && (e.extensions || "GraphQLError" === e.name)) {
    return e;
  } else if ("object" == typeof e && e.message) {
    return new m(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});
  } else {
    return new m(e);
  }
};

class CombinedError extends Error {
  constructor(e) {
    var r = (e.graphQLErrors || []).map(rehydrateGraphQlError);
    var t = ((e, r) => {
      var t = "";
      if (e) {
        return `[Network] ${e.message}`;
      }
      if (r) {
        for (var a of r) {
          if (t) {
            t += "\n";
          }
          t += `[GraphQL] ${a.message}`;
        }
      }
      return t;
    })(e.networkError, r);
    super(t);
    this.name = "CombinedError";
    this.message = t;
    this.graphQLErrors = r;
    this.networkError = e.networkError;
    this.response = e.response;
  }
  toString() {
    return this.message;
  }
}

var phash = (e, r) => {
  var t = 0 | (r || 5381);
  for (var a = 0, n = 0 | e.length; a < n; a++) {
    t = (t << 5) + t + e.charCodeAt(a);
  }
  return t;
};

var x = new Set;

var D = new WeakMap;

var stringify = e => {
  if (null === e || x.has(e)) {
    return "null";
  } else if ("object" != typeof e) {
    return JSON.stringify(e) || "";
  } else if (e.toJSON) {
    return stringify(e.toJSON());
  } else if (Array.isArray(e)) {
    var r = "[";
    for (var t of e) {
      if (r.length > 1) {
        r += ",";
      }
      r += stringify(t) || "null";
    }
    return r + "]";
  } else if (L !== NoopConstructor && e instanceof L || M !== NoopConstructor && e instanceof M) {
    return "null";
  }
  var a = Object.keys(e).sort();
  if (!a.length && e.constructor && Object.getPrototypeOf(e).constructor !== Object.prototype.constructor) {
    var n = D.get(e) || Math.random().toString(36).slice(2);
    D.set(e, n);
    return stringify({
      __key: n
    });
  }
  x.add(e);
  var i = "{";
  for (var o of a) {
    var s = stringify(e[o]);
    if (s) {
      if (i.length > 1) {
        i += ",";
      }
      i += stringify(o) + ":" + s;
    }
  }
  x.delete(e);
  return i + "}";
};

var extract = (e, r, t) => {
  if (null == t || "object" != typeof t || t.toJSON || x.has(t)) {} else if (Array.isArray(t)) {
    for (var a = 0, n = t.length; a < n; a++) {
      extract(e, `${r}.${a}`, t[a]);
    }
  } else if (t instanceof L || t instanceof M) {
    e.set(r, t);
  } else {
    x.add(t);
    for (var i of Object.keys(t)) {
      extract(e, `${r}.${i}`, t[i]);
    }
  }
};

var stringifyVariables = e => {
  x.clear();
  return stringify(e);
};

class NoopConstructor {}

var L = "undefined" != typeof File ? File : NoopConstructor;

var M = "undefined" != typeof Blob ? Blob : NoopConstructor;

var _ = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;

var F = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;

var replaceOutsideStrings = (e, r) => r % 2 == 0 ? e.replace(F, "\n") : e;

var sanitizeDocument = e => e.split(_).map(replaceOutsideStrings).join("").trim();

var C = new Map;

var R = new Map;

var stringifyDocument = e => {
  var r;
  if ("string" == typeof e) {
    r = sanitizeDocument(e);
  } else if (e.loc && R.get(e.__key) === e) {
    r = e.loc.source.body;
  } else {
    r = C.get(e) || sanitizeDocument(y(e));
    C.set(e, r);
  }
  if ("string" != typeof e && !e.loc) {
    e.loc = {
      start: 0,
      end: r.length,
      source: {
        body: r,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return r;
};

var hashDocument = e => {
  var r = phash(stringifyDocument(e));
  if (e.definitions) {
    var t = getOperationName(e);
    if (t) {
      r = phash(`\n# ${t}`, r);
    }
  }
  return r;
};

var createRequest = (e, r, t) => {
  var a = r || {};
  var n = (e => {
    var r;
    var t;
    if ("string" == typeof e) {
      r = hashDocument(e);
      t = R.get(r) || h(e, {
        noLocation: !0
      });
    } else {
      r = e.__key || hashDocument(e);
      t = R.get(r) || e;
    }
    if (!t.loc) {
      stringifyDocument(t);
    }
    t.__key = r;
    R.set(r, t);
    return t;
  })(e);
  var i = stringifyVariables(a);
  var o = n.__key;
  if ("{}" !== i) {
    o = phash(i, o);
  }
  return {
    key: o,
    query: n,
    variables: a,
    extensions: t
  };
};

var getOperationName = e => {
  for (var r of e.definitions) {
    if (r.kind === v.OPERATION_DEFINITION) {
      return r.name ? r.name.value : void 0;
    }
  }
};

var makeResult = (e, r, t) => {
  if (!("data" in r || "errors" in r && Array.isArray(r.errors))) {
    throw new Error("No Content");
  }
  var a = "subscription" === e.kind;
  return {
    operation: e,
    data: r.data,
    error: Array.isArray(r.errors) ? new CombinedError({
      graphQLErrors: r.errors,
      response: t
    }) : void 0,
    extensions: r.extensions ? {
      ...r.extensions
    } : void 0,
    hasNext: null == r.hasNext ? a : r.hasNext,
    stale: !1
  };
};

var deepMerge = (e, r) => {
  if ("object" == typeof e && null != e) {
    if (!e.constructor || e.constructor === Object || Array.isArray(e)) {
      e = Array.isArray(e) ? [ ...e ] : {
        ...e
      };
      for (var t of Object.keys(r)) {
        e[t] = deepMerge(e[t], r[t]);
      }
      return e;
    }
  }
  return r;
};

var mergeResultPatch = (e, r, t, a) => {
  var n = e.error ? e.error.graphQLErrors : [];
  var i = !!e.extensions || !!(r.payload || r).extensions;
  var o = {
    ...e.extensions,
    ...(r.payload || r).extensions
  };
  var s = r.incremental;
  if ("path" in r) {
    s = [ r ];
  }
  var l = {
    data: e.data
  };
  if (s) {
    var _loop = function(e) {
      if (Array.isArray(e.errors)) {
        n.push(...e.errors);
      }
      if (e.extensions) {
        Object.assign(o, e.extensions);
        i = !0;
      }
      var r = "data";
      var t = l;
      var s = [];
      if (e.path) {
        s = e.path;
      } else if (a) {
        var u = a.find((r => r.id === e.id));
        if (e.subPath) {
          s = [ ...u.path, ...e.subPath ];
        } else {
          s = u.path;
        }
      }
      for (var d = 0, c = s.length; d < c; r = s[d++]) {
        t = t[r] = Array.isArray(t[r]) ? [ ...t[r] ] : {
          ...t[r]
        };
      }
      if (e.items) {
        var f = +r >= 0 ? r : 0;
        for (var p = 0, v = e.items.length; p < v; p++) {
          t[f + p] = deepMerge(t[f + p], e.items[p]);
        }
      } else if (void 0 !== e.data) {
        t[r] = deepMerge(t[r], e.data);
      }
    };
    for (var u of s) {
      _loop(u);
    }
  } else {
    l.data = (r.payload || r).data || e.data;
    n = r.errors || r.payload && r.payload.errors || n;
  }
  return {
    operation: e.operation,
    data: l.data,
    error: n.length ? new CombinedError({
      graphQLErrors: n,
      response: t
    }) : void 0,
    extensions: i ? o : void 0,
    hasNext: null != r.hasNext ? r.hasNext : e.hasNext,
    stale: !1
  };
};

var makeErrorResult = (e, r, t) => ({
  operation: e,
  data: void 0,
  error: new CombinedError({
    networkError: r,
    response: t
  }),
  extensions: void 0,
  hasNext: !1,
  stale: !1
});

var splitOutSearchParams = e => {
  var r = e.indexOf("?");
  return r > -1 ? [ e.slice(0, r), new URLSearchParams(e.slice(r + 1)) ] : [ e, new URLSearchParams ];
};

var makeFetchOptions = (e, r) => {
  var t = {
    accept: "subscription" === e.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a = ("function" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions) || {};
  if (a.headers) {
    if ((e => "has" in e && !Object.keys(e).length)(a.headers)) {
      a.headers.forEach(((e, r) => {
        t[r] = e;
      }));
    } else if (Array.isArray(a.headers)) {
      a.headers.forEach(((e, r) => {
        if (Array.isArray(e)) {
          if (t[e[0]]) {
            t[e[0]] = `${t[e[0]]},${e[1]}`;
          } else {
            t[e[0]] = e[1];
          }
        } else {
          t[r] = e;
        }
      }));
    } else {
      for (var n in a.headers) {
        t[n.toLowerCase()] = a.headers[n];
      }
    }
  }
  var i = ((e, r) => {
    if (r && ("query" !== e.kind || !e.context.preferGetMethod)) {
      var t = stringifyVariables(r);
      var a = (e => {
        var r = new Map;
        if (L !== NoopConstructor || M !== NoopConstructor) {
          x.clear();
          extract(r, "variables", e);
        }
        return r;
      })(r.variables);
      if (a.size) {
        var n = new FormData;
        n.append("operations", t);
        n.append("map", stringifyVariables({
          ...[ ...a.keys() ].map((e => [ e ]))
        }));
        var i = 0;
        for (var o of a.values()) {
          n.append("" + i++, o);
        }
        return n;
      }
      return t;
    }
  })(e, r);
  if ("string" == typeof i && !t["content-type"]) {
    t["content-type"] = "application/json";
  }
  return {
    ...a,
    method: i ? "POST" : "GET",
    body: i,
    headers: t
  };
};

var P = "undefined" != typeof TextDecoder ? new TextDecoder : null;

var $ = /boundary="?([^=";]+)"?/i;

var j = /data: ?([^\n]+)/;

var toString = e => "Buffer" === e.constructor.name ? e.toString() : P.decode(e);

async function* streamBody(e) {
  if (e.body[Symbol.asyncIterator]) {
    for await (var r of e.body) {
      yield toString(r);
    }
  } else {
    var t = e.body.getReader();
    var a;
    try {
      while (!(a = await t.read()).done) {
        yield toString(a.value);
      }
    } finally {
      t.cancel();
    }
  }
}

async function* split(e, r) {
  var t = "";
  var a;
  for await (var n of e) {
    t += n;
    while ((a = t.indexOf(r)) > -1) {
      yield t.slice(0, a);
      t = t.slice(a + r.length);
    }
  }
}

function makeFetchSource(e, r, t) {
  var a;
  if ("undefined" != typeof AbortController) {
    t.signal = (a = new AbortController).signal;
  }
  return onEnd((() => {
    if (a) {
      a.abort();
    }
  }))(filter((e => !!e))(fromAsyncIterable(async function* fetchOperation(e, r, t) {
    var a = !0;
    var n = null;
    var i;
    try {
      yield await Promise.resolve();
      var o = (i = await (e.context.fetch || fetch)(r, t)).headers.get("Content-Type") || "";
      var s;
      if (/multipart\/mixed/i.test(o)) {
        s = async function* parseMultipartMixed(e, r) {
          var t = e.match($);
          var a = "--" + (t ? t[1] : "-");
          var n = !0;
          var i;
          for await (var o of split(streamBody(r), "\r\n" + a)) {
            if (n) {
              n = !1;
              var s = o.indexOf(a);
              if (s > -1) {
                o = o.slice(s + a.length);
              } else {
                continue;
              }
            }
            try {
              yield i = JSON.parse(o.slice(o.indexOf("\r\n\r\n") + 4));
            } catch (e) {
              if (!i) {
                throw e;
              }
            }
            if (i && !1 === i.hasNext) {
              break;
            }
          }
          if (i && !1 !== i.hasNext) {
            yield {
              hasNext: !1
            };
          }
        }(o, i);
      } else if (/text\/event-stream/i.test(o)) {
        s = async function* parseEventStream(e) {
          var r;
          for await (var t of split(streamBody(e), "\n\n")) {
            var a = t.match(j);
            if (a) {
              var n = a[1];
              try {
                yield r = JSON.parse(n);
              } catch (e) {
                if (!r) {
                  throw e;
                }
              }
              if (r && !1 === r.hasNext) {
                break;
              }
            }
          }
          if (r && !1 !== r.hasNext) {
            yield {
              hasNext: !1
            };
          }
        }(i);
      } else if (!/text\//i.test(o)) {
        s = async function* parseJSON(e) {
          yield JSON.parse(await e.text());
        }(i);
      } else {
        s = async function* parseMaybeJSON(e) {
          var r = await e.text();
          try {
            var t = JSON.parse(r);
            if ("production" !== process.env.NODE_ENV) {
              console.warn('Found response with content-type "text/plain" but it had a valid "application/json" response.');
            }
            yield t;
          } catch (e) {
            throw new Error(r);
          }
        }(i);
      }
      var l;
      for await (var u of s) {
        if (u.pending && !n) {
          l = u.pending;
        } else if (u.pending) {
          l = [ ...l, ...u.pending ];
        }
        n = n ? mergeResultPatch(n, u, i, l) : makeResult(e, u, i);
        a = !1;
        yield n;
        a = !0;
      }
      if (!n) {
        yield n = makeResult(e, {}, i);
      }
    } catch (r) {
      if (!a) {
        throw r;
      }
      yield makeErrorResult(e, i && (i.status < 200 || i.status >= 300) && i.statusText ? new Error(i.statusText) : r, i);
    }
  }(e, r, t))));
}

var maskTypename = (e, r) => {
  if (!e || "object" != typeof e) {
    return e;
  } else if (Array.isArray(e)) {
    return e.map((e => maskTypename(e)));
  } else if (e && "object" == typeof e && (r || "__typename" in e)) {
    var t = {};
    for (var a in e) {
      if ("__typename" === a) {
        Object.defineProperty(t, "__typename", {
          enumerable: !1,
          value: e.__typename
        });
      } else {
        t[a] = maskTypename(e[a]);
      }
    }
    return t;
  } else {
    return e;
  }
};

function withPromise(e) {
  var source$ = r => e(r);
  source$.toPromise = () => toPromise(take(1)(filter((e => !e.stale && !e.hasNext))(source$)));
  source$.then = (e, r) => source$.toPromise().then(e, r);
  source$.subscribe = e => subscribe(e)(source$);
  return source$;
}

function makeOperation(e, r, t) {
  return {
    ...r,
    kind: e,
    context: r.context ? {
      ...r.context,
      ...t
    } : t || r.context
  };
}

var noop = () => {};

var fetchExchange = ({forward: e, dispatchDebug: r}) => t => {
  var a = mergeMap((e => {
    var a = function makeFetchBody(e) {
      var r = {
        query: void 0,
        documentId: void 0,
        operationName: getOperationName(e.query),
        variables: e.variables || void 0,
        extensions: e.extensions
      };
      if ("documentId" in e.query && e.query.documentId && (!e.query.definitions || !e.query.definitions.length)) {
        r.documentId = e.query.documentId;
      } else if (!e.extensions || !e.extensions.persistedQuery || e.extensions.persistedQuery.miss) {
        r.query = stringifyDocument(e.query);
      }
      return r;
    }(e);
    var n = ((e, r) => {
      var t = "query" === e.kind && e.context.preferGetMethod;
      if (!t || !r) {
        return e.context.url;
      }
      var a = splitOutSearchParams(e.context.url);
      for (var n in r) {
        var i = r[n];
        if (i) {
          a[1].set(n, "object" == typeof i ? stringifyVariables(i) : i);
        }
      }
      var o = a.join("?");
      if (o.length > 2047 && "force" !== t) {
        e.context.preferGetMethod = !1;
        return e.context.url;
      }
      return o;
    })(e, a);
    var i = makeFetchOptions(e, a);
    "production" !== process.env.NODE_ENV && r({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e,
      data: {
        url: n,
        fetchOptions: i
      },
      source: "fetchExchange"
    });
    var o = takeUntil(filter((r => "teardown" === r.kind && r.key === e.key))(t))(makeFetchSource(e, n, i));
    if ("production" !== process.env.NODE_ENV) {
      return onPush((t => {
        var a = !t.data ? t.error : void 0;
        "production" !== process.env.NODE_ENV && r({
          type: a ? "fetchError" : "fetchSuccess",
          message: `A ${a ? "failed" : "successful"} fetch response has been returned.`,
          operation: e,
          data: {
            url: n,
            fetchOptions: i,
            value: a || t
          },
          source: "fetchExchange"
        });
      }))(o);
    }
    return o;
  }))(filter((e => "teardown" !== e.kind && ("subscription" !== e.kind || !!e.context.fetchSubscriptions)))(t));
  return merge([ a, e(filter((e => "teardown" === e.kind || "subscription" === e.kind && !e.context.fetchSubscriptions))(t)) ]);
};

var fallbackExchange = ({dispatchDebug: e}) => r => {
  if ("production" !== process.env.NODE_ENV) {
    r = onPush((r => {
      if ("teardown" !== r.kind && "production" !== process.env.NODE_ENV) {
        var t = `No exchange has handled operations of kind "${r.kind}". Check whether you've added an exchange responsible for these operations.`;
        "production" !== process.env.NODE_ENV && e({
          type: "fallbackCatch",
          message: t,
          operation: r,
          source: "fallbackExchange"
        });
        console.warn(t);
      }
    }))(r);
  }
  return filter((e => !1))(r);
};

var q = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = 0;
  var t = new Map;
  var a = new Map;
  var n = new Set;
  var i = [];
  var o = {
    url: e.url,
    fetchSubscriptions: e.fetchSubscriptions,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    preferGetMethod: e.preferGetMethod,
    requestPolicy: e.requestPolicy || "cache-first"
  };
  var s = makeSubject();
  function nextOperation(e) {
    if ("mutation" === e.kind || "teardown" === e.kind || !n.has(e.key)) {
      if ("teardown" === e.kind) {
        n.delete(e.key);
      } else if ("mutation" !== e.kind) {
        n.add(e.key);
      }
      s.next(e);
    }
  }
  var l = !1;
  function dispatchOperation(e) {
    if (e) {
      nextOperation(e);
    }
    if (!l) {
      l = !0;
      while (l && (e = i.shift())) {
        nextOperation(e);
      }
      l = !1;
    }
  }
  var makeResultSource = r => {
    var o = takeUntil(filter((e => "teardown" === e.kind && e.key === r.key))(s.source))(filter((e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance)))(h));
    if (e.maskTypename) {
      o = map((e => ({
        ...e,
        data: maskTypename(e.data, !0)
      })))(o);
    }
    if ("query" !== r.kind) {
      o = takeWhile((e => !!e.hasNext), !0)(o);
    } else {
      o = switchMap((e => {
        var t = fromValue(e);
        return e.stale || e.hasNext ? t : merge([ t, map((() => {
          e.stale = !0;
          return e;
        }))(take(1)(filter((e => e.key === r.key))(s.source))) ]);
      }))(o);
    }
    if ("mutation" !== r.kind) {
      o = onEnd((() => {
        n.delete(r.key);
        t.delete(r.key);
        a.delete(r.key);
        l = !1;
        for (var e = i.length - 1; e >= 0; e--) {
          if (i[e].key === r.key) {
            i.splice(e, 1);
          }
        }
        nextOperation(makeOperation("teardown", r, r.context));
      }))(onPush((e => {
        if (e.stale) {
          for (var a of i) {
            if (a.key === e.operation.key) {
              n.delete(a.key);
              break;
            }
          }
        } else if (!e.hasNext) {
          n.delete(r.key);
        }
        t.set(r.key, e);
      }))(o));
    } else {
      o = onStart((() => {
        nextOperation(r);
      }))(o);
    }
    return share(o);
  };
  var u = this instanceof Client ? this : Object.create(Client.prototype);
  var d = Object.assign(u, {
    suspense: !!e.suspense,
    operations$: s.source,
    reexecuteOperation(e) {
      if ("teardown" === e.kind) {
        dispatchOperation(e);
      } else if ("mutation" === e.kind || a.has(e.key)) {
        var r = !1;
        for (var t = 0; t < i.length; t++) {
          r = r || i[t].key === e.key;
        }
        if (!r) {
          n.delete(e.key);
        }
        i.push(e);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e, t, a) {
      if (!a) {
        a = {};
      }
      var n;
      if ("production" !== process.env.NODE_ENV && "teardown" !== e && (n = (e => {
        for (var r of e.definitions) {
          if (r.kind === v.OPERATION_DEFINITION) {
            return r.operation;
          }
        }
      })(t.query)) !== e) {
        throw new Error(`Expected operation of type "${e}" but found "${n}"`);
      }
      return makeOperation(e, t, {
        _instance: "mutation" === e ? r = r + 1 | 0 : void 0,
        ...o,
        ...a,
        requestPolicy: a.requestPolicy || o.requestPolicy,
        suspense: a.suspense || !1 !== a.suspense && d.suspense
      });
    },
    executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return withPromise(makeResultSource(e));
      }
      return withPromise(function lazy(e) {
        return r => e()(r);
      }((() => {
        var r = a.get(e.key);
        if (!r) {
          a.set(e.key, r = makeResultSource(e));
        }
        r = onStart((() => {
          dispatchOperation(e);
        }))(r);
        var n = t.get(e.key);
        if ("query" === e.kind && n && (n.stale || n.hasNext)) {
          return switchMap(fromValue)(merge([ r, filter((r => r === t.get(e.key)))(fromValue(n)) ]));
        } else {
          return r;
        }
      })));
    },
    executeQuery(e, r) {
      var t = d.createRequestOperation("query", e, r);
      return d.executeRequestOperation(t);
    },
    executeSubscription(e, r) {
      var t = d.createRequestOperation("subscription", e, r);
      return d.executeRequestOperation(t);
    },
    executeMutation(e, r) {
      var t = d.createRequestOperation("mutation", e, r);
      return d.executeRequestOperation(t);
    },
    readQuery(e, r, t) {
      var a = null;
      subscribe((e => {
        a = e;
      }))(d.query(e, r, t)).unsubscribe();
      return a;
    },
    query: (e, r, t) => d.executeQuery(createRequest(e, r), t),
    subscription: (e, r, t) => d.executeSubscription(createRequest(e, r), t),
    mutation: (e, r, t) => d.executeMutation(createRequest(e, r), t)
  });
  var c = noop;
  if ("production" !== process.env.NODE_ENV) {
    var {next: f, source: p} = makeSubject();
    d.subscribeToDebugTarget = e => subscribe(e)(p);
    c = f;
  }
  var m = (e => ({client: r, forward: t, dispatchDebug: a}) => e.reduceRight(((e, t) => {
    var n = !1;
    return t({
      client: r,
      forward(r) {
        if ("production" !== process.env.NODE_ENV) {
          if (n) {
            throw new Error("forward() must only be called once in each Exchange.");
          }
          n = !0;
        }
        return share(e(share(r)));
      },
      dispatchDebug(e) {
        "production" !== process.env.NODE_ENV && a({
          timestamp: Date.now(),
          source: t.name,
          ...e
        });
      }
    });
  }), t))(e.exchanges);
  var h = share(m({
    client: d,
    dispatchDebug: c,
    forward: fallbackExchange({
      dispatchDebug: c
    })
  })(s.source));
  !function publish(e) {
    subscribe((e => {}))(e);
  }(h);
  return d;
};

var _hasField = (e, r) => !!e && !!e.fields && e.fields.some((e => e.name === r));

var _supportsDeprecatedArgumentsArg = e => {
  var r = e && e.fields && e.fields.find((e => "args" === e.name));
  return !!(r && r.args && r.args.find((e => "includeDeprecated" === e.name)));
};

var toSupportedFeatures = e => ({
  directiveIsRepeatable: _hasField(e.directive, "isRepeatable"),
  specifiedByURL: _hasField(e.type, "specifiedByURL"),
  inputValueDeprecation: _hasField(e.inputValue, "isDeprecated"),
  directiveArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(e.directive),
  fieldArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(e.field)
});

var V;

var U;

var makeIntrospectionQuery = e => {
  if (V && U === e) {
    return V;
  } else {
    return V = _makeIntrospectionQuery(U = e);
  }
};

var _makeIntrospectionQuery = e => ({
  kind: v.DOCUMENT,
  definitions: [ {
    kind: v.OPERATION_DEFINITION,
    name: {
      kind: v.NAME,
      value: "IntrospectionQuery"
    },
    operation: E.QUERY,
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "__schema"
        },
        selectionSet: _makeSchemaSelection(e)
      } ]
    }
  }, _makeSchemaFullTypeFragment(e), _makeSchemaInputValueFragment(e), _makeTypeRefFragment() ]
});

var makeIntrospectSupportQuery = () => ({
  kind: v.DOCUMENT,
  definitions: [ {
    kind: v.OPERATION_DEFINITION,
    name: {
      kind: v.NAME,
      value: "IntrospectSupportQuery"
    },
    operation: E.QUERY,
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        alias: {
          kind: v.NAME,
          value: "directive"
        },
        name: {
          kind: v.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: v.ARGUMENT,
          name: {
            kind: v.NAME,
            value: "name"
          },
          value: {
            kind: v.STRING,
            value: "__Directive"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !0
        })
      }, {
        kind: v.FIELD,
        alias: {
          kind: v.NAME,
          value: "field"
        },
        name: {
          kind: v.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: v.ARGUMENT,
          name: {
            kind: v.NAME,
            value: "name"
          },
          value: {
            kind: v.STRING,
            value: "__Field"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !0
        })
      }, {
        kind: v.FIELD,
        alias: {
          kind: v.NAME,
          value: "type"
        },
        name: {
          kind: v.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: v.ARGUMENT,
          name: {
            kind: v.NAME,
            value: "name"
          },
          value: {
            kind: v.STRING,
            value: "__Type"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !1
        })
      }, {
        kind: v.FIELD,
        alias: {
          kind: v.NAME,
          value: "inputValue"
        },
        name: {
          kind: v.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: v.ARGUMENT,
          name: {
            kind: v.NAME,
            value: "name"
          },
          value: {
            kind: v.STRING,
            value: "__InputValue"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !1
        })
      } ]
    }
  } ]
});

var _makeFieldNamesSelection = e => ({
  kind: v.SELECTION_SET,
  selections: [ {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "fields"
    },
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "name"
        }
      }, ...e.includeArgs ? [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "args"
        },
        selectionSet: {
          kind: v.SELECTION_SET,
          selections: [ {
            kind: v.FIELD,
            name: {
              kind: v.NAME,
              value: "name"
            }
          } ]
        }
      } ] : [] ]
    }
  } ]
});

var _makeSchemaSelection = e => ({
  kind: v.SELECTION_SET,
  selections: [ {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "queryType"
    },
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "name"
        }
      } ]
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "mutationType"
    },
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "name"
        }
      } ]
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "subscriptionType"
    },
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "name"
        }
      } ]
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "types"
    },
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FRAGMENT_SPREAD,
        name: {
          kind: v.NAME,
          value: "FullType"
        }
      } ]
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "directives"
    },
    selectionSet: {
      kind: v.SELECTION_SET,
      selections: [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "name"
        }
      }, {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "description"
        }
      }, {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "locations"
        }
      }, _makeSchemaArgsField(e.directiveArgumentsIsDeprecated), ...e.directiveIsRepeatable ? [ {
        kind: v.FIELD,
        name: {
          kind: v.NAME,
          value: "isRepeatable"
        }
      } ] : [] ]
    }
  } ]
});

var _makeSchemaFullTypeFragment = e => ({
  kind: v.FRAGMENT_DEFINITION,
  name: {
    kind: v.NAME,
    value: "FullType"
  },
  typeCondition: {
    kind: v.NAMED_TYPE,
    name: {
      kind: v.NAME,
      value: "__Type"
    }
  },
  selectionSet: {
    kind: v.SELECTION_SET,
    selections: [ {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "kind"
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "name"
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "description"
      }
    }, ...e.specifiedByURL ? [ {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "specifiedByURL"
      }
    } ] : [], {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "fields"
      },
      arguments: [ {
        kind: v.ARGUMENT,
        name: {
          kind: v.NAME,
          value: "includeDeprecated"
        },
        value: {
          kind: v.BOOLEAN,
          value: !0
        }
      } ],
      selectionSet: {
        kind: v.SELECTION_SET,
        selections: [ {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "name"
          }
        }, {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "description"
          }
        }, {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "isDeprecated"
          }
        }, {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "deprecationReason"
          }
        }, _makeSchemaArgsField(e.fieldArgumentsIsDeprecated), {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "type"
          },
          selectionSet: {
            kind: v.SELECTION_SET,
            selections: [ {
              kind: v.FRAGMENT_SPREAD,
              name: {
                kind: v.NAME,
                value: "TypeRef"
              }
            } ]
          }
        } ]
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "interfaces"
      },
      selectionSet: {
        kind: v.SELECTION_SET,
        selections: [ {
          kind: v.FRAGMENT_SPREAD,
          name: {
            kind: v.NAME,
            value: "TypeRef"
          }
        } ]
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "possibleTypes"
      },
      selectionSet: {
        kind: v.SELECTION_SET,
        selections: [ {
          kind: v.FRAGMENT_SPREAD,
          name: {
            kind: v.NAME,
            value: "TypeRef"
          }
        } ]
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "inputFields"
      },
      arguments: e.inputValueDeprecation ? [ {
        kind: v.ARGUMENT,
        name: {
          kind: v.NAME,
          value: "includeDeprecated"
        },
        value: {
          kind: v.BOOLEAN,
          value: !0
        }
      } ] : [],
      selectionSet: {
        kind: v.SELECTION_SET,
        selections: [ {
          kind: v.FRAGMENT_SPREAD,
          name: {
            kind: v.NAME,
            value: "InputValue"
          }
        } ]
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "enumValues"
      },
      arguments: [ {
        kind: v.ARGUMENT,
        name: {
          kind: v.NAME,
          value: "includeDeprecated"
        },
        value: {
          kind: v.BOOLEAN,
          value: !0
        }
      } ],
      selectionSet: {
        kind: v.SELECTION_SET,
        selections: [ {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "name"
          }
        }, {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "description"
          }
        }, {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "isDeprecated"
          }
        }, {
          kind: v.FIELD,
          name: {
            kind: v.NAME,
            value: "deprecationReason"
          }
        } ]
      }
    } ]
  }
});

var _makeSchemaArgsField = e => ({
  kind: v.FIELD,
  name: {
    kind: v.NAME,
    value: "args"
  },
  arguments: e ? [ {
    kind: v.ARGUMENT,
    name: {
      kind: v.NAME,
      value: "includeDeprecated"
    },
    value: {
      kind: v.BOOLEAN,
      value: !0
    }
  } ] : [],
  selectionSet: {
    kind: v.SELECTION_SET,
    selections: [ {
      kind: v.FRAGMENT_SPREAD,
      name: {
        kind: v.NAME,
        value: "InputValue"
      }
    } ]
  }
});

var _makeSchemaInputValueFragment = e => ({
  kind: v.FRAGMENT_DEFINITION,
  name: {
    kind: v.NAME,
    value: "InputValue"
  },
  typeCondition: {
    kind: v.NAMED_TYPE,
    name: {
      kind: v.NAME,
      value: "__InputValue"
    }
  },
  selectionSet: {
    kind: v.SELECTION_SET,
    selections: [ {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "name"
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "description"
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "defaultValue"
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "type"
      },
      selectionSet: {
        kind: v.SELECTION_SET,
        selections: [ {
          kind: v.FRAGMENT_SPREAD,
          name: {
            kind: v.NAME,
            value: "TypeRef"
          }
        } ]
      }
    }, ...e.inputValueDeprecation ? [ {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "isDeprecated"
      }
    }, {
      kind: v.FIELD,
      name: {
        kind: v.NAME,
        value: "deprecationReason"
      }
    } ] : [] ]
  }
});

var _makeTypeRefFragment = () => ({
  kind: v.FRAGMENT_DEFINITION,
  name: {
    kind: v.NAME,
    value: "TypeRef"
  },
  typeCondition: {
    kind: v.NAMED_TYPE,
    name: {
      kind: v.NAME,
      value: "__Type"
    }
  },
  selectionSet: _makeTypeRefSelection(0)
});

var _makeTypeRefSelection = e => ({
  kind: v.SELECTION_SET,
  selections: e < 9 ? [ {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "kind"
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "name"
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "ofType"
    },
    selectionSet: _makeTypeRefSelection(e + 1)
  } ] : [ {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "kind"
    }
  }, {
    kind: v.FIELD,
    name: {
      kind: v.NAME,
      value: "name"
    }
  } ]
});

var G = {
  directiveIsRepeatable: !0,
  specifiedByURL: !0,
  inputValueDeprecation: !0,
  directiveArgumentsIsDeprecated: !0,
  fieldArgumentsIsDeprecated: !0
};

function loadFromSDL(e) {
  var r = new Set;
  var t = null;
  var a = null;
  var load = async () => {
    var r = u.extname(e.file);
    var t = await g.readFile(e.file, {
      encoding: "utf8"
    });
    if (".json" === r) {
      var a = JSON.parse(t);
      if (!a || !a.__schema) {
        throw new Error("Parsing JSON introspection data failed.\nThe JSON payload did not evaluate to an introspection schema.");
      }
      return {
        introspection: a,
        schema: c(a, {
          assumeValid: !!e.assumeValid
        })
      };
    } else {
      var n = f(t, {
        assumeValidSDL: !!e.assumeValid
      });
      var i = makeIntrospectionQuery(G);
      var o = p({
        schema: n,
        document: i
      });
      if (o.errors) {
        throw new CombinedError({
          graphQLErrors: o.errors
        });
      } else if (o.data) {
        return {
          introspection: o.data,
          schema: n
        };
      } else {
        throw new Error("Executing introspection against SDL schema failed.\n`graphql` failed to return any schema data or error.");
      }
    }
  };
  return {
    load: async e => e || !a ? a = await load() : a,
    notifyOnUpdate(n) {
      if (!r.size) {
        (async () => {
          t = new AbortController;
          var n = g.watch(e.file, {
            signal: t.signal,
            persistent: !1
          });
          try {
            for await (var i of n) {
              if (a = await load()) {
                for (var o of r) {
                  o(a);
                }
              }
            }
          } catch (e) {
            if ("AbortError" !== e.name) {
              throw e;
            }
          } finally {
            t = null;
          }
        })();
      }
      r.add(n);
      return () => {
        r.delete(n);
        if (!r.size && t) {
          t.abort();
        }
      };
    },
    async loadIntrospection() {
      var e = await this.load();
      return e && e.introspection;
    },
    async loadSchema() {
      var e = await this.load();
      return e && e.schema;
    }
  };
}

var retryExchange = e => {
  var {retryIf: r, retryWith: t} = e;
  var a = e.initialDelayMs || 1e3;
  var n = e.maxDelayMs || 15e3;
  var i = e.maxNumberAttempts || 2;
  var o = null != e.randomDelay ? !!e.randomDelay : !0;
  return ({forward: e, dispatchDebug: s}) => l => {
    var {source: u, next: d} = makeSubject();
    var c = mergeMap((e => {
      var r = e.context.retry || {
        count: 0,
        delay: null
      };
      var t = ++r.count;
      var u = r.delay || a;
      var d = Math.random() + 1.5;
      if (o) {
        if (u * d < n) {
          u *= d;
        } else {
          u = n;
        }
      } else {
        u = Math.min(t * a, n);
      }
      r.delay = u;
      var c = filter((r => ("query" === r.kind || "teardown" === r.kind) && r.key === e.key))(l);
      "production" !== process.env.NODE_ENV && s({
        type: "retryAttempt",
        message: `The operation has failed and a retry has been triggered (${t} / ${i})`,
        operation: e,
        data: {
          retryCount: t,
          delayAmount: u
        },
        source: "retryExchange"
      });
      return takeUntil(c)(function debounce(e) {
        return r => t => {
          var a;
          var n = !1;
          var i = !1;
          r((r => {
            if (i) {} else if (0 === r) {
              i = !0;
              if (a) {
                n = !0;
              } else {
                t(0);
              }
            } else if (0 === r.tag) {
              var o = r[0];
              t(start((e => {
                if (1 === e && !i) {
                  i = !0;
                  n = !1;
                  if (a) {
                    clearTimeout(a);
                  }
                  o(1);
                } else if (!i) {
                  o(0);
                }
              })));
            } else {
              if (a) {
                clearTimeout(a);
              }
              a = setTimeout((() => {
                a = void 0;
                t(r);
                if (n) {
                  t(0);
                }
              }), e(r[0]));
            }
          }));
        };
      }((() => u))(fromValue(makeOperation(e.kind, e, {
        ...e.context,
        retry: r
      }))));
    }))(u);
    return filter((e => {
      var a = e.operation.context.retry;
      if (!e.error || !(r ? r(e.error, e.operation) : t || e.error.networkError)) {
        if (a) {
          a.count = 0;
          a.delay = null;
        }
        return !0;
      }
      if (!((a && a.count || 0) >= i - 1)) {
        var n = t ? t(e.error, e.operation) : e.operation;
        if (!n) {
          return !0;
        }
        d(n);
        return !1;
      }
      "production" !== process.env.NODE_ENV && s({
        type: "retryExhausted",
        message: "Maximum number of retries has been reached. No further retries will be performed.",
        operation: e.operation,
        source: "retryExchange"
      });
      return !0;
    }))(e(merge([ l, c ])));
  };
};

var J = {
  directiveIsRepeatable: !0,
  specifiedByURL: !0,
  inputValueDeprecation: !0,
  directiveArgumentsIsDeprecated: !0,
  fieldArgumentsIsDeprecated: !0
};

var B = {
  directiveIsRepeatable: !1,
  specifiedByURL: !1,
  inputValueDeprecation: !1,
  directiveArgumentsIsDeprecated: !1,
  fieldArgumentsIsDeprecated: !1
};

function loadFromURL(e) {
  var r = e.interval || 6e4;
  var t = new Set;
  var a = null;
  var n = null;
  var i = null;
  var o = new q({
    url: `${e.url}`,
    fetchOptions: {
      headers: e.headers
    },
    exchanges: [ retryExchange({
      initialDelayMs: 200,
      maxDelayMs: 1500,
      maxNumberAttempts: 3,
      retryWith(e, r) {
        if (e.networkError) {
          process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
        }
        return r;
      }
    }), fetchExchange ]
  });
  var introspect = async e => {
    var n = makeIntrospectionQuery(e);
    var s = await o.query(n, {});
    try {
      if (s.error) {
        throw s.error;
      } else if (s.data) {
        var l = s.data;
        return {
          introspection: l,
          schema: c(l, {
            assumeValid: !0
          })
        };
      } else {
        throw new Error("Executing introspection against API failed.\nThe API failed to return any schema data or error.");
      }
    } finally {
      (() => {
        if (t.size && !a) {
          a = setTimeout((async () => {
            a = null;
            try {
              i = await load();
            } catch (e) {
              i = null;
            }
            if (i) {
              for (var e of t) {
                e(i);
              }
            }
          }), r);
        }
      })();
    }
  };
  var load = async () => {
    if (!n) {
      var e = makeIntrospectSupportQuery();
      var r = await o.query(e, {});
      if (r.error && r.error.graphQLErrors.length > 0) {
        var t = await introspect(J);
        if (t) {
          n = J;
          return t;
        } else {
          n = B;
        }
      } else if (r.data && !r.error) {
        n = toSupportedFeatures(r.data);
      } else if (r.error) {
        n = null;
        throw r.error;
      } else {
        n = B;
      }
    }
    return introspect(n);
  };
  return {
    load: async e => e || !i ? i = await load() : i,
    notifyOnUpdate(e) {
      t.add(e);
      return () => {
        t.delete(e);
        if (!t.size && a) {
          clearTimeout(a);
          a = null;
        }
      };
    },
    async loadIntrospection() {
      var e = await this.load();
      return e && e.introspection;
    },
    async loadSchema() {
      var e = await this.load();
      return e && e.schema;
    }
  };
}

function load(e) {
  var r = (e => {
    try {
      return e ? {
        url: new URL("object" == typeof e ? e.url : e),
        headers: "object" == typeof e ? e.headers : void 0
      } : null;
    } catch (e) {
      return null;
    }
  })(e.origin);
  if (r) {
    return loadFromURL({
      ...r,
      interval: e.fetchInterval
    });
  } else if ("string" == typeof e.origin) {
    return loadFromSDL({
      file: e.rootPath ? u.resolve(e.rootPath, e.origin) : e.origin,
      assumeValid: null != e.assumeValid ? e.assumeValid : !0
    });
  } else {
    throw new Error('Configuration contains an invalid "schema" option');
  }
}

var Q = process.cwd();

var maybeRelative = e => {
  var r = l.relative(Q, e);
  return !r.startsWith("..") ? r : e;
};

class TSError extends Error {
  constructor(e) {
    var r = "string" != typeof e.messageText ? e.messageText.messageText : e.messageText;
    if (e.file) {
      r += ` (${maybeRelative(e.file.fileName)})`;
    }
    super(r);
    this.name = "TSError";
    this.diagnostic = e;
  }
}

class TadaError extends Error {
  constructor(e) {
    super(e);
    this.name = "TadaError";
  }
}

var parseConfig = e => {
  if (e.schema && "object" == typeof e.schema) {
    var {schema: r} = e;
    if (!("url" in r)) {
      throw new TadaError("Configuration contains a `schema` object, but no `url` property");
    }
    if ("headers" in r && r.headers && "object" == typeof r.headers) {
      for (var t in r.headers) {
        if (r.headers[t] && "string" != typeof r.headers[t]) {
          throw new TadaError("Headers at `schema.headers` contain a non-string value at key: " + t);
        }
      }
    } else if ("headers" in r) {
      throw new TadaError("Configuration contains a `schema.headers` property, but it's not an object");
    }
  } else if ("string" != typeof e.schema) {
    throw new TadaError("Configuration is missing a `schema` property");
  } else if ("tadaOutputLocation" in e && e.tadaOutputLocation && "string" != typeof e.tadaOutputLocation) {
    throw new TadaError("Configuration contains a `tadaOutputLocation` property, but it's not a file path");
  } else if ("tadaTurboLocation" in e && e.tadaTurboLocation && "string" != typeof e.tadaTurboLocation) {
    throw new TadaError("Configuration contains a `tadaTurboLocation` property, but it's not a file path");
  } else if ("tadaPersistedLocation" in e && e.tadaPersistedLocation && "string" != typeof e.tadaPersistedLocation) {
    throw new TadaError("Configuration contains a `tadaPersistedLocation` property, but it's not a file path");
  } else if ("template" in e && e.template && "string" != typeof e.template) {
    throw new TadaError("Configuration contains a `template` property, but it's not a string");
  }
  return e;
};

var isFile = e => e.isFile();

var isDir = e => e.isDirectory();

var stat = (e, r = isFile) => k.stat(e).then(r).catch((() => !1));

var z = "undefined" != typeof require ? require.resolve.bind(require) : N(import.meta.url).resolve;

var resolveExtend = async (e, r) => {
  try {
    return toTSConfigPath(z(e, {
      paths: [ r ]
    }));
  } catch (e) {
    return null;
  }
};

var toTSConfigPath = e => ".json" !== l.extname(e) ? l.resolve(Q, e, "tsconfig.json") : l.resolve(Q, e);

var readTSConfigFile = async e => {
  var r = toTSConfigPath(e);
  var t = await k.readFile(r, "utf8");
  var a = s(r, t);
  if (a.error) {
    throw new TSError(a.error);
  }
  return a.config || {};
};

var findTSConfigFile = async e => {
  var r = toTSConfigPath(e || Q);
  var t = toTSConfigPath(l.resolve(r, "/"));
  while (r !== t) {
    if (await stat(r)) {
      return r;
    }
    var a = l.resolve(r, "..", ".git");
    if (await stat(a, isDir)) {
      return null;
    }
    var n = toTSConfigPath(l.resolve(r, "..", ".."));
    if (n === r) {
      break;
    }
    r = n;
  }
  return null;
};

var loadConfig = async e => {
  var r = await findTSConfigFile(e);
  if (!r) {
    throw new TadaError(e ? `No tsconfig.json found at or above: ${maybeRelative(e)}` : "No tsconfig.json found at or above current working directory");
  }
  var t = await readTSConfigFile(r);
  var a = (e => e && e.compilerOptions && e.compilerOptions.plugins && e.compilerOptions.plugins.find((e => "@0no-co/graphqlsp" === e.name || "gql.tada/lsp" === e.name)) || null)(t);
  if (a) {
    return {
      pluginConfig: a,
      configPath: r,
      rootPath: l.dirname(r)
    };
  }
  if (Array.isArray(t.extends)) {
    for (var n of t.extends) {
      if (".json" !== l.extname(n)) {
        n += ".json";
      }
      try {
        if (await resolveExtend(n, l.dirname(r))) {
          return {
            ...loadConfig(e),
            rootPath: l.dirname(r)
          };
        }
      } catch (e) {}
    }
  } else if (t.extends) {
    try {
      if (await resolveExtend(t.extends, l.dirname(r))) {
        return {
          ...loadConfig(e),
          rootPath: l.dirname(r)
        };
      }
    } catch (e) {}
  }
  throw new TadaError(`Could not find a valid GraphQLSP plugin entry in: ${maybeRelative(r)}`);
};

var resolveTypeScriptRootDir = async e => {
  try {
    var r = await loadConfig(e);
    return l.dirname(r.configPath);
  } catch (e) {
    return;
  }
};

function nameCompare(e, r) {
  return e.name < r.name ? -1 : e.name > r.name ? 1 : 0;
}

function mapTypeRef(e) {
  switch (e.kind) {
   case "NON_NULL":
   case "LIST":
    return {
      kind: e.kind,
      ofType: mapTypeRef(e.ofType)
    };

   case "ENUM":
   case "INPUT_OBJECT":
   case "SCALAR":
   case "OBJECT":
   case "INTERFACE":
   case "UNION":
    return {
      kind: e.kind,
      name: e.name
    };
  }
}

function mapEnumValue(e) {
  return {
    name: e.name,
    isDeprecated: !!e.isDeprecated,
    deprecationReason: void 0
  };
}

function mapInputField(e) {
  return {
    name: e.name,
    type: mapTypeRef(e.type),
    defaultValue: e.defaultValue || void 0
  };
}

function mapField(e) {
  return {
    name: e.name,
    type: mapTypeRef(e.type),
    args: e.args ? e.args.map(mapInputField).sort(nameCompare) : [],
    isDeprecated: !!e.isDeprecated,
    deprecationReason: void 0
  };
}

function mapPossibleType(e) {
  return {
    kind: e.kind,
    name: e.name
  };
}

function minifyIntrospectionType(e) {
  switch (e.kind) {
   case "SCALAR":
    return {
      kind: "SCALAR",
      name: e.name
    };

   case "ENUM":
    return {
      kind: "ENUM",
      name: e.name,
      enumValues: e.enumValues.map(mapEnumValue)
    };

   case "INPUT_OBJECT":
    return {
      kind: "INPUT_OBJECT",
      name: e.name,
      inputFields: e.inputFields.map(mapInputField)
    };

   case "OBJECT":
    return {
      kind: "OBJECT",
      name: e.name,
      fields: e.fields ? e.fields.map(mapField).sort(nameCompare) : [],
      interfaces: e.interfaces ? e.interfaces.map(mapPossibleType).sort(nameCompare) : []
    };

   case "INTERFACE":
    return {
      kind: "INTERFACE",
      name: e.name,
      fields: e.fields ? e.fields.map(mapField).sort(nameCompare) : [],
      interfaces: e.interfaces ? e.interfaces.map(mapPossibleType).sort(nameCompare) : [],
      possibleTypes: e.possibleTypes ? e.possibleTypes.map(mapPossibleType).sort(nameCompare) : []
    };

   case "UNION":
    return {
      kind: "UNION",
      name: e.name,
      possibleTypes: e.possibleTypes ? e.possibleTypes.map(mapPossibleType).sort(nameCompare) : []
    };
  }
}

var minifyIntrospectionQuery = e => {
  if (!e || !("__schema" in e)) {
    throw new TypeError("Expected to receive an IntrospectionQuery.");
  }
  var {__schema: {queryType: r, mutationType: t, subscriptionType: a, types: n}} = e;
  var i = n.filter((e => {
    switch (e.name) {
     case "__Directive":
     case "__DirectiveLocation":
     case "__EnumValue":
     case "__InputValue":
     case "__Field":
     case "__Type":
     case "__TypeKind":
     case "__Schema":
      return !1;

     default:
      return "SCALAR" === e.kind || "ENUM" === e.kind || "INPUT_OBJECT" === e.kind || "OBJECT" === e.kind || "INTERFACE" === e.kind || "UNION" === e.kind;
    }
  })).map(minifyIntrospectionType).sort(nameCompare);
  return {
    __schema: {
      queryType: {
        kind: r.kind,
        name: r.name
      },
      mutationType: t ? {
        kind: t.kind,
        name: t.name
      } : null,
      subscriptionType: a ? {
        kind: a.kind,
        name: a.name
      } : null,
      types: i,
      directives: []
    }
  };
};

var printName = e => e ? `'${e}'` : "never";

var printTypeRef = e => {
  if ("NON_NULL" === e.kind) {
    return `{ kind: 'NON_NULL'; name: never; ofType: ${printTypeRef(e.ofType)}; }`;
  } else if ("LIST" === e.kind) {
    return `{ kind: 'LIST'; name: never; ofType: ${printTypeRef(e.ofType)}; }`;
  } else {
    return `{ kind: ${printName(e.kind)}; name: ${printName(e.name)}; ofType: null; }`;
  }
};

var printNamedTypes = e => {
  if (!e.length) {
    return "never";
  }
  var r = "";
  for (var t of e) {
    if (r) {
      r += " | ";
    }
    r += printName(t.name);
  }
  return r;
};

var printFields = e => {
  var r = "";
  for (var t of e) {
    var a = printName(t.name);
    var n = printTypeRef(t.type);
    r += `${printName(t.name)}: { name: ${a}; type: ${n} }; `;
  }
  return `{ ${r}}`;
};

var printIntrospectionType = e => {
  if ("ENUM" === e.kind) {
    var r = printNamedTypes(e.enumValues);
    return `{ name: ${printName(e.name)}; enumValues: ${r}; }`;
  } else if ("INPUT_OBJECT" === e.kind) {
    var t = (e => {
      var r = "";
      for (var t of e) {
        if (r) {
          r += ", ";
        }
        r += `{ name: ${printName(t.name)}; type: ${printTypeRef(t.type)}; defaultValue: ${t.defaultValue ? JSON.stringify(t.defaultValue) : "null"} }`;
      }
      return `[${r}]`;
    })(e.inputFields);
    return `{ kind: 'INPUT_OBJECT'; name: ${printName(e.name)}; inputFields: ${t}; }`;
  } else if ("OBJECT" === e.kind) {
    var a = printFields(e.fields);
    return `{ kind: 'OBJECT'; name: ${printName(e.name)}; fields: ${a}; }`;
  } else if ("INTERFACE" === e.kind) {
    return `{ kind: 'INTERFACE'; name: ${printName(e.name)}; fields: ${printFields(e.fields)}; possibleTypes: ${printNamedTypes(e.possibleTypes)}; }`;
  } else if ("UNION" === e.kind) {
    return `{ kind: 'UNION'; name: ${printName(e.name)}; fields: {}; possibleTypes: ${printNamedTypes(e.possibleTypes)}; }`;
  } else {
    return "unknown";
  }
};

function preprocessIntrospection({__schema: e}) {
  var r = printName(e.queryType.name);
  var t = printName(e.mutationType && e.mutationType.name);
  var a = printName(e.subscriptionType && e.subscriptionType.name);
  var n = "";
  for (var i of e.types) {
    var o = printIntrospectionType(i);
    if (n) {
      n += "\n";
    }
    n += `    ${printName(i.name)}: ${o};`;
  }
  return `{\n  query: ${r};\n  mutation: ${t};\n  subscription: ${a};\n  types: {\n${n}\n  };\n}`;
}

var W = [ "/* eslint-disable */", "/* prettier-ignore */" ].join("\n") + "\n";

var Y = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * It will automatically be used by `gql.tada` to infer the types of your GraphQL documents.", " * If you need to reuse this data or update your `scalars`, update `tadaOutputLocation` to", " * instead save to a .ts instead of a .d.ts file.", " */" ].join("\n");

var H = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * You may import it to create a `graphql()` tag function with `gql.tada`", " * by importing it and passing it to `initGraphQLTada<>()`.", " *", " * @example", " * ```", " * import { initGraphQLTada } from 'gql.tada';", " * import type { introspection } from './introspection';", " *", " * export const graphql = initGraphQLTada<{", " *   introspection: typeof introspection;", " *   scalars: {", " *     DateTime: string;", " *     Json: any;", " *   };", " * }>();", " * ```", " */" ].join("\n");

var stringifyJson = e => "string" == typeof e ? e : JSON.stringify(e, null, 2);

function outputIntrospectionFile(e, r) {
  if (/\.d\.ts$/.test(r.fileType)) {
    var t = "string" != typeof e && r.shouldPreprocess ? preprocessIntrospection(e) : stringifyJson(e);
    return [ W, Y, `export type introspection = ${t};\n`, "import * as gqlTada from 'gql.tada';\n", "declare module 'gql.tada' {", "  interface setupSchema {", "    introspection: introspection", "  }", "}" ].join("\n");
  } else if (/\.ts$/.test(r.fileType)) {
    var a = stringifyJson(e);
    return [ W, H, `const introspection = ${a} as const;\n`, "export { introspection };" ].join("\n");
  }
  throw new TadaError(`No available introspection format for "${r.fileType}" (expected ".ts" or ".d.ts")`);
}

export { TSError, TadaError, createProgram, createVirtualHost, findTSConfigFile, importLib, importModule, load, loadConfig, loadFromSDL, loadFromURL, minifyIntrospectionQuery as minifyIntrospection, outputIntrospectionFile, parseConfig, preprocessIntrospection, readTSConfigFile, resolveModuleFile, resolveTypeScriptRootDir };
//# sourceMappingURL=gql-tada-internal.mjs.map
