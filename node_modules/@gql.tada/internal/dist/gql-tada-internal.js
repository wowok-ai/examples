Object.defineProperty(exports, "__esModule", {
  value: !0
});

var e = require("typescript");

var r = require("node:path");

var n = require("graphql");

var t = require("@0no-co/graphql.web");

var i = require("node:fs/promises");

var a = require("node:module");

var o = "undefined" != typeof document ? document.currentScript : null;

function _interopNamespaceDefault(e) {
  var r = Object.create(null);
  if (e) {
    Object.keys(e).forEach((function(n) {
      if ("default" !== n) {
        var t = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(r, n, t.get ? t : {
          enumerable: !0,
          get: function() {
            return e[n];
          }
        });
      }
    }));
  }
  r.default = e;
  return r;
}

var s = _interopNamespaceDefault(r);

var d = _interopNamespaceDefault(i);

var l = {
  rootDir: "/",
  moduleResolution: e.ModuleResolutionKind.Bundler,
  skipLibCheck: !0,
  skipDefaultLibCheck: !0,
  allowImportingTsExtensions: !0,
  allowSyntheticDefaultImports: !0,
  resolvePackageJsonExports: !0,
  resolvePackageJsonImports: !0,
  resolveJsonModule: !0,
  esModuleInterop: !0,
  jsx: e.JsxEmit.Preserve,
  target: e.ScriptTarget.Latest,
  checkJs: !1,
  allowJs: !0,
  strict: !0,
  noEmit: !0,
  noLib: !1,
  disableReferencedProjectLoad: !0,
  disableSourceOfProjectReferenceRedirect: !0,
  disableSizeLimit: !0,
  disableSolutionSearching: !0
};

let u = class File {
  constructor(r, n) {
    this.cache = function createTargetCache() {
      return {
        [e.ScriptTarget[e.ScriptTarget.ES3]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES5]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2015]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2016]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2017]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2018]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2019]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2020]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2021]]: null,
        [e.ScriptTarget[e.ScriptTarget.ES2022]]: null,
        [e.ScriptTarget[e.ScriptTarget.Latest]]: null,
        [e.ScriptTarget[e.ScriptTarget.JSON]]: null
      };
    }();
    this.name = normalize(r);
    if ("string" == typeof n) {
      this.text = n || "\n";
      this.data = null;
    } else {
      this.text = null;
      this.data = n;
    }
  }
  toSourceFile(r) {
    var n = "object" == typeof r ? r.languageVersion : r;
    return function getTargetCache(r, n) {
      return r[e.ScriptTarget[n]] || null;
    }(this.cache, n) || function setTargetCache(r, n, t) {
      r[e.ScriptTarget[n]] = t;
      return t;
    }(this.cache, n, e.createSourceFile(this.name, this.toString(), r));
  }
  toBuffer() {
    return this.data || (this.data = (new TextEncoder).encode(this.text));
  }
  toString() {
    return this.text || (this.text = (new TextDecoder).decode(this.data));
  }
};

class Directory {
  constructor() {
    this.children = Object.create(null);
    this.files = Object.create(null);
  }
  getOrCreateDirectory(e) {
    return this.children[e] || (this.children[e] = new Directory);
  }
}

function normalize(e) {
  return r.posix.normalize(!e.startsWith(r.posix.sep) ? r.posix.sep + e : e);
}

function split$1(e) {
  return e !== r.posix.sep ? e.split(r.posix.sep).slice(1) : [];
}

var c = r.posix.sep;

var p = "function" == typeof require ? require.resolve : a.createRequire("undefined" == typeof document ? require("url").pathToFileURL(__filename).href : o && o.src || new URL("dist/gql-tada-internal.js", document.baseURI).href).resolve;

var f = "lib.d.ts";

var teardownPlaceholder = () => {};

var v = teardownPlaceholder;

function start(e) {
  return {
    tag: 0,
    0: e
  };
}

function push(e) {
  return {
    tag: 1,
    0: e
  };
}

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

var identity = e => e;

function filter(e) {
  return r => n => {
    var t = v;
    r((r => {
      if (0 === r) {
        n(0);
      } else if (0 === r.tag) {
        t = r[0];
        n(r);
      } else if (!e(r[0])) {
        t(0);
      } else {
        n(r);
      }
    }));
  };
}

function map(e) {
  return r => n => r((r => {
    if (0 === r || 0 === r.tag) {
      n(r);
    } else {
      n(push(e(r[0])));
    }
  }));
}

function mergeMap(e) {
  return r => n => {
    var t = [];
    var i = v;
    var a = !1;
    var o = !1;
    r((r => {
      if (o) {} else if (0 === r) {
        o = !0;
        if (!t.length) {
          n(0);
        }
      } else if (0 === r.tag) {
        i = r[0];
      } else {
        a = !1;
        !function applyInnerSource(e) {
          var r = v;
          e((e => {
            if (0 === e) {
              if (t.length) {
                var s = t.indexOf(r);
                if (s > -1) {
                  (t = t.slice()).splice(s, 1);
                }
                if (!t.length) {
                  if (o) {
                    n(0);
                  } else if (!a) {
                    a = !0;
                    i(0);
                  }
                }
              }
            } else if (0 === e.tag) {
              t.push(r = e[0]);
              r(0);
            } else if (t.length) {
              n(e);
              r(0);
            }
          }));
        }(e(r[0]));
        if (!a) {
          a = !0;
          i(0);
        }
      }
    }));
    n(start((e => {
      if (1 === e) {
        if (!o) {
          o = !0;
          i(1);
        }
        for (var r = 0, n = t, s = t.length; r < s; r++) {
          n[r](1);
        }
        t.length = 0;
      } else {
        if (!o && !a) {
          a = !0;
          i(0);
        } else {
          a = !1;
        }
        for (var d = 0, l = t, u = t.length; d < u; d++) {
          l[d](0);
        }
      }
    })));
  };
}

function merge(e) {
  return function mergeAll(e) {
    return mergeMap(identity)(e);
  }(m(e));
}

function onEnd(e) {
  return r => n => {
    var t = !1;
    r((r => {
      if (t) {} else if (0 === r) {
        t = !0;
        n(0);
        e();
      } else if (0 === r.tag) {
        var i = r[0];
        n(start((r => {
          if (1 === r) {
            t = !0;
            i(1);
            e();
          } else {
            i(r);
          }
        })));
      } else {
        n(r);
      }
    }));
  };
}

function onPush(e) {
  return r => n => {
    var t = !1;
    r((r => {
      if (t) {} else if (0 === r) {
        t = !0;
        n(0);
      } else if (0 === r.tag) {
        var i = r[0];
        n(start((e => {
          if (1 === e) {
            t = !0;
          }
          i(e);
        })));
      } else {
        e(r[0]);
        n(r);
      }
    }));
  };
}

function onStart(e) {
  return r => n => r((r => {
    if (0 === r) {
      n(0);
    } else if (0 === r.tag) {
      n(r);
      e();
    } else {
      n(r);
    }
  }));
}

function share(e) {
  var r = [];
  var n = v;
  var t = !1;
  return i => {
    r.push(i);
    if (1 === r.length) {
      e((e => {
        if (0 === e) {
          for (var i = 0, a = r, o = r.length; i < o; i++) {
            a[i](0);
          }
          r.length = 0;
        } else if (0 === e.tag) {
          n = e[0];
        } else {
          t = !1;
          for (var s = 0, d = r, l = r.length; s < l; s++) {
            d[s](e);
          }
        }
      }));
    }
    i(start((e => {
      if (1 === e) {
        var a = r.indexOf(i);
        if (a > -1) {
          (r = r.slice()).splice(a, 1);
        }
        if (!r.length) {
          n(1);
        }
      } else if (!t) {
        t = !0;
        n(0);
      }
    })));
  };
}

function switchMap(e) {
  return r => n => {
    var t = v;
    var i = v;
    var a = !1;
    var o = !1;
    var s = !1;
    var d = !1;
    r((r => {
      if (d) {} else if (0 === r) {
        d = !0;
        if (!s) {
          n(0);
        }
      } else if (0 === r.tag) {
        t = r[0];
      } else {
        if (s) {
          i(1);
          i = v;
        }
        if (!a) {
          a = !0;
          t(0);
        } else {
          a = !1;
        }
        !function applyInnerSource(e) {
          s = !0;
          e((e => {
            if (!s) {} else if (0 === e) {
              s = !1;
              if (d) {
                n(0);
              } else if (!a) {
                a = !0;
                t(0);
              }
            } else if (0 === e.tag) {
              o = !1;
              (i = e[0])(0);
            } else {
              n(e);
              if (!o) {
                i(0);
              } else {
                o = !1;
              }
            }
          }));
        }(e(r[0]));
      }
    }));
    n(start((e => {
      if (1 === e) {
        if (!d) {
          d = !0;
          t(1);
        }
        if (s) {
          s = !1;
          i(1);
        }
      } else {
        if (!d && !a) {
          a = !0;
          t(0);
        }
        if (s && !o) {
          o = !0;
          i(0);
        }
      }
    })));
  };
}

function take(e) {
  return r => n => {
    var t = v;
    var i = !1;
    var a = 0;
    r((r => {
      if (i) {} else if (0 === r) {
        i = !0;
        n(0);
      } else if (0 === r.tag) {
        if (e <= 0) {
          i = !0;
          n(0);
          r[0](1);
        } else {
          t = r[0];
        }
      } else if (a++ < e) {
        n(r);
        if (!i && a >= e) {
          i = !0;
          n(0);
          t(1);
        }
      } else {
        n(r);
      }
    }));
    n(start((r => {
      if (1 === r && !i) {
        i = !0;
        t(1);
      } else if (0 === r && !i && a < e) {
        t(0);
      }
    })));
  };
}

function takeUntil(e) {
  return r => n => {
    var t = v;
    var i = v;
    var a = !1;
    r((r => {
      if (a) {} else if (0 === r) {
        a = !0;
        i(1);
        n(0);
      } else if (0 === r.tag) {
        t = r[0];
        e((e => {
          if (0 === e) {} else if (0 === e.tag) {
            (i = e[0])(0);
          } else {
            a = !0;
            i(1);
            t(1);
            n(0);
          }
        }));
      } else {
        n(r);
      }
    }));
    n(start((e => {
      if (1 === e && !a) {
        a = !0;
        t(1);
        i(1);
      } else if (!a) {
        t(0);
      }
    })));
  };
}

function takeWhile(e, r) {
  return n => t => {
    var i = v;
    var a = !1;
    n((n => {
      if (a) {} else if (0 === n) {
        a = !0;
        t(0);
      } else if (0 === n.tag) {
        i = n[0];
        t(n);
      } else if (!e(n[0])) {
        a = !0;
        if (r) {
          t(n);
        }
        t(0);
        i(1);
      } else {
        t(n);
      }
    }));
  };
}

function fromAsyncIterable(e) {
  return r => {
    var n = e[asyncIteratorSymbol()] && e[asyncIteratorSymbol()]() || e;
    var t = !1;
    var i = !1;
    var a = !1;
    var o;
    r(start((async e => {
      if (1 === e) {
        t = !0;
        if (n.return) {
          n.return();
        }
      } else if (i) {
        a = !0;
      } else {
        for (a = i = !0; a && !t; ) {
          if ((o = await n.next()).done) {
            t = !0;
            if (n.return) {
              await n.return();
            }
            r(0);
          } else {
            try {
              a = !1;
              r(push(o.value));
            } catch (e) {
              if (n.throw) {
                if (t = !!(await n.throw(e)).done) {
                  r(0);
                }
              } else {
                throw e;
              }
            }
          }
        }
        i = !1;
      }
    })));
  };
}

var m = function fromIterable(e) {
  if (e[Symbol.asyncIterator]) {
    return fromAsyncIterable(e);
  }
  return r => {
    var n = e[Symbol.iterator]();
    var t = !1;
    var i = !1;
    var a = !1;
    var o;
    r(start((e => {
      if (1 === e) {
        t = !0;
        if (n.return) {
          n.return();
        }
      } else if (i) {
        a = !0;
      } else {
        for (a = i = !0; a && !t; ) {
          if ((o = n.next()).done) {
            t = !0;
            if (n.return) {
              n.return();
            }
            r(0);
          } else {
            try {
              a = !1;
              r(push(o.value));
            } catch (e) {
              if (n.throw) {
                if (t = !!n.throw(e).done) {
                  r(0);
                }
              } else {
                throw e;
              }
            }
          }
        }
        i = !1;
      }
    })));
  };
};

function fromValue(e) {
  return r => {
    var n = !1;
    r(start((t => {
      if (1 === t) {
        n = !0;
      } else if (!n) {
        n = !0;
        r(push(e));
        r(0);
      }
    })));
  };
}

function make(e) {
  return r => {
    var n = !1;
    var t = e({
      next(e) {
        if (!n) {
          r(push(e));
        }
      },
      complete() {
        if (!n) {
          n = !0;
          r(0);
        }
      }
    });
    r(start((e => {
      if (1 === e && !n) {
        n = !0;
        t();
      }
    })));
  };
}

function makeSubject() {
  var e;
  var r;
  return {
    source: share(make((n => {
      e = n.next;
      r = n.complete;
      return teardownPlaceholder;
    }))),
    next(r) {
      if (e) {
        e(r);
      }
    },
    complete() {
      if (r) {
        r();
      }
    }
  };
}

function subscribe(e) {
  return r => {
    var n = v;
    var t = !1;
    r((r => {
      if (0 === r) {
        t = !0;
      } else if (0 === r.tag) {
        (n = r[0])(0);
      } else if (!t) {
        e(r[0]);
        n(0);
      }
    }));
    return {
      unsubscribe() {
        if (!t) {
          t = !0;
          n(1);
        }
      }
    };
  };
}

function toPromise(e) {
  return new Promise((r => {
    var n = v;
    var t;
    e((e => {
      if (0 === e) {
        Promise.resolve(t).then(r);
      } else if (0 === e.tag) {
        (n = e[0])(0);
      } else {
        t = e[0];
        n(0);
      }
    }));
  }));
}

var rehydrateGraphQlError = e => {
  if (e && e.message && (e.extensions || "GraphQLError" === e.name)) {
    return e;
  } else if ("object" == typeof e && e.message) {
    return new t.GraphQLError(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});
  } else {
    return new t.GraphQLError(e);
  }
};

class CombinedError extends Error {
  constructor(e) {
    var r = (e.graphQLErrors || []).map(rehydrateGraphQlError);
    var n = ((e, r) => {
      var n = "";
      if (e) {
        return `[Network] ${e.message}`;
      }
      if (r) {
        for (var t of r) {
          if (n) {
            n += "\n";
          }
          n += `[GraphQL] ${t.message}`;
        }
      }
      return n;
    })(e.networkError, r);
    super(n);
    this.name = "CombinedError";
    this.message = n;
    this.graphQLErrors = r;
    this.networkError = e.networkError;
    this.response = e.response;
  }
  toString() {
    return this.message;
  }
}

var phash = (e, r) => {
  var n = 0 | (r || 5381);
  for (var t = 0, i = 0 | e.length; t < i; t++) {
    n = (n << 5) + n + e.charCodeAt(t);
  }
  return n;
};

var h = new Set;

var y = new WeakMap;

var stringify = e => {
  if (null === e || h.has(e)) {
    return "null";
  } else if ("object" != typeof e) {
    return JSON.stringify(e) || "";
  } else if (e.toJSON) {
    return stringify(e.toJSON());
  } else if (Array.isArray(e)) {
    var r = "[";
    for (var n of e) {
      if (r.length > 1) {
        r += ",";
      }
      r += stringify(n) || "null";
    }
    return r + "]";
  } else if (E !== NoopConstructor && e instanceof E || k !== NoopConstructor && e instanceof k) {
    return "null";
  }
  var t = Object.keys(e).sort();
  if (!t.length && e.constructor && Object.getPrototypeOf(e).constructor !== Object.prototype.constructor) {
    var i = y.get(e) || Math.random().toString(36).slice(2);
    y.set(e, i);
    return stringify({
      __key: i
    });
  }
  h.add(e);
  var a = "{";
  for (var o of t) {
    var s = stringify(e[o]);
    if (s) {
      if (a.length > 1) {
        a += ",";
      }
      a += stringify(o) + ":" + s;
    }
  }
  h.delete(e);
  return a + "}";
};

var extract = (e, r, n) => {
  if (null == n || "object" != typeof n || n.toJSON || h.has(n)) {} else if (Array.isArray(n)) {
    for (var t = 0, i = n.length; t < i; t++) {
      extract(e, `${r}.${t}`, n[t]);
    }
  } else if (n instanceof E || n instanceof k) {
    e.set(r, n);
  } else {
    h.add(n);
    for (var a of Object.keys(n)) {
      extract(e, `${r}.${a}`, n[a]);
    }
  }
};

var stringifyVariables = e => {
  h.clear();
  return stringify(e);
};

class NoopConstructor {}

var E = "undefined" != typeof File ? File : NoopConstructor;

var k = "undefined" != typeof Blob ? Blob : NoopConstructor;

var g = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;

var N = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;

var replaceOutsideStrings = (e, r) => r % 2 == 0 ? e.replace(N, "\n") : e;

var sanitizeDocument = e => e.split(g).map(replaceOutsideStrings).join("").trim();

var T = new Map;

var S = new Map;

var stringifyDocument = e => {
  var r;
  if ("string" == typeof e) {
    r = sanitizeDocument(e);
  } else if (e.loc && S.get(e.__key) === e) {
    r = e.loc.source.body;
  } else {
    r = T.get(e) || sanitizeDocument(t.print(e));
    T.set(e, r);
  }
  if ("string" != typeof e && !e.loc) {
    e.loc = {
      start: 0,
      end: r.length,
      source: {
        body: r,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return r;
};

var hashDocument = e => {
  var r = phash(stringifyDocument(e));
  if (e.definitions) {
    var n = getOperationName(e);
    if (n) {
      r = phash(`\n# ${n}`, r);
    }
  }
  return r;
};

var createRequest = (e, r, n) => {
  var i = r || {};
  var a = (e => {
    var r;
    var n;
    if ("string" == typeof e) {
      r = hashDocument(e);
      n = S.get(r) || t.parse(e, {
        noLocation: !0
      });
    } else {
      r = e.__key || hashDocument(e);
      n = S.get(r) || e;
    }
    if (!n.loc) {
      stringifyDocument(n);
    }
    n.__key = r;
    S.set(r, n);
    return n;
  })(e);
  var o = stringifyVariables(i);
  var s = a.__key;
  if ("{}" !== o) {
    s = phash(o, s);
  }
  return {
    key: s,
    query: a,
    variables: i,
    extensions: n
  };
};

var getOperationName = e => {
  for (var r of e.definitions) {
    if (r.kind === t.Kind.OPERATION_DEFINITION) {
      return r.name ? r.name.value : void 0;
    }
  }
};

var makeResult = (e, r, n) => {
  if (!("data" in r || "errors" in r && Array.isArray(r.errors))) {
    throw new Error("No Content");
  }
  var t = "subscription" === e.kind;
  return {
    operation: e,
    data: r.data,
    error: Array.isArray(r.errors) ? new CombinedError({
      graphQLErrors: r.errors,
      response: n
    }) : void 0,
    extensions: r.extensions ? {
      ...r.extensions
    } : void 0,
    hasNext: null == r.hasNext ? t : r.hasNext,
    stale: !1
  };
};

var deepMerge = (e, r) => {
  if ("object" == typeof e && null != e) {
    if (!e.constructor || e.constructor === Object || Array.isArray(e)) {
      e = Array.isArray(e) ? [ ...e ] : {
        ...e
      };
      for (var n of Object.keys(r)) {
        e[n] = deepMerge(e[n], r[n]);
      }
      return e;
    }
  }
  return r;
};

var mergeResultPatch = (e, r, n, t) => {
  var i = e.error ? e.error.graphQLErrors : [];
  var a = !!e.extensions || !!(r.payload || r).extensions;
  var o = {
    ...e.extensions,
    ...(r.payload || r).extensions
  };
  var s = r.incremental;
  if ("path" in r) {
    s = [ r ];
  }
  var d = {
    data: e.data
  };
  if (s) {
    var _loop = function(e) {
      if (Array.isArray(e.errors)) {
        i.push(...e.errors);
      }
      if (e.extensions) {
        Object.assign(o, e.extensions);
        a = !0;
      }
      var r = "data";
      var n = d;
      var s = [];
      if (e.path) {
        s = e.path;
      } else if (t) {
        var l = t.find((r => r.id === e.id));
        if (e.subPath) {
          s = [ ...l.path, ...e.subPath ];
        } else {
          s = l.path;
        }
      }
      for (var u = 0, c = s.length; u < c; r = s[u++]) {
        n = n[r] = Array.isArray(n[r]) ? [ ...n[r] ] : {
          ...n[r]
        };
      }
      if (e.items) {
        var p = +r >= 0 ? r : 0;
        for (var f = 0, v = e.items.length; f < v; f++) {
          n[p + f] = deepMerge(n[p + f], e.items[f]);
        }
      } else if (void 0 !== e.data) {
        n[r] = deepMerge(n[r], e.data);
      }
    };
    for (var l of s) {
      _loop(l);
    }
  } else {
    d.data = (r.payload || r).data || e.data;
    i = r.errors || r.payload && r.payload.errors || i;
  }
  return {
    operation: e.operation,
    data: d.data,
    error: i.length ? new CombinedError({
      graphQLErrors: i,
      response: n
    }) : void 0,
    extensions: a ? o : void 0,
    hasNext: null != r.hasNext ? r.hasNext : e.hasNext,
    stale: !1
  };
};

var makeErrorResult = (e, r, n) => ({
  operation: e,
  data: void 0,
  error: new CombinedError({
    networkError: r,
    response: n
  }),
  extensions: void 0,
  hasNext: !1,
  stale: !1
});

var splitOutSearchParams = e => {
  var r = e.indexOf("?");
  return r > -1 ? [ e.slice(0, r), new URLSearchParams(e.slice(r + 1)) ] : [ e, new URLSearchParams ];
};

var makeFetchOptions = (e, r) => {
  var n = {
    accept: "subscription" === e.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var t = ("function" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions) || {};
  if (t.headers) {
    if ((e => "has" in e && !Object.keys(e).length)(t.headers)) {
      t.headers.forEach(((e, r) => {
        n[r] = e;
      }));
    } else if (Array.isArray(t.headers)) {
      t.headers.forEach(((e, r) => {
        if (Array.isArray(e)) {
          if (n[e[0]]) {
            n[e[0]] = `${n[e[0]]},${e[1]}`;
          } else {
            n[e[0]] = e[1];
          }
        } else {
          n[r] = e;
        }
      }));
    } else {
      for (var i in t.headers) {
        n[i.toLowerCase()] = t.headers[i];
      }
    }
  }
  var a = ((e, r) => {
    if (r && ("query" !== e.kind || !e.context.preferGetMethod)) {
      var n = stringifyVariables(r);
      var t = (e => {
        var r = new Map;
        if (E !== NoopConstructor || k !== NoopConstructor) {
          h.clear();
          extract(r, "variables", e);
        }
        return r;
      })(r.variables);
      if (t.size) {
        var i = new FormData;
        i.append("operations", n);
        i.append("map", stringifyVariables({
          ...[ ...t.keys() ].map((e => [ e ]))
        }));
        var a = 0;
        for (var o of t.values()) {
          i.append("" + a++, o);
        }
        return i;
      }
      return n;
    }
  })(e, r);
  if ("string" == typeof a && !n["content-type"]) {
    n["content-type"] = "application/json";
  }
  return {
    ...t,
    method: a ? "POST" : "GET",
    body: a,
    headers: n
  };
};

var b = "undefined" != typeof TextDecoder ? new TextDecoder : null;

var w = /boundary="?([^=";]+)"?/i;

var I = /data: ?([^\n]+)/;

var toString = e => "Buffer" === e.constructor.name ? e.toString() : b.decode(e);

async function* streamBody(e) {
  if (e.body[Symbol.asyncIterator]) {
    for await (var r of e.body) {
      yield toString(r);
    }
  } else {
    var n = e.body.getReader();
    var t;
    try {
      while (!(t = await n.read()).done) {
        yield toString(t.value);
      }
    } finally {
      n.cancel();
    }
  }
}

async function* split(e, r) {
  var n = "";
  var t;
  for await (var i of e) {
    n += i;
    while ((t = n.indexOf(r)) > -1) {
      yield n.slice(0, t);
      n = n.slice(t + r.length);
    }
  }
}

function makeFetchSource(e, r, n) {
  var t;
  if ("undefined" != typeof AbortController) {
    n.signal = (t = new AbortController).signal;
  }
  return onEnd((() => {
    if (t) {
      t.abort();
    }
  }))(filter((e => !!e))(fromAsyncIterable(async function* fetchOperation(e, r, n) {
    var t = !0;
    var i = null;
    var a;
    try {
      yield await Promise.resolve();
      var o = (a = await (e.context.fetch || fetch)(r, n)).headers.get("Content-Type") || "";
      var s;
      if (/multipart\/mixed/i.test(o)) {
        s = async function* parseMultipartMixed(e, r) {
          var n = e.match(w);
          var t = "--" + (n ? n[1] : "-");
          var i = !0;
          var a;
          for await (var o of split(streamBody(r), "\r\n" + t)) {
            if (i) {
              i = !1;
              var s = o.indexOf(t);
              if (s > -1) {
                o = o.slice(s + t.length);
              } else {
                continue;
              }
            }
            try {
              yield a = JSON.parse(o.slice(o.indexOf("\r\n\r\n") + 4));
            } catch (e) {
              if (!a) {
                throw e;
              }
            }
            if (a && !1 === a.hasNext) {
              break;
            }
          }
          if (a && !1 !== a.hasNext) {
            yield {
              hasNext: !1
            };
          }
        }(o, a);
      } else if (/text\/event-stream/i.test(o)) {
        s = async function* parseEventStream(e) {
          var r;
          for await (var n of split(streamBody(e), "\n\n")) {
            var t = n.match(I);
            if (t) {
              var i = t[1];
              try {
                yield r = JSON.parse(i);
              } catch (e) {
                if (!r) {
                  throw e;
                }
              }
              if (r && !1 === r.hasNext) {
                break;
              }
            }
          }
          if (r && !1 !== r.hasNext) {
            yield {
              hasNext: !1
            };
          }
        }(a);
      } else if (!/text\//i.test(o)) {
        s = async function* parseJSON(e) {
          yield JSON.parse(await e.text());
        }(a);
      } else {
        s = async function* parseMaybeJSON(e) {
          var r = await e.text();
          try {
            var n = JSON.parse(r);
            if ("production" !== process.env.NODE_ENV) {
              console.warn('Found response with content-type "text/plain" but it had a valid "application/json" response.');
            }
            yield n;
          } catch (e) {
            throw new Error(r);
          }
        }(a);
      }
      var d;
      for await (var l of s) {
        if (l.pending && !i) {
          d = l.pending;
        } else if (l.pending) {
          d = [ ...d, ...l.pending ];
        }
        i = i ? mergeResultPatch(i, l, a, d) : makeResult(e, l, a);
        t = !1;
        yield i;
        t = !0;
      }
      if (!i) {
        yield i = makeResult(e, {}, a);
      }
    } catch (r) {
      if (!t) {
        throw r;
      }
      yield makeErrorResult(e, a && (a.status < 200 || a.status >= 300) && a.statusText ? new Error(a.statusText) : r, a);
    }
  }(e, r, n))));
}

var maskTypename = (e, r) => {
  if (!e || "object" != typeof e) {
    return e;
  } else if (Array.isArray(e)) {
    return e.map((e => maskTypename(e)));
  } else if (e && "object" == typeof e && (r || "__typename" in e)) {
    var n = {};
    for (var t in e) {
      if ("__typename" === t) {
        Object.defineProperty(n, "__typename", {
          enumerable: !1,
          value: e.__typename
        });
      } else {
        n[t] = maskTypename(e[t]);
      }
    }
    return n;
  } else {
    return e;
  }
};

function withPromise(e) {
  var source$ = r => e(r);
  source$.toPromise = () => toPromise(take(1)(filter((e => !e.stale && !e.hasNext))(source$)));
  source$.then = (e, r) => source$.toPromise().then(e, r);
  source$.subscribe = e => subscribe(e)(source$);
  return source$;
}

function makeOperation(e, r, n) {
  return {
    ...r,
    kind: e,
    context: r.context ? {
      ...r.context,
      ...n
    } : n || r.context
  };
}

var noop = () => {};

var fetchExchange = ({forward: e, dispatchDebug: r}) => n => {
  var t = mergeMap((e => {
    var t = function makeFetchBody(e) {
      var r = {
        query: void 0,
        documentId: void 0,
        operationName: getOperationName(e.query),
        variables: e.variables || void 0,
        extensions: e.extensions
      };
      if ("documentId" in e.query && e.query.documentId && (!e.query.definitions || !e.query.definitions.length)) {
        r.documentId = e.query.documentId;
      } else if (!e.extensions || !e.extensions.persistedQuery || e.extensions.persistedQuery.miss) {
        r.query = stringifyDocument(e.query);
      }
      return r;
    }(e);
    var i = ((e, r) => {
      var n = "query" === e.kind && e.context.preferGetMethod;
      if (!n || !r) {
        return e.context.url;
      }
      var t = splitOutSearchParams(e.context.url);
      for (var i in r) {
        var a = r[i];
        if (a) {
          t[1].set(i, "object" == typeof a ? stringifyVariables(a) : a);
        }
      }
      var o = t.join("?");
      if (o.length > 2047 && "force" !== n) {
        e.context.preferGetMethod = !1;
        return e.context.url;
      }
      return o;
    })(e, t);
    var a = makeFetchOptions(e, t);
    "production" !== process.env.NODE_ENV && r({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e,
      data: {
        url: i,
        fetchOptions: a
      },
      source: "fetchExchange"
    });
    var o = takeUntil(filter((r => "teardown" === r.kind && r.key === e.key))(n))(makeFetchSource(e, i, a));
    if ("production" !== process.env.NODE_ENV) {
      return onPush((n => {
        var t = !n.data ? n.error : void 0;
        "production" !== process.env.NODE_ENV && r({
          type: t ? "fetchError" : "fetchSuccess",
          message: `A ${t ? "failed" : "successful"} fetch response has been returned.`,
          operation: e,
          data: {
            url: i,
            fetchOptions: a,
            value: t || n
          },
          source: "fetchExchange"
        });
      }))(o);
    }
    return o;
  }))(filter((e => "teardown" !== e.kind && ("subscription" !== e.kind || !!e.context.fetchSubscriptions)))(n));
  return merge([ t, e(filter((e => "teardown" === e.kind || "subscription" === e.kind && !e.context.fetchSubscriptions))(n)) ]);
};

var fallbackExchange = ({dispatchDebug: e}) => r => {
  if ("production" !== process.env.NODE_ENV) {
    r = onPush((r => {
      if ("teardown" !== r.kind && "production" !== process.env.NODE_ENV) {
        var n = `No exchange has handled operations of kind "${r.kind}". Check whether you've added an exchange responsible for these operations.`;
        "production" !== process.env.NODE_ENV && e({
          type: "fallbackCatch",
          message: n,
          operation: r,
          source: "fallbackExchange"
        });
        console.warn(n);
      }
    }))(r);
  }
  return filter((e => !1))(r);
};

var K = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = 0;
  var n = new Map;
  var i = new Map;
  var a = new Set;
  var o = [];
  var s = {
    url: e.url,
    fetchSubscriptions: e.fetchSubscriptions,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    preferGetMethod: e.preferGetMethod,
    requestPolicy: e.requestPolicy || "cache-first"
  };
  var d = makeSubject();
  function nextOperation(e) {
    if ("mutation" === e.kind || "teardown" === e.kind || !a.has(e.key)) {
      if ("teardown" === e.kind) {
        a.delete(e.key);
      } else if ("mutation" !== e.kind) {
        a.add(e.key);
      }
      d.next(e);
    }
  }
  var l = !1;
  function dispatchOperation(e) {
    if (e) {
      nextOperation(e);
    }
    if (!l) {
      l = !0;
      while (l && (e = o.shift())) {
        nextOperation(e);
      }
      l = !1;
    }
  }
  var makeResultSource = r => {
    var t = takeUntil(filter((e => "teardown" === e.kind && e.key === r.key))(d.source))(filter((e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance)))(h));
    if (e.maskTypename) {
      t = map((e => ({
        ...e,
        data: maskTypename(e.data, !0)
      })))(t);
    }
    if ("query" !== r.kind) {
      t = takeWhile((e => !!e.hasNext), !0)(t);
    } else {
      t = switchMap((e => {
        var n = fromValue(e);
        return e.stale || e.hasNext ? n : merge([ n, map((() => {
          e.stale = !0;
          return e;
        }))(take(1)(filter((e => e.key === r.key))(d.source))) ]);
      }))(t);
    }
    if ("mutation" !== r.kind) {
      t = onEnd((() => {
        a.delete(r.key);
        n.delete(r.key);
        i.delete(r.key);
        l = !1;
        for (var e = o.length - 1; e >= 0; e--) {
          if (o[e].key === r.key) {
            o.splice(e, 1);
          }
        }
        nextOperation(makeOperation("teardown", r, r.context));
      }))(onPush((e => {
        if (e.stale) {
          for (var t of o) {
            if (t.key === e.operation.key) {
              a.delete(t.key);
              break;
            }
          }
        } else if (!e.hasNext) {
          a.delete(r.key);
        }
        n.set(r.key, e);
      }))(t));
    } else {
      t = onStart((() => {
        nextOperation(r);
      }))(t);
    }
    return share(t);
  };
  var u = this instanceof Client ? this : Object.create(Client.prototype);
  var c = Object.assign(u, {
    suspense: !!e.suspense,
    operations$: d.source,
    reexecuteOperation(e) {
      if ("teardown" === e.kind) {
        dispatchOperation(e);
      } else if ("mutation" === e.kind || i.has(e.key)) {
        var r = !1;
        for (var n = 0; n < o.length; n++) {
          r = r || o[n].key === e.key;
        }
        if (!r) {
          a.delete(e.key);
        }
        o.push(e);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e, n, i) {
      if (!i) {
        i = {};
      }
      var a;
      if ("production" !== process.env.NODE_ENV && "teardown" !== e && (a = (e => {
        for (var r of e.definitions) {
          if (r.kind === t.Kind.OPERATION_DEFINITION) {
            return r.operation;
          }
        }
      })(n.query)) !== e) {
        throw new Error(`Expected operation of type "${e}" but found "${a}"`);
      }
      return makeOperation(e, n, {
        _instance: "mutation" === e ? r = r + 1 | 0 : void 0,
        ...s,
        ...i,
        requestPolicy: i.requestPolicy || s.requestPolicy,
        suspense: i.suspense || !1 !== i.suspense && c.suspense
      });
    },
    executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return withPromise(makeResultSource(e));
      }
      return withPromise(function lazy(e) {
        return r => e()(r);
      }((() => {
        var r = i.get(e.key);
        if (!r) {
          i.set(e.key, r = makeResultSource(e));
        }
        r = onStart((() => {
          dispatchOperation(e);
        }))(r);
        var t = n.get(e.key);
        if ("query" === e.kind && t && (t.stale || t.hasNext)) {
          return switchMap(fromValue)(merge([ r, filter((r => r === n.get(e.key)))(fromValue(t)) ]));
        } else {
          return r;
        }
      })));
    },
    executeQuery(e, r) {
      var n = c.createRequestOperation("query", e, r);
      return c.executeRequestOperation(n);
    },
    executeSubscription(e, r) {
      var n = c.createRequestOperation("subscription", e, r);
      return c.executeRequestOperation(n);
    },
    executeMutation(e, r) {
      var n = c.createRequestOperation("mutation", e, r);
      return c.executeRequestOperation(n);
    },
    readQuery(e, r, n) {
      var t = null;
      subscribe((e => {
        t = e;
      }))(c.query(e, r, n)).unsubscribe();
      return t;
    },
    query: (e, r, n) => c.executeQuery(createRequest(e, r), n),
    subscription: (e, r, n) => c.executeSubscription(createRequest(e, r), n),
    mutation: (e, r, n) => c.executeMutation(createRequest(e, r), n)
  });
  var p = noop;
  if ("production" !== process.env.NODE_ENV) {
    var {next: f, source: v} = makeSubject();
    c.subscribeToDebugTarget = e => subscribe(e)(v);
    p = f;
  }
  var m = (e => ({client: r, forward: n, dispatchDebug: t}) => e.reduceRight(((e, n) => {
    var i = !1;
    return n({
      client: r,
      forward(r) {
        if ("production" !== process.env.NODE_ENV) {
          if (i) {
            throw new Error("forward() must only be called once in each Exchange.");
          }
          i = !0;
        }
        return share(e(share(r)));
      },
      dispatchDebug(e) {
        "production" !== process.env.NODE_ENV && t({
          timestamp: Date.now(),
          source: n.name,
          ...e
        });
      }
    });
  }), n))(e.exchanges);
  var h = share(m({
    client: c,
    dispatchDebug: p,
    forward: fallbackExchange({
      dispatchDebug: p
    })
  })(d.source));
  !function publish(e) {
    subscribe((e => {}))(e);
  }(h);
  return c;
};

var _hasField = (e, r) => !!e && !!e.fields && e.fields.some((e => e.name === r));

var _supportsDeprecatedArgumentsArg = e => {
  var r = e && e.fields && e.fields.find((e => "args" === e.name));
  return !!(r && r.args && r.args.find((e => "includeDeprecated" === e.name)));
};

var toSupportedFeatures = e => ({
  directiveIsRepeatable: _hasField(e.directive, "isRepeatable"),
  specifiedByURL: _hasField(e.type, "specifiedByURL"),
  inputValueDeprecation: _hasField(e.inputValue, "isDeprecated"),
  directiveArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(e.directive),
  fieldArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(e.field)
});

var x;

var A;

var makeIntrospectionQuery = e => {
  if (x && A === e) {
    return x;
  } else {
    return x = _makeIntrospectionQuery(A = e);
  }
};

var _makeIntrospectionQuery = e => ({
  kind: t.Kind.DOCUMENT,
  definitions: [ {
    kind: t.Kind.OPERATION_DEFINITION,
    name: {
      kind: t.Kind.NAME,
      value: "IntrospectionQuery"
    },
    operation: t.OperationTypeNode.QUERY,
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "__schema"
        },
        selectionSet: _makeSchemaSelection(e)
      } ]
    }
  }, _makeSchemaFullTypeFragment(e), _makeSchemaInputValueFragment(e), _makeTypeRefFragment() ]
});

var makeIntrospectSupportQuery = () => ({
  kind: t.Kind.DOCUMENT,
  definitions: [ {
    kind: t.Kind.OPERATION_DEFINITION,
    name: {
      kind: t.Kind.NAME,
      value: "IntrospectSupportQuery"
    },
    operation: t.OperationTypeNode.QUERY,
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        alias: {
          kind: t.Kind.NAME,
          value: "directive"
        },
        name: {
          kind: t.Kind.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: t.Kind.ARGUMENT,
          name: {
            kind: t.Kind.NAME,
            value: "name"
          },
          value: {
            kind: t.Kind.STRING,
            value: "__Directive"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !0
        })
      }, {
        kind: t.Kind.FIELD,
        alias: {
          kind: t.Kind.NAME,
          value: "field"
        },
        name: {
          kind: t.Kind.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: t.Kind.ARGUMENT,
          name: {
            kind: t.Kind.NAME,
            value: "name"
          },
          value: {
            kind: t.Kind.STRING,
            value: "__Field"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !0
        })
      }, {
        kind: t.Kind.FIELD,
        alias: {
          kind: t.Kind.NAME,
          value: "type"
        },
        name: {
          kind: t.Kind.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: t.Kind.ARGUMENT,
          name: {
            kind: t.Kind.NAME,
            value: "name"
          },
          value: {
            kind: t.Kind.STRING,
            value: "__Type"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !1
        })
      }, {
        kind: t.Kind.FIELD,
        alias: {
          kind: t.Kind.NAME,
          value: "inputValue"
        },
        name: {
          kind: t.Kind.NAME,
          value: "__type"
        },
        arguments: [ {
          kind: t.Kind.ARGUMENT,
          name: {
            kind: t.Kind.NAME,
            value: "name"
          },
          value: {
            kind: t.Kind.STRING,
            value: "__InputValue"
          }
        } ],
        selectionSet: _makeFieldNamesSelection({
          includeArgs: !1
        })
      } ]
    }
  } ]
});

var _makeFieldNamesSelection = e => ({
  kind: t.Kind.SELECTION_SET,
  selections: [ {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "fields"
    },
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "name"
        }
      }, ...e.includeArgs ? [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "args"
        },
        selectionSet: {
          kind: t.Kind.SELECTION_SET,
          selections: [ {
            kind: t.Kind.FIELD,
            name: {
              kind: t.Kind.NAME,
              value: "name"
            }
          } ]
        }
      } ] : [] ]
    }
  } ]
});

var _makeSchemaSelection = e => ({
  kind: t.Kind.SELECTION_SET,
  selections: [ {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "queryType"
    },
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "name"
        }
      } ]
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "mutationType"
    },
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "name"
        }
      } ]
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "subscriptionType"
    },
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "name"
        }
      } ]
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "types"
    },
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FRAGMENT_SPREAD,
        name: {
          kind: t.Kind.NAME,
          value: "FullType"
        }
      } ]
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "directives"
    },
    selectionSet: {
      kind: t.Kind.SELECTION_SET,
      selections: [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "name"
        }
      }, {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "description"
        }
      }, {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "locations"
        }
      }, _makeSchemaArgsField(e.directiveArgumentsIsDeprecated), ...e.directiveIsRepeatable ? [ {
        kind: t.Kind.FIELD,
        name: {
          kind: t.Kind.NAME,
          value: "isRepeatable"
        }
      } ] : [] ]
    }
  } ]
});

var _makeSchemaFullTypeFragment = e => ({
  kind: t.Kind.FRAGMENT_DEFINITION,
  name: {
    kind: t.Kind.NAME,
    value: "FullType"
  },
  typeCondition: {
    kind: t.Kind.NAMED_TYPE,
    name: {
      kind: t.Kind.NAME,
      value: "__Type"
    }
  },
  selectionSet: {
    kind: t.Kind.SELECTION_SET,
    selections: [ {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "kind"
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "name"
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "description"
      }
    }, ...e.specifiedByURL ? [ {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "specifiedByURL"
      }
    } ] : [], {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "fields"
      },
      arguments: [ {
        kind: t.Kind.ARGUMENT,
        name: {
          kind: t.Kind.NAME,
          value: "includeDeprecated"
        },
        value: {
          kind: t.Kind.BOOLEAN,
          value: !0
        }
      } ],
      selectionSet: {
        kind: t.Kind.SELECTION_SET,
        selections: [ {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "name"
          }
        }, {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "description"
          }
        }, {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "isDeprecated"
          }
        }, {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "deprecationReason"
          }
        }, _makeSchemaArgsField(e.fieldArgumentsIsDeprecated), {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "type"
          },
          selectionSet: {
            kind: t.Kind.SELECTION_SET,
            selections: [ {
              kind: t.Kind.FRAGMENT_SPREAD,
              name: {
                kind: t.Kind.NAME,
                value: "TypeRef"
              }
            } ]
          }
        } ]
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "interfaces"
      },
      selectionSet: {
        kind: t.Kind.SELECTION_SET,
        selections: [ {
          kind: t.Kind.FRAGMENT_SPREAD,
          name: {
            kind: t.Kind.NAME,
            value: "TypeRef"
          }
        } ]
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "possibleTypes"
      },
      selectionSet: {
        kind: t.Kind.SELECTION_SET,
        selections: [ {
          kind: t.Kind.FRAGMENT_SPREAD,
          name: {
            kind: t.Kind.NAME,
            value: "TypeRef"
          }
        } ]
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "inputFields"
      },
      arguments: e.inputValueDeprecation ? [ {
        kind: t.Kind.ARGUMENT,
        name: {
          kind: t.Kind.NAME,
          value: "includeDeprecated"
        },
        value: {
          kind: t.Kind.BOOLEAN,
          value: !0
        }
      } ] : [],
      selectionSet: {
        kind: t.Kind.SELECTION_SET,
        selections: [ {
          kind: t.Kind.FRAGMENT_SPREAD,
          name: {
            kind: t.Kind.NAME,
            value: "InputValue"
          }
        } ]
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "enumValues"
      },
      arguments: [ {
        kind: t.Kind.ARGUMENT,
        name: {
          kind: t.Kind.NAME,
          value: "includeDeprecated"
        },
        value: {
          kind: t.Kind.BOOLEAN,
          value: !0
        }
      } ],
      selectionSet: {
        kind: t.Kind.SELECTION_SET,
        selections: [ {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "name"
          }
        }, {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "description"
          }
        }, {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "isDeprecated"
          }
        }, {
          kind: t.Kind.FIELD,
          name: {
            kind: t.Kind.NAME,
            value: "deprecationReason"
          }
        } ]
      }
    } ]
  }
});

var _makeSchemaArgsField = e => ({
  kind: t.Kind.FIELD,
  name: {
    kind: t.Kind.NAME,
    value: "args"
  },
  arguments: e ? [ {
    kind: t.Kind.ARGUMENT,
    name: {
      kind: t.Kind.NAME,
      value: "includeDeprecated"
    },
    value: {
      kind: t.Kind.BOOLEAN,
      value: !0
    }
  } ] : [],
  selectionSet: {
    kind: t.Kind.SELECTION_SET,
    selections: [ {
      kind: t.Kind.FRAGMENT_SPREAD,
      name: {
        kind: t.Kind.NAME,
        value: "InputValue"
      }
    } ]
  }
});

var _makeSchemaInputValueFragment = e => ({
  kind: t.Kind.FRAGMENT_DEFINITION,
  name: {
    kind: t.Kind.NAME,
    value: "InputValue"
  },
  typeCondition: {
    kind: t.Kind.NAMED_TYPE,
    name: {
      kind: t.Kind.NAME,
      value: "__InputValue"
    }
  },
  selectionSet: {
    kind: t.Kind.SELECTION_SET,
    selections: [ {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "name"
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "description"
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "defaultValue"
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "type"
      },
      selectionSet: {
        kind: t.Kind.SELECTION_SET,
        selections: [ {
          kind: t.Kind.FRAGMENT_SPREAD,
          name: {
            kind: t.Kind.NAME,
            value: "TypeRef"
          }
        } ]
      }
    }, ...e.inputValueDeprecation ? [ {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "isDeprecated"
      }
    }, {
      kind: t.Kind.FIELD,
      name: {
        kind: t.Kind.NAME,
        value: "deprecationReason"
      }
    } ] : [] ]
  }
});

var _makeTypeRefFragment = () => ({
  kind: t.Kind.FRAGMENT_DEFINITION,
  name: {
    kind: t.Kind.NAME,
    value: "TypeRef"
  },
  typeCondition: {
    kind: t.Kind.NAMED_TYPE,
    name: {
      kind: t.Kind.NAME,
      value: "__Type"
    }
  },
  selectionSet: _makeTypeRefSelection(0)
});

var _makeTypeRefSelection = e => ({
  kind: t.Kind.SELECTION_SET,
  selections: e < 9 ? [ {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "kind"
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "name"
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "ofType"
    },
    selectionSet: _makeTypeRefSelection(e + 1)
  } ] : [ {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "kind"
    }
  }, {
    kind: t.Kind.FIELD,
    name: {
      kind: t.Kind.NAME,
      value: "name"
    }
  } ]
});

var O = {
  directiveIsRepeatable: !0,
  specifiedByURL: !0,
  inputValueDeprecation: !0,
  directiveArgumentsIsDeprecated: !0,
  fieldArgumentsIsDeprecated: !0
};

function loadFromSDL(e) {
  var t = new Set;
  var a = null;
  var o = null;
  var load = async () => {
    var t = r.extname(e.file);
    var a = await i.readFile(e.file, {
      encoding: "utf8"
    });
    if (".json" === t) {
      var o = JSON.parse(a);
      if (!o || !o.__schema) {
        throw new Error("Parsing JSON introspection data failed.\nThe JSON payload did not evaluate to an introspection schema.");
      }
      return {
        introspection: o,
        schema: n.buildClientSchema(o, {
          assumeValid: !!e.assumeValid
        })
      };
    } else {
      var s = n.buildSchema(a, {
        assumeValidSDL: !!e.assumeValid
      });
      var d = makeIntrospectionQuery(O);
      var l = n.executeSync({
        schema: s,
        document: d
      });
      if (l.errors) {
        throw new CombinedError({
          graphQLErrors: l.errors
        });
      } else if (l.data) {
        return {
          introspection: l.data,
          schema: s
        };
      } else {
        throw new Error("Executing introspection against SDL schema failed.\n`graphql` failed to return any schema data or error.");
      }
    }
  };
  return {
    load: async e => e || !o ? o = await load() : o,
    notifyOnUpdate(r) {
      if (!t.size) {
        (async () => {
          a = new AbortController;
          var r = i.watch(e.file, {
            signal: a.signal,
            persistent: !1
          });
          try {
            for await (var n of r) {
              if (o = await load()) {
                for (var s of t) {
                  s(o);
                }
              }
            }
          } catch (e) {
            if ("AbortError" !== e.name) {
              throw e;
            }
          } finally {
            a = null;
          }
        })();
      }
      t.add(r);
      return () => {
        t.delete(r);
        if (!t.size && a) {
          a.abort();
        }
      };
    },
    async loadIntrospection() {
      var e = await this.load();
      return e && e.introspection;
    },
    async loadSchema() {
      var e = await this.load();
      return e && e.schema;
    }
  };
}

var retryExchange = e => {
  var {retryIf: r, retryWith: n} = e;
  var t = e.initialDelayMs || 1e3;
  var i = e.maxDelayMs || 15e3;
  var a = e.maxNumberAttempts || 2;
  var o = null != e.randomDelay ? !!e.randomDelay : !0;
  return ({forward: e, dispatchDebug: s}) => d => {
    var {source: l, next: u} = makeSubject();
    var c = mergeMap((e => {
      var r = e.context.retry || {
        count: 0,
        delay: null
      };
      var n = ++r.count;
      var l = r.delay || t;
      var u = Math.random() + 1.5;
      if (o) {
        if (l * u < i) {
          l *= u;
        } else {
          l = i;
        }
      } else {
        l = Math.min(n * t, i);
      }
      r.delay = l;
      var c = filter((r => ("query" === r.kind || "teardown" === r.kind) && r.key === e.key))(d);
      "production" !== process.env.NODE_ENV && s({
        type: "retryAttempt",
        message: `The operation has failed and a retry has been triggered (${n} / ${a})`,
        operation: e,
        data: {
          retryCount: n,
          delayAmount: l
        },
        source: "retryExchange"
      });
      return takeUntil(c)(function debounce(e) {
        return r => n => {
          var t;
          var i = !1;
          var a = !1;
          r((r => {
            if (a) {} else if (0 === r) {
              a = !0;
              if (t) {
                i = !0;
              } else {
                n(0);
              }
            } else if (0 === r.tag) {
              var o = r[0];
              n(start((e => {
                if (1 === e && !a) {
                  a = !0;
                  i = !1;
                  if (t) {
                    clearTimeout(t);
                  }
                  o(1);
                } else if (!a) {
                  o(0);
                }
              })));
            } else {
              if (t) {
                clearTimeout(t);
              }
              t = setTimeout((() => {
                t = void 0;
                n(r);
                if (i) {
                  n(0);
                }
              }), e(r[0]));
            }
          }));
        };
      }((() => l))(fromValue(makeOperation(e.kind, e, {
        ...e.context,
        retry: r
      }))));
    }))(l);
    return filter((e => {
      var t = e.operation.context.retry;
      if (!e.error || !(r ? r(e.error, e.operation) : n || e.error.networkError)) {
        if (t) {
          t.count = 0;
          t.delay = null;
        }
        return !0;
      }
      if (!((t && t.count || 0) >= a - 1)) {
        var i = n ? n(e.error, e.operation) : e.operation;
        if (!i) {
          return !0;
        }
        u(i);
        return !1;
      }
      "production" !== process.env.NODE_ENV && s({
        type: "retryExhausted",
        message: "Maximum number of retries has been reached. No further retries will be performed.",
        operation: e.operation,
        source: "retryExchange"
      });
      return !0;
    }))(e(merge([ d, c ])));
  };
};

var D = {
  directiveIsRepeatable: !0,
  specifiedByURL: !0,
  inputValueDeprecation: !0,
  directiveArgumentsIsDeprecated: !0,
  fieldArgumentsIsDeprecated: !0
};

var L = {
  directiveIsRepeatable: !1,
  specifiedByURL: !1,
  inputValueDeprecation: !1,
  directiveArgumentsIsDeprecated: !1,
  fieldArgumentsIsDeprecated: !1
};

function loadFromURL(e) {
  var r = e.interval || 6e4;
  var t = new Set;
  var i = null;
  var a = null;
  var o = null;
  var s = new K({
    url: `${e.url}`,
    fetchOptions: {
      headers: e.headers
    },
    exchanges: [ retryExchange({
      initialDelayMs: 200,
      maxDelayMs: 1500,
      maxNumberAttempts: 3,
      retryWith(e, r) {
        if (e.networkError) {
          process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
        }
        return r;
      }
    }), fetchExchange ]
  });
  var introspect = async e => {
    var a = makeIntrospectionQuery(e);
    var d = await s.query(a, {});
    try {
      if (d.error) {
        throw d.error;
      } else if (d.data) {
        var l = d.data;
        return {
          introspection: l,
          schema: n.buildClientSchema(l, {
            assumeValid: !0
          })
        };
      } else {
        throw new Error("Executing introspection against API failed.\nThe API failed to return any schema data or error.");
      }
    } finally {
      (() => {
        if (t.size && !i) {
          i = setTimeout((async () => {
            i = null;
            try {
              o = await load();
            } catch (e) {
              o = null;
            }
            if (o) {
              for (var e of t) {
                e(o);
              }
            }
          }), r);
        }
      })();
    }
  };
  var load = async () => {
    if (!a) {
      var e = makeIntrospectSupportQuery();
      var r = await s.query(e, {});
      if (r.error && r.error.graphQLErrors.length > 0) {
        var n = await introspect(D);
        if (n) {
          a = D;
          return n;
        } else {
          a = L;
        }
      } else if (r.data && !r.error) {
        a = toSupportedFeatures(r.data);
      } else if (r.error) {
        a = null;
        throw r.error;
      } else {
        a = L;
      }
    }
    return introspect(a);
  };
  return {
    load: async e => e || !o ? o = await load() : o,
    notifyOnUpdate(e) {
      t.add(e);
      return () => {
        t.delete(e);
        if (!t.size && i) {
          clearTimeout(i);
          i = null;
        }
      };
    },
    async loadIntrospection() {
      var e = await this.load();
      return e && e.introspection;
    },
    async loadSchema() {
      var e = await this.load();
      return e && e.schema;
    }
  };
}

var M = process.cwd();

var maybeRelative = e => {
  var r = s.relative(M, e);
  return !r.startsWith("..") ? r : e;
};

class TSError extends Error {
  constructor(e) {
    var r = "string" != typeof e.messageText ? e.messageText.messageText : e.messageText;
    if (e.file) {
      r += ` (${maybeRelative(e.file.fileName)})`;
    }
    super(r);
    this.name = "TSError";
    this.diagnostic = e;
  }
}

class TadaError extends Error {
  constructor(e) {
    super(e);
    this.name = "TadaError";
  }
}

var isFile = e => e.isFile();

var isDir = e => e.isDirectory();

var stat = (e, r = isFile) => d.stat(e).then(r).catch((() => !1));

var _ = "undefined" != typeof require ? require.resolve.bind(require) : a.createRequire("undefined" == typeof document ? require("url").pathToFileURL(__filename).href : o && o.src || new URL("dist/gql-tada-internal.js", document.baseURI).href).resolve;

var resolveExtend = async (e, r) => {
  try {
    return toTSConfigPath(_(e, {
      paths: [ r ]
    }));
  } catch (e) {
    return null;
  }
};

var toTSConfigPath = e => ".json" !== s.extname(e) ? s.resolve(M, e, "tsconfig.json") : s.resolve(M, e);

var readTSConfigFile = async r => {
  var n = toTSConfigPath(r);
  var t = await d.readFile(n, "utf8");
  var i = e.parseConfigFileTextToJson(n, t);
  if (i.error) {
    throw new TSError(i.error);
  }
  return i.config || {};
};

var findTSConfigFile = async e => {
  var r = toTSConfigPath(e || M);
  var n = toTSConfigPath(s.resolve(r, "/"));
  while (r !== n) {
    if (await stat(r)) {
      return r;
    }
    var t = s.resolve(r, "..", ".git");
    if (await stat(t, isDir)) {
      return null;
    }
    var i = toTSConfigPath(s.resolve(r, "..", ".."));
    if (i === r) {
      break;
    }
    r = i;
  }
  return null;
};

var loadConfig = async e => {
  var r = await findTSConfigFile(e);
  if (!r) {
    throw new TadaError(e ? `No tsconfig.json found at or above: ${maybeRelative(e)}` : "No tsconfig.json found at or above current working directory");
  }
  var n = await readTSConfigFile(r);
  var t = (e => e && e.compilerOptions && e.compilerOptions.plugins && e.compilerOptions.plugins.find((e => "@0no-co/graphqlsp" === e.name || "gql.tada/lsp" === e.name)) || null)(n);
  if (t) {
    return {
      pluginConfig: t,
      configPath: r,
      rootPath: s.dirname(r)
    };
  }
  if (Array.isArray(n.extends)) {
    for (var i of n.extends) {
      if (".json" !== s.extname(i)) {
        i += ".json";
      }
      try {
        if (await resolveExtend(i, s.dirname(r))) {
          return {
            ...loadConfig(e),
            rootPath: s.dirname(r)
          };
        }
      } catch (e) {}
    }
  } else if (n.extends) {
    try {
      if (await resolveExtend(n.extends, s.dirname(r))) {
        return {
          ...loadConfig(e),
          rootPath: s.dirname(r)
        };
      }
    } catch (e) {}
  }
  throw new TadaError(`Could not find a valid GraphQLSP plugin entry in: ${maybeRelative(r)}`);
};

function nameCompare(e, r) {
  return e.name < r.name ? -1 : e.name > r.name ? 1 : 0;
}

function mapTypeRef(e) {
  switch (e.kind) {
   case "NON_NULL":
   case "LIST":
    return {
      kind: e.kind,
      ofType: mapTypeRef(e.ofType)
    };

   case "ENUM":
   case "INPUT_OBJECT":
   case "SCALAR":
   case "OBJECT":
   case "INTERFACE":
   case "UNION":
    return {
      kind: e.kind,
      name: e.name
    };
  }
}

function mapEnumValue(e) {
  return {
    name: e.name,
    isDeprecated: !!e.isDeprecated,
    deprecationReason: void 0
  };
}

function mapInputField(e) {
  return {
    name: e.name,
    type: mapTypeRef(e.type),
    defaultValue: e.defaultValue || void 0
  };
}

function mapField(e) {
  return {
    name: e.name,
    type: mapTypeRef(e.type),
    args: e.args ? e.args.map(mapInputField).sort(nameCompare) : [],
    isDeprecated: !!e.isDeprecated,
    deprecationReason: void 0
  };
}

function mapPossibleType(e) {
  return {
    kind: e.kind,
    name: e.name
  };
}

function minifyIntrospectionType(e) {
  switch (e.kind) {
   case "SCALAR":
    return {
      kind: "SCALAR",
      name: e.name
    };

   case "ENUM":
    return {
      kind: "ENUM",
      name: e.name,
      enumValues: e.enumValues.map(mapEnumValue)
    };

   case "INPUT_OBJECT":
    return {
      kind: "INPUT_OBJECT",
      name: e.name,
      inputFields: e.inputFields.map(mapInputField)
    };

   case "OBJECT":
    return {
      kind: "OBJECT",
      name: e.name,
      fields: e.fields ? e.fields.map(mapField).sort(nameCompare) : [],
      interfaces: e.interfaces ? e.interfaces.map(mapPossibleType).sort(nameCompare) : []
    };

   case "INTERFACE":
    return {
      kind: "INTERFACE",
      name: e.name,
      fields: e.fields ? e.fields.map(mapField).sort(nameCompare) : [],
      interfaces: e.interfaces ? e.interfaces.map(mapPossibleType).sort(nameCompare) : [],
      possibleTypes: e.possibleTypes ? e.possibleTypes.map(mapPossibleType).sort(nameCompare) : []
    };

   case "UNION":
    return {
      kind: "UNION",
      name: e.name,
      possibleTypes: e.possibleTypes ? e.possibleTypes.map(mapPossibleType).sort(nameCompare) : []
    };
  }
}

var printName = e => e ? `'${e}'` : "never";

var printTypeRef = e => {
  if ("NON_NULL" === e.kind) {
    return `{ kind: 'NON_NULL'; name: never; ofType: ${printTypeRef(e.ofType)}; }`;
  } else if ("LIST" === e.kind) {
    return `{ kind: 'LIST'; name: never; ofType: ${printTypeRef(e.ofType)}; }`;
  } else {
    return `{ kind: ${printName(e.kind)}; name: ${printName(e.name)}; ofType: null; }`;
  }
};

var printNamedTypes = e => {
  if (!e.length) {
    return "never";
  }
  var r = "";
  for (var n of e) {
    if (r) {
      r += " | ";
    }
    r += printName(n.name);
  }
  return r;
};

var printFields = e => {
  var r = "";
  for (var n of e) {
    var t = printName(n.name);
    var i = printTypeRef(n.type);
    r += `${printName(n.name)}: { name: ${t}; type: ${i} }; `;
  }
  return `{ ${r}}`;
};

var printIntrospectionType = e => {
  if ("ENUM" === e.kind) {
    var r = printNamedTypes(e.enumValues);
    return `{ name: ${printName(e.name)}; enumValues: ${r}; }`;
  } else if ("INPUT_OBJECT" === e.kind) {
    var n = (e => {
      var r = "";
      for (var n of e) {
        if (r) {
          r += ", ";
        }
        r += `{ name: ${printName(n.name)}; type: ${printTypeRef(n.type)}; defaultValue: ${n.defaultValue ? JSON.stringify(n.defaultValue) : "null"} }`;
      }
      return `[${r}]`;
    })(e.inputFields);
    return `{ kind: 'INPUT_OBJECT'; name: ${printName(e.name)}; inputFields: ${n}; }`;
  } else if ("OBJECT" === e.kind) {
    var t = printFields(e.fields);
    return `{ kind: 'OBJECT'; name: ${printName(e.name)}; fields: ${t}; }`;
  } else if ("INTERFACE" === e.kind) {
    return `{ kind: 'INTERFACE'; name: ${printName(e.name)}; fields: ${printFields(e.fields)}; possibleTypes: ${printNamedTypes(e.possibleTypes)}; }`;
  } else if ("UNION" === e.kind) {
    return `{ kind: 'UNION'; name: ${printName(e.name)}; fields: {}; possibleTypes: ${printNamedTypes(e.possibleTypes)}; }`;
  } else {
    return "unknown";
  }
};

function preprocessIntrospection({__schema: e}) {
  var r = printName(e.queryType.name);
  var n = printName(e.mutationType && e.mutationType.name);
  var t = printName(e.subscriptionType && e.subscriptionType.name);
  var i = "";
  for (var a of e.types) {
    var o = printIntrospectionType(a);
    if (i) {
      i += "\n";
    }
    i += `    ${printName(a.name)}: ${o};`;
  }
  return `{\n  query: ${r};\n  mutation: ${n};\n  subscription: ${t};\n  types: {\n${i}\n  };\n}`;
}

var F = [ "/* eslint-disable */", "/* prettier-ignore */" ].join("\n") + "\n";

var C = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * It will automatically be used by `gql.tada` to infer the types of your GraphQL documents.", " * If you need to reuse this data or update your `scalars`, update `tadaOutputLocation` to", " * instead save to a .ts instead of a .d.ts file.", " */" ].join("\n");

var R = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * You may import it to create a `graphql()` tag function with `gql.tada`", " * by importing it and passing it to `initGraphQLTada<>()`.", " *", " * @example", " * ```", " * import { initGraphQLTada } from 'gql.tada';", " * import type { introspection } from './introspection';", " *", " * export const graphql = initGraphQLTada<{", " *   introspection: typeof introspection;", " *   scalars: {", " *     DateTime: string;", " *     Json: any;", " *   };", " * }>();", " * ```", " */" ].join("\n");

var stringifyJson = e => "string" == typeof e ? e : JSON.stringify(e, null, 2);

exports.TSError = TSError;

exports.TadaError = TadaError;

exports.createProgram = (r, n) => e.createProgram(r, l, n);

exports.createVirtualHost = function createVirtualHost() {
  var r = e.createModuleResolutionCache(c, normalize, l);
  var n = new Directory;
  n.files[f] = new u(f, "");
  return {
    getCanonicalFileName: normalize,
    getDefaultLibFileName: () => c + f,
    getCurrentDirectory: () => c,
    getNewLine: () => "\n",
    getModuleResolutionCache: () => r,
    useCaseSensitiveFileNames: () => !0,
    fileExists(e) {
      var r = split$1(normalize(e));
      var t = n;
      for (var i = 0; i < r.length - 1; i++) {
        if (!(t = t.children[r[i]])) {
          return !1;
        }
      }
      return !!t.files[r[r.length - 1]];
    },
    directoryExists(e) {
      var r = split$1(normalize(e));
      if (!r.length) {
        return !0;
      }
      var t = n;
      for (var i = 0; i < r.length - 1; i++) {
        if (!(t = t.children[r[i]])) {
          return !1;
        }
      }
      return !!t.children[r[r.length - 1]];
    },
    writeFile(e, r) {
      var t = normalize(e);
      var i = split$1(t);
      var a = n;
      for (var o = 0; o < i.length - 1; o++) {
        a = a.getOrCreateDirectory(i[o]);
      }
      a.files[i[i.length - 1]] = new u(t, r);
    },
    getDirectories(e) {
      var r = split$1(normalize(e));
      var t = n;
      for (var i = 0; i < r.length; i++) {
        if (!(t = t.children[r[i]])) {
          return [];
        }
      }
      return Object.keys(t.children);
    },
    readFile(e) {
      var r = split$1(normalize(e));
      var t = n;
      for (var i = 0; i < r.length - 1; i++) {
        if (!(t = t.children[r[i]])) {
          return;
        }
      }
      var a = t.files[r[r.length - 1]];
      return a && a.toString();
    },
    getSourceFile(e, r) {
      var t = split$1(normalize(e));
      var i = n;
      for (var a = 0; a < t.length - 1; a++) {
        if (!(i = i.children[t[a]])) {
          return;
        }
      }
      var o = i.files[t[t.length - 1]];
      return o && o.toSourceFile(r);
    },
    resolveModuleNames(n, t) {
      var i = [];
      for (var a of n) {
        var o = e.resolveModuleName(a, t, l, this, r);
        i.push(o.resolvedModule);
      }
      return i;
    }
  };
};

exports.findTSConfigFile = findTSConfigFile;

exports.importLib = async function importLib(e) {
  var n = "typescript/package.json";
  var t = p(n, {
    paths: [ "node_modules", ...p.paths(n) || [] ]
  });
  if (!t) {
    throw new Error("Failed to resolve typescript");
  }
  var a = r.join(r.dirname(t), "lib");
  var o = (await Promise.all([ "lib.es5.d.ts", "lib.es2015.symbol.d.ts", "lib.es2015.collection.d.ts", "lib.es2015.iterable.d.ts" ].map((e => i.readFile(r.resolve(a, e), {
    encoding: "utf8"
  }))))).join("\n");
  e.writeFile(e.getDefaultLibFileName(l), o, !1);
};

exports.importModule = async function importModule(e, n) {
  var t = `${n}/package.json`;
  var a = p(t, {
    paths: [ "node_modules", ...p.paths(t) || [] ]
  });
  if (!a) {
    throw new Error(`Failed to resolve "${n}"`);
  }
  var o = r.dirname(a);
  var s = `/node_modules/${n}/`;
  await async function walk(n) {
    for (var t of await i.readdir(n)) {
      var a = r.join(n, t);
      if ((await i.stat(a)).isDirectory()) {
        await walk(a);
      } else {
        var d = r.join(r.relative(o, n), t);
        var l = await i.readFile(a, {
          encoding: "utf8"
        });
        e.writeFile(s + d.split(r.sep).join("/"), l, !1);
      }
    }
  }(o);
};

exports.load = function load(e) {
  var n = (e => {
    try {
      return e ? {
        url: new URL("object" == typeof e ? e.url : e),
        headers: "object" == typeof e ? e.headers : void 0
      } : null;
    } catch (e) {
      return null;
    }
  })(e.origin);
  if (n) {
    return loadFromURL({
      ...n,
      interval: e.fetchInterval
    });
  } else if ("string" == typeof e.origin) {
    return loadFromSDL({
      file: e.rootPath ? r.resolve(e.rootPath, e.origin) : e.origin,
      assumeValid: null != e.assumeValid ? e.assumeValid : !0
    });
  } else {
    throw new Error('Configuration contains an invalid "schema" option');
  }
};

exports.loadConfig = loadConfig;

exports.loadFromSDL = loadFromSDL;

exports.loadFromURL = loadFromURL;

exports.minifyIntrospection = e => {
  if (!e || !("__schema" in e)) {
    throw new TypeError("Expected to receive an IntrospectionQuery.");
  }
  var {__schema: {queryType: r, mutationType: n, subscriptionType: t, types: i}} = e;
  var a = i.filter((e => {
    switch (e.name) {
     case "__Directive":
     case "__DirectiveLocation":
     case "__EnumValue":
     case "__InputValue":
     case "__Field":
     case "__Type":
     case "__TypeKind":
     case "__Schema":
      return !1;

     default:
      return "SCALAR" === e.kind || "ENUM" === e.kind || "INPUT_OBJECT" === e.kind || "OBJECT" === e.kind || "INTERFACE" === e.kind || "UNION" === e.kind;
    }
  })).map(minifyIntrospectionType).sort(nameCompare);
  return {
    __schema: {
      queryType: {
        kind: r.kind,
        name: r.name
      },
      mutationType: n ? {
        kind: n.kind,
        name: n.name
      } : null,
      subscriptionType: t ? {
        kind: t.kind,
        name: t.name
      } : null,
      types: a,
      directives: []
    }
  };
};

exports.outputIntrospectionFile = function outputIntrospectionFile(e, r) {
  if (/\.d\.ts$/.test(r.fileType)) {
    var n = "string" != typeof e && r.shouldPreprocess ? preprocessIntrospection(e) : stringifyJson(e);
    return [ F, C, `export type introspection = ${n};\n`, "import * as gqlTada from 'gql.tada';\n", "declare module 'gql.tada' {", "  interface setupSchema {", "    introspection: introspection", "  }", "}" ].join("\n");
  } else if (/\.ts$/.test(r.fileType)) {
    var t = stringifyJson(e);
    return [ F, R, `const introspection = ${t} as const;\n`, "export { introspection };" ].join("\n");
  }
  throw new TadaError(`No available introspection format for "${r.fileType}" (expected ".ts" or ".d.ts")`);
};

exports.parseConfig = e => {
  if (e.schema && "object" == typeof e.schema) {
    var {schema: r} = e;
    if (!("url" in r)) {
      throw new TadaError("Configuration contains a `schema` object, but no `url` property");
    }
    if ("headers" in r && r.headers && "object" == typeof r.headers) {
      for (var n in r.headers) {
        if (r.headers[n] && "string" != typeof r.headers[n]) {
          throw new TadaError("Headers at `schema.headers` contain a non-string value at key: " + n);
        }
      }
    } else if ("headers" in r) {
      throw new TadaError("Configuration contains a `schema.headers` property, but it's not an object");
    }
  } else if ("string" != typeof e.schema) {
    throw new TadaError("Configuration is missing a `schema` property");
  } else if ("tadaOutputLocation" in e && e.tadaOutputLocation && "string" != typeof e.tadaOutputLocation) {
    throw new TadaError("Configuration contains a `tadaOutputLocation` property, but it's not a file path");
  } else if ("tadaTurboLocation" in e && e.tadaTurboLocation && "string" != typeof e.tadaTurboLocation) {
    throw new TadaError("Configuration contains a `tadaTurboLocation` property, but it's not a file path");
  } else if ("tadaPersistedLocation" in e && e.tadaPersistedLocation && "string" != typeof e.tadaPersistedLocation) {
    throw new TadaError("Configuration contains a `tadaPersistedLocation` property, but it's not a file path");
  } else if ("template" in e && e.template && "string" != typeof e.template) {
    throw new TadaError("Configuration contains a `template` property, but it's not a string");
  }
  return e;
};

exports.preprocessIntrospection = preprocessIntrospection;

exports.readTSConfigFile = readTSConfigFile;

exports.resolveModuleFile = async function resolveModuleFile(e) {
  var n = e.indexOf("/");
  var t = e.slice(0, n);
  var a = e.slice(n);
  var o = `${t}/package.json`;
  var s = p(o, {
    paths: [ "node_modules", ...p.paths(o) || [] ]
  });
  if (!s) {
    throw new Error(`Failed to resolve "${t}"`);
  }
  var d = r.join(r.dirname(s), a);
  return i.readFile(d, {
    encoding: "utf8"
  });
};

exports.resolveTypeScriptRootDir = async e => {
  try {
    var r = await loadConfig(e);
    return s.dirname(r.configPath);
  } catch (e) {
    return;
  }
};
//# sourceMappingURL=gql-tada-internal.js.map
