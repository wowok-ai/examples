import * as typescript from 'typescript';
import {
  CompilerHost,
  ScriptTarget,
  CreateSourceFileOptions,
  ResolvedModule,
  Diagnostic,
} from 'typescript';
import { IntrospectionQuery, GraphQLSchema } from 'graphql';
import { TsConfigJson } from 'type-fest';

declare function normalize(filename: string): string;

/** @internal */
declare function importModule(host: CompilerHost, id: string): Promise<void>;
/** @internal */
declare function importLib(host: CompilerHost): Promise<void>;
/** @internal */
declare function resolveModuleFile(from: string): Promise<string>;

/** @internal */
type VirtualCompilerHost = ReturnType<typeof createVirtualHost> & CompilerHost;
/** @internal */
declare const createProgram: (rootNames: string[], host: CompilerHost) => typescript.Program;
/** @internal */
declare function createVirtualHost(): {
  getCanonicalFileName: typeof normalize;
  getDefaultLibFileName(): string;
  getCurrentDirectory(): '/' | '\\';
  getNewLine(): string;
  getModuleResolutionCache(): typescript.ModuleResolutionCache;
  useCaseSensitiveFileNames(): true;
  fileExists(filename: string): boolean;
  directoryExists(directoryName: string): boolean;
  writeFile(filename: string, content: Uint8Array | string): void;
  getDirectories(directoryName: string): string[];
  readFile(filename: string): string | undefined;
  getSourceFile(
    filename: string,
    languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions
  ): typescript.SourceFile | undefined;
  resolveModuleNames(moduleNames: string[], containingFile: string): (ResolvedModule | undefined)[];
};

interface SchemaLoaderResult {
  introspection: IntrospectionQuery;
  schema: GraphQLSchema;
}
type OnSchemaUpdate = (result: SchemaLoaderResult) => void;
interface SchemaLoader {
  load(reload?: boolean): Promise<SchemaLoaderResult>;
  notifyOnUpdate(onUpdate: OnSchemaUpdate): () => void;
  /** @internal */
  loadIntrospection(): Promise<IntrospectionQuery | null>;
  /** @internal */
  loadSchema(): Promise<GraphQLSchema | null>;
}
type SchemaOrigin =
  | string
  | {
      url: string;
      headers?: HeadersInit;
    };

interface LoadFromSDLConfig {
  assumeValid?: boolean;
  file: string;
}
declare function loadFromSDL(config: LoadFromSDLConfig): SchemaLoader;

interface LoadFromURLConfig {
  url: URL | string;
  headers?: HeadersInit;
  interval?: number;
}
declare function loadFromURL(config: LoadFromURLConfig): SchemaLoader;

interface LoadConfig {
  origin: SchemaOrigin;
  rootPath?: string;
  fetchInterval?: number;
  assumeValid?: boolean;
}
declare function load(config: LoadConfig): SchemaLoader;

declare class TSError extends Error {
  readonly name: 'TSError';
  readonly diagnostic: Diagnostic;
  constructor(diagnostic: Diagnostic);
}
declare class TadaError extends Error {
  readonly name: 'TadaError';
  constructor(message: string);
}

interface GraphQLSPConfig {
  schema: SchemaOrigin;
  tadaOutputLocation?: string;
  tadaTurboLocation?: string;
  tadaPersistedLocation?: string;
  template?: string;
}
declare const parseConfig: (input: Record<string, unknown>) => GraphQLSPConfig;

declare const readTSConfigFile: (filePath: string) => Promise<TsConfigJson>;
declare const findTSConfigFile: (targetPath?: string) => Promise<string | null>;
interface LoadConfigResult {
  pluginConfig: Record<string, unknown>;
  configPath: string;
  rootPath: string;
}
declare const loadConfig: (targetPath?: string) => Promise<LoadConfigResult>;
/** @deprecated Use {@link loadConfig} instead */
declare const resolveTypeScriptRootDir: (tsconfigPath: string) => Promise<string | undefined>;

/** Minifies an {@link IntrospectionQuery} for use with Graphcache or the `populateExchange`.
 *
 * @param schema - An {@link IntrospectionQuery} object to be minified.
 * @param opts - An optional {@link MinifySchemaOptions} configuration object.
 * @returns the minified {@link IntrospectionQuery} object.
 *
 * @remarks
 * `minifyIntrospectionQuery` reduces the size of an {@link IntrospectionQuery} by
 * removing data and information that a client-side consumer, like Graphcache or the
 * `populateExchange`, may not require.
 *
 * At the very least, it will remove system types, descriptions, depreactions,
 * and source locations. Unless disabled via the options passed, it will also
 * by default remove all scalars, enums, inputs, and directives.
 *
 * @throws
 * If `schema` receives an object that isnâ€™t an {@link IntrospectionQuery}, a
 * {@link TypeError} will be thrown.
 */
declare const minifyIntrospectionQuery: (schema: IntrospectionQuery) => IntrospectionQuery;

declare function preprocessIntrospection({ __schema: schema }: IntrospectionQuery): string;

interface OutputIntrospectionFileOptions {
  fileType: '.ts' | '.d.ts' | string;
  shouldPreprocess?: boolean;
}
declare function outputIntrospectionFile(
  introspection: IntrospectionQuery | string,
  opts: OutputIntrospectionFileOptions
): string;

export {
  type GraphQLSPConfig,
  type LoadConfig,
  type LoadConfigResult,
  type OnSchemaUpdate,
  type SchemaLoader,
  type SchemaLoaderResult,
  type SchemaOrigin,
  TSError,
  TadaError,
  type VirtualCompilerHost,
  createProgram,
  createVirtualHost,
  findTSConfigFile,
  importLib,
  importModule,
  load,
  loadConfig,
  loadFromSDL,
  loadFromURL,
  minifyIntrospectionQuery as minifyIntrospection,
  outputIntrospectionFile,
  parseConfig,
  preprocessIntrospection,
  readTSConfigFile,
  resolveModuleFile,
  resolveTypeScriptRootDir,
};
