{"version":3,"file":"gql-tada-internal.mjs","sources":["../src/vfs/compilerOptions.ts","../src/vfs/host.ts","../src/vfs/utils.ts","../src/vfs/import.ts","../src/vfs/index.ts","../../../node_modules/.pnpm/@urql+core@4.3.0_graphql@16.8.1/node_modules/@urql/core/dist/urql-core-chunk.mjs","../src/loaders/query.ts","../src/loaders/sdl.ts","../../../node_modules/.pnpm/@urql+exchange-retry@1.2.1_graphql@16.8.1/node_modules/@urql/exchange-retry/dist/urql-exchange-retry.mjs","../src/loaders/url.ts","../src/loaders/index.ts","../src/helpers.ts","../src/errors.ts","../src/config.ts","../src/resolve.ts","../src/introspection/minify.ts","../src/introspection/preprocess.ts","../src/introspection/constants.ts","../src/introspection/output.ts"],"sourcesContent":["import type { CompilerOptions } from 'typescript';\n\nimport { ScriptTarget, JsxEmit, ModuleResolutionKind } from 'typescript';\n\nexport const compilerOptions: CompilerOptions = {\n  rootDir: '/',\n  moduleResolution: ModuleResolutionKind.Bundler,\n  skipLibCheck: true,\n  skipDefaultLibCheck: true,\n  allowImportingTsExtensions: true,\n  allowSyntheticDefaultImports: true,\n  resolvePackageJsonExports: true,\n  resolvePackageJsonImports: true,\n  resolveJsonModule: true,\n  esModuleInterop: true,\n  jsx: JsxEmit.Preserve,\n  target: ScriptTarget.Latest,\n  checkJs: false,\n  allowJs: true,\n  strict: true,\n  noEmit: true,\n  noLib: false,\n  disableReferencedProjectLoad: true,\n  disableSourceOfProjectReferenceRedirect: true,\n  disableSizeLimit: true,\n  disableSolutionSearching: true,\n};\n","import type { ScriptTarget, CreateSourceFileOptions, SourceFile } from 'typescript';\n\nimport { createSourceFile } from 'typescript';\nimport { posix as path } from 'node:path';\n\nimport type { TargetCache } from './utils';\nimport { createTargetCache, setTargetCache, getTargetCache } from './utils';\n\nexport type FileData = Uint8Array | string;\nexport type Files = Record<string, FileData>;\n\nexport class File {\n  cache: TargetCache<SourceFile>;\n  name: string;\n  data: Uint8Array | null;\n  text: string | null;\n  constructor(name: string, data: Uint8Array | string) {\n    this.cache = createTargetCache();\n    this.name = normalize(name);\n    if (typeof data === 'string') {\n      this.text = data || '\\n';\n      this.data = null;\n    } else {\n      this.text = null;\n      this.data = data;\n    }\n  }\n\n  toSourceFile(opts: ScriptTarget | CreateSourceFileOptions) {\n    const target = typeof opts === 'object' ? opts.languageVersion : opts;\n    return (\n      getTargetCache(this.cache, target) ||\n      setTargetCache(this.cache, target, createSourceFile(this.name, this.toString(), opts))\n    );\n  }\n\n  toBuffer(): Uint8Array {\n    return this.data || (this.data = new TextEncoder().encode(this.text!));\n  }\n\n  toString() {\n    return this.text || (this.text = new TextDecoder().decode(this.data!));\n  }\n}\n\nexport class Directory {\n  children: Record<string, Directory | undefined>;\n  files: Record<string, File | undefined>;\n  constructor() {\n    this.children = Object.create(null);\n    this.files = Object.create(null);\n  }\n\n  getOrCreateDirectory(name: string): Directory {\n    return this.children[name] || (this.children[name] = new Directory());\n  }\n}\n\nexport function normalize(filename: string) {\n  return path.normalize(!filename.startsWith(path.sep) ? path.sep + filename : filename);\n}\n\nexport function split(filename: string): string[] {\n  return filename !== path.sep ? filename.split(path.sep).slice(1) : [];\n}\n\nexport const sep = path.sep;\n","import { ScriptTarget } from 'typescript';\n\nexport type TargetCache<T> = { readonly _opaque: unique symbol } & Record<string, T | null>;\n\nfunction createTargetCache<T>(): TargetCache<T> {\n  return {\n    [ScriptTarget[ScriptTarget.ES3]]: null,\n    [ScriptTarget[ScriptTarget.ES5]]: null,\n    [ScriptTarget[ScriptTarget.ES2015]]: null,\n    [ScriptTarget[ScriptTarget.ES2016]]: null,\n    [ScriptTarget[ScriptTarget.ES2017]]: null,\n    [ScriptTarget[ScriptTarget.ES2018]]: null,\n    [ScriptTarget[ScriptTarget.ES2019]]: null,\n    [ScriptTarget[ScriptTarget.ES2020]]: null,\n    [ScriptTarget[ScriptTarget.ES2021]]: null,\n    [ScriptTarget[ScriptTarget.ES2022]]: null,\n    [ScriptTarget[ScriptTarget.Latest]]: null,\n    [ScriptTarget[ScriptTarget.JSON]]: null,\n  } as TargetCache<T>;\n}\n\nfunction setTargetCache<T>(cache: TargetCache<T>, key: ScriptTarget, value: T): T {\n  cache[ScriptTarget[key]] = value;\n  return value;\n}\n\nfunction getTargetCache<T>(cache: TargetCache<T>, key: ScriptTarget): T | null {\n  return cache[ScriptTarget[key]] || null;\n}\n\nexport { createTargetCache, setTargetCache, getTargetCache };\n","import type { CompilerHost } from 'typescript';\n\nimport path from 'node:path';\nimport fs from 'node:fs/promises';\nimport { createRequire } from 'node:module';\nimport { compilerOptions } from './compilerOptions';\n\nconst requireResolve =\n  typeof require === 'function' ? require.resolve : createRequire(import.meta.url).resolve;\n\nconst toPath = (input: string) => input.split(path.sep).join('/');\n\n/** @internal */\nexport async function importModule(host: CompilerHost, id: string) {\n  const request = `${id}/package.json`;\n  const module = requireResolve(request, {\n    paths: ['node_modules', ...(requireResolve.paths(request) || [])],\n  });\n  if (!module) {\n    throw new Error(`Failed to resolve \"${id}\"`);\n  }\n\n  const fromBasePath = path.dirname(module);\n  const toBasePath = `/node_modules/${id}/`;\n\n  async function walk(directory: string) {\n    for (const entry of await fs.readdir(directory)) {\n      const fromFilePath = path.join(directory, entry);\n      if ((await fs.stat(fromFilePath)).isDirectory()) {\n        await walk(fromFilePath);\n      } else {\n        const toFilePath = path.join(path.relative(fromBasePath, directory), entry);\n        const data = await fs.readFile(fromFilePath, { encoding: 'utf8' });\n        host.writeFile(toBasePath + toPath(toFilePath), data, false);\n      }\n    }\n  }\n\n  await walk(fromBasePath);\n}\n\n/** @internal */\nexport async function importLib(host: CompilerHost) {\n  const request = 'typescript/package.json';\n  const module = requireResolve(request, {\n    paths: ['node_modules', ...(requireResolve.paths(request) || [])],\n  });\n  if (!module) {\n    throw new Error('Failed to resolve typescript');\n  }\n\n  const LIB_PATH = path.join(path.dirname(module), 'lib');\n  const LIB_FILES = [\n    'lib.es5.d.ts',\n    'lib.es2015.symbol.d.ts',\n    'lib.es2015.collection.d.ts',\n    'lib.es2015.iterable.d.ts',\n  ];\n\n  const contents = (\n    await Promise.all(\n      LIB_FILES.map((libFile) => fs.readFile(path.resolve(LIB_PATH, libFile), { encoding: 'utf8' }))\n    )\n  ).join('\\n');\n\n  host.writeFile(host.getDefaultLibFileName(compilerOptions), contents, false);\n}\n\n/** @internal */\nexport async function resolveModuleFile(from: string) {\n  const slashIndex = from.indexOf('/');\n  const id = from.slice(0, slashIndex);\n  const subpath = from.slice(slashIndex);\n  const request = `${id}/package.json`;\n  const module = requireResolve(request, {\n    paths: ['node_modules', ...(requireResolve.paths(request) || [])],\n  });\n  if (!module) {\n    throw new Error(`Failed to resolve \"${id}\"`);\n  }\n\n  const fromFilePath = path.join(path.dirname(module), subpath);\n  return fs.readFile(fromFilePath, { encoding: 'utf8' });\n}\n","import type {\n  CompilerHost,\n  ResolvedModule,\n  CreateSourceFileOptions,\n  ScriptTarget,\n} from 'typescript';\n\nimport {\n  createProgram as tsCreateProgram,\n  createModuleResolutionCache,\n  resolveModuleName,\n} from 'typescript';\n\nimport { compilerOptions } from './compilerOptions';\nimport { Directory, File, split, normalize, sep } from './host';\n\nconst ROOT_LIB_DTS_PATH = 'lib.d.ts';\nconst ROOT_LIB_DTS_DATA = '';\n\nexport { importLib, importModule, resolveModuleFile } from './import';\n\n/** @internal */\nexport type VirtualCompilerHost = ReturnType<typeof createVirtualHost> & CompilerHost;\n\n/** @internal */\nexport const createProgram = (rootNames: string[], host: CompilerHost) =>\n  tsCreateProgram(rootNames, compilerOptions, host);\n\n/** @internal */\nexport function createVirtualHost() {\n  const cache = createModuleResolutionCache(sep, normalize, compilerOptions);\n\n  const root = new Directory();\n  root.files[ROOT_LIB_DTS_PATH] = new File(ROOT_LIB_DTS_PATH, ROOT_LIB_DTS_DATA);\n\n  return {\n    getCanonicalFileName: normalize,\n\n    getDefaultLibFileName() {\n      return sep + ROOT_LIB_DTS_PATH;\n    },\n    getCurrentDirectory() {\n      return sep;\n    },\n    getNewLine() {\n      return '\\n';\n    },\n    getModuleResolutionCache() {\n      return cache;\n    },\n    useCaseSensitiveFileNames() {\n      return true;\n    },\n\n    fileExists(filename: string) {\n      const parts = split(normalize(filename));\n      let directory: Directory | undefined = root;\n      for (let i = 0; i < parts.length - 1; i++) {\n        directory = directory.children[parts[i]];\n        if (!directory) return false;\n      }\n      return !!directory.files[parts[parts.length - 1]];\n    },\n\n    directoryExists(directoryName: string) {\n      const parts = split(normalize(directoryName));\n      if (!parts.length) return true;\n      let directory: Directory | undefined = root;\n      for (let i = 0; i < parts.length - 1; i++) {\n        directory = directory.children[parts[i]];\n        if (!directory) return false;\n      }\n      return !!directory.children[parts[parts.length - 1]];\n    },\n\n    writeFile(filename: string, content: Uint8Array | string) {\n      const name = normalize(filename);\n      const parts = split(name);\n      let directory = root;\n      for (let i = 0; i < parts.length - 1; i++)\n        directory = directory.getOrCreateDirectory(parts[i]);\n      directory.files[parts[parts.length - 1]] = new File(name, content);\n    },\n\n    getDirectories(directoryName: string) {\n      const parts = split(normalize(directoryName));\n      let directory: Directory | undefined = root;\n      for (let i = 0; i < parts.length; i++) {\n        directory = directory.children[parts[i]];\n        if (!directory) return [];\n      }\n      return Object.keys(directory.children);\n    },\n\n    readFile(filename: string) {\n      const parts = split(normalize(filename));\n      let directory: Directory | undefined = root;\n      for (let i = 0; i < parts.length - 1; i++) {\n        directory = directory.children[parts[i]];\n        if (!directory) return undefined;\n      }\n      const file = directory.files[parts[parts.length - 1]];\n      return file && file.toString();\n    },\n\n    getSourceFile(\n      filename: string,\n      languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions\n    ) {\n      const parts = split(normalize(filename));\n      let directory: Directory | undefined = root;\n      for (let i = 0; i < parts.length - 1; i++) {\n        directory = directory.children[parts[i]];\n        if (!directory) return undefined;\n      }\n      const file = directory.files[parts[parts.length - 1]];\n      return file && file.toSourceFile(languageVersionOrOptions);\n    },\n\n    resolveModuleNames(moduleNames: string[], containingFile: string) {\n      const resolvedModules: (ResolvedModule | undefined)[] = [];\n      for (const moduleName of moduleNames) {\n        const result = resolveModuleName(moduleName, containingFile, compilerOptions, this, cache);\n        resolvedModules.push(result.resolvedModule);\n      }\n      return resolvedModules;\n    },\n  } satisfies CompilerHost;\n}\n","import { GraphQLError as e, print as r, parse as t, Kind as a } from \"@0no-co/graphql.web\";\n\nimport { onEnd as o, filter as n, fromAsyncIterable as s } from \"wonka\";\n\nvar rehydrateGraphQlError = r => {\n  if (r && r.message && (r.extensions || \"GraphQLError\" === r.name)) {\n    return r;\n  } else if (\"object\" == typeof r && r.message) {\n    return new e(r.message, r.nodes, r.source, r.positions, r.path, r, r.extensions || {});\n  } else {\n    return new e(r);\n  }\n};\n\nclass CombinedError extends Error {\n  constructor(e) {\n    var r = (e.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((e, r) => {\n      var t = \"\";\n      if (e) {\n        return `[Network] ${e.message}`;\n      }\n      if (r) {\n        for (var a of r) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(e.networkError, r);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = r;\n    this.networkError = e.networkError;\n    this.response = e.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\nvar phash = (e, r) => {\n  var t = 0 | (r || 5381);\n  for (var a = 0, o = 0 | e.length; a < o; a++) {\n    t = (t << 5) + t + e.charCodeAt(a);\n  }\n  return t;\n};\n\nvar i = new Set;\n\nvar f = new WeakMap;\n\nvar stringify = e => {\n  if (null === e || i.has(e)) {\n    return \"null\";\n  } else if (\"object\" != typeof e) {\n    return JSON.stringify(e) || \"\";\n  } else if (e.toJSON) {\n    return stringify(e.toJSON());\n  } else if (Array.isArray(e)) {\n    var r = \"[\";\n    for (var t of e) {\n      if (r.length > 1) {\n        r += \",\";\n      }\n      r += stringify(t) || \"null\";\n    }\n    return r += \"]\";\n  } else if (l !== NoopConstructor && e instanceof l || c !== NoopConstructor && e instanceof c) {\n    return \"null\";\n  }\n  var a = Object.keys(e).sort();\n  if (!a.length && e.constructor && Object.getPrototypeOf(e).constructor !== Object.prototype.constructor) {\n    var o = f.get(e) || Math.random().toString(36).slice(2);\n    f.set(e, o);\n    return stringify({\n      __key: o\n    });\n  }\n  i.add(e);\n  var n = \"{\";\n  for (var s of a) {\n    var d = stringify(e[s]);\n    if (d) {\n      if (n.length > 1) {\n        n += \",\";\n      }\n      n += stringify(s) + \":\" + d;\n    }\n  }\n  i.delete(e);\n  return n += \"}\";\n};\n\nvar extract = (e, r, t) => {\n  if (null == t || \"object\" != typeof t || t.toJSON || i.has(t)) {} else if (Array.isArray(t)) {\n    for (var a = 0, o = t.length; a < o; a++) {\n      extract(e, `${r}.${a}`, t[a]);\n    }\n  } else if (t instanceof l || t instanceof c) {\n    e.set(r, t);\n  } else {\n    i.add(t);\n    for (var n of Object.keys(t)) {\n      extract(e, `${r}.${n}`, t[n]);\n    }\n  }\n};\n\nvar stringifyVariables = e => {\n  i.clear();\n  return stringify(e);\n};\n\nclass NoopConstructor {}\n\nvar l = \"undefined\" != typeof File ? File : NoopConstructor;\n\nvar c = \"undefined\" != typeof Blob ? Blob : NoopConstructor;\n\nvar d = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\n\nvar v = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\n\nvar replaceOutsideStrings = (e, r) => r % 2 == 0 ? e.replace(v, \"\\n\") : e;\n\nvar sanitizeDocument = e => e.split(d).map(replaceOutsideStrings).join(\"\").trim();\n\nvar p = new Map;\n\nvar u = new Map;\n\nvar stringifyDocument = e => {\n  var t;\n  if (\"string\" == typeof e) {\n    t = sanitizeDocument(e);\n  } else if (e.loc && u.get(e.__key) === e) {\n    t = e.loc.source.body;\n  } else {\n    t = p.get(e) || sanitizeDocument(r(e));\n    p.set(e, t);\n  }\n  if (\"string\" != typeof e && !e.loc) {\n    e.loc = {\n      start: 0,\n      end: t.length,\n      source: {\n        body: t,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return t;\n};\n\nvar hashDocument = e => {\n  var r = phash(stringifyDocument(e));\n  if (e.definitions) {\n    var t = getOperationName(e);\n    if (t) {\n      r = phash(`\\n# ${t}`, r);\n    }\n  }\n  return r;\n};\n\nvar keyDocument = e => {\n  var r;\n  var a;\n  if (\"string\" == typeof e) {\n    r = hashDocument(e);\n    a = u.get(r) || t(e, {\n      noLocation: !0\n    });\n  } else {\n    r = e.__key || hashDocument(e);\n    a = u.get(r) || e;\n  }\n  if (!a.loc) {\n    stringifyDocument(a);\n  }\n  a.__key = r;\n  u.set(r, a);\n  return a;\n};\n\nvar createRequest = (e, r, t) => {\n  var a = r || {};\n  var o = keyDocument(e);\n  var n = stringifyVariables(a);\n  var s = o.__key;\n  if (\"{}\" !== n) {\n    s = phash(n, s);\n  }\n  return {\n    key: s,\n    query: o,\n    variables: a,\n    extensions: t\n  };\n};\n\nvar getOperationName = e => {\n  for (var r of e.definitions) {\n    if (r.kind === a.OPERATION_DEFINITION) {\n      return r.name ? r.name.value : void 0;\n    }\n  }\n};\n\nvar getOperationType = e => {\n  for (var r of e.definitions) {\n    if (r.kind === a.OPERATION_DEFINITION) {\n      return r.operation;\n    }\n  }\n};\n\nvar makeResult = (e, r, t) => {\n  if (!(\"data\" in r || \"errors\" in r && Array.isArray(r.errors))) {\n    throw new Error(\"No Content\");\n  }\n  var a = \"subscription\" === e.kind;\n  return {\n    operation: e,\n    data: r.data,\n    error: Array.isArray(r.errors) ? new CombinedError({\n      graphQLErrors: r.errors,\n      response: t\n    }) : void 0,\n    extensions: r.extensions ? {\n      ...r.extensions\n    } : void 0,\n    hasNext: null == r.hasNext ? a : r.hasNext,\n    stale: !1\n  };\n};\n\nvar deepMerge = (e, r) => {\n  if (\"object\" == typeof e && null != e) {\n    if (!e.constructor || e.constructor === Object || Array.isArray(e)) {\n      e = Array.isArray(e) ? [ ...e ] : {\n        ...e\n      };\n      for (var t of Object.keys(r)) {\n        e[t] = deepMerge(e[t], r[t]);\n      }\n      return e;\n    }\n  }\n  return r;\n};\n\nvar mergeResultPatch = (e, r, t, a) => {\n  var o = e.error ? e.error.graphQLErrors : [];\n  var n = !!e.extensions || !!(r.payload || r).extensions;\n  var s = {\n    ...e.extensions,\n    ...(r.payload || r).extensions\n  };\n  var i = r.incremental;\n  if (\"path\" in r) {\n    i = [ r ];\n  }\n  var f = {\n    data: e.data\n  };\n  if (i) {\n    var _loop = function(e) {\n      if (Array.isArray(e.errors)) {\n        o.push(...e.errors);\n      }\n      if (e.extensions) {\n        Object.assign(s, e.extensions);\n        n = !0;\n      }\n      var r = \"data\";\n      var t = f;\n      var i = [];\n      if (e.path) {\n        i = e.path;\n      } else if (a) {\n        var l = a.find((r => r.id === e.id));\n        if (e.subPath) {\n          i = [ ...l.path, ...e.subPath ];\n        } else {\n          i = l.path;\n        }\n      }\n      for (var c = 0, d = i.length; c < d; r = i[c++]) {\n        t = t[r] = Array.isArray(t[r]) ? [ ...t[r] ] : {\n          ...t[r]\n        };\n      }\n      if (e.items) {\n        var v = +r >= 0 ? r : 0;\n        for (var p = 0, u = e.items.length; p < u; p++) {\n          t[v + p] = deepMerge(t[v + p], e.items[p]);\n        }\n      } else if (void 0 !== e.data) {\n        t[r] = deepMerge(t[r], e.data);\n      }\n    };\n    for (var l of i) {\n      _loop(l);\n    }\n  } else {\n    f.data = (r.payload || r).data || e.data;\n    o = r.errors || r.payload && r.payload.errors || o;\n  }\n  return {\n    operation: e.operation,\n    data: f.data,\n    error: o.length ? new CombinedError({\n      graphQLErrors: o,\n      response: t\n    }) : void 0,\n    extensions: n ? s : void 0,\n    hasNext: null != r.hasNext ? r.hasNext : e.hasNext,\n    stale: !1\n  };\n};\n\nvar makeErrorResult = (e, r, t) => ({\n  operation: e,\n  data: void 0,\n  error: new CombinedError({\n    networkError: r,\n    response: t\n  }),\n  extensions: void 0,\n  hasNext: !1,\n  stale: !1\n});\n\nfunction makeFetchBody(e) {\n  var r = {\n    query: void 0,\n    documentId: void 0,\n    operationName: getOperationName(e.query),\n    variables: e.variables || void 0,\n    extensions: e.extensions\n  };\n  if (\"documentId\" in e.query && e.query.documentId && (!e.query.definitions || !e.query.definitions.length)) {\n    r.documentId = e.query.documentId;\n  } else if (!e.extensions || !e.extensions.persistedQuery || e.extensions.persistedQuery.miss) {\n    r.query = stringifyDocument(e.query);\n  }\n  return r;\n}\n\nvar makeFetchURL = (e, r) => {\n  var t = \"query\" === e.kind && e.context.preferGetMethod;\n  if (!t || !r) {\n    return e.context.url;\n  }\n  var a = splitOutSearchParams(e.context.url);\n  for (var o in r) {\n    var n = r[o];\n    if (n) {\n      a[1].set(o, \"object\" == typeof n ? stringifyVariables(n) : n);\n    }\n  }\n  var s = a.join(\"?\");\n  if (s.length > 2047 && \"force\" !== t) {\n    e.context.preferGetMethod = !1;\n    return e.context.url;\n  }\n  return s;\n};\n\nvar splitOutSearchParams = e => {\n  var r = e.indexOf(\"?\");\n  return r > -1 ? [ e.slice(0, r), new URLSearchParams(e.slice(r + 1)) ] : [ e, new URLSearchParams ];\n};\n\nvar serializeBody = (e, r) => {\n  if (r && !(\"query\" === e.kind && !!e.context.preferGetMethod)) {\n    var t = stringifyVariables(r);\n    var a = (e => {\n      var r = new Map;\n      if (l !== NoopConstructor || c !== NoopConstructor) {\n        i.clear();\n        extract(r, \"variables\", e);\n      }\n      return r;\n    })(r.variables);\n    if (a.size) {\n      var o = new FormData;\n      o.append(\"operations\", t);\n      o.append(\"map\", stringifyVariables({\n        ...[ ...a.keys() ].map((e => [ e ]))\n      }));\n      var n = 0;\n      for (var s of a.values()) {\n        o.append(\"\" + n++, s);\n      }\n      return o;\n    }\n    return t;\n  }\n};\n\nvar makeFetchOptions = (e, r) => {\n  var t = {\n    accept: \"subscription\" === e.kind ? \"text/event-stream, multipart/mixed\" : \"application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed\"\n  };\n  var a = (\"function\" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions) || {};\n  if (a.headers) {\n    if ((e => \"has\" in e && !Object.keys(e).length)(a.headers)) {\n      a.headers.forEach(((e, r) => {\n        t[r] = e;\n      }));\n    } else if (Array.isArray(a.headers)) {\n      a.headers.forEach(((e, r) => {\n        if (Array.isArray(e)) {\n          if (t[e[0]]) {\n            t[e[0]] = `${t[e[0]]},${e[1]}`;\n          } else {\n            t[e[0]] = e[1];\n          }\n        } else {\n          t[r] = e;\n        }\n      }));\n    } else {\n      for (var o in a.headers) {\n        t[o.toLowerCase()] = a.headers[o];\n      }\n    }\n  }\n  var n = serializeBody(e, r);\n  if (\"string\" == typeof n && !t[\"content-type\"]) {\n    t[\"content-type\"] = \"application/json\";\n  }\n  return {\n    ...a,\n    method: n ? \"POST\" : \"GET\",\n    body: n,\n    headers: t\n  };\n};\n\nvar y = \"undefined\" != typeof TextDecoder ? new TextDecoder : null;\n\nvar h = /boundary=\"?([^=\";]+)\"?/i;\n\nvar m = /data: ?([^\\n]+)/;\n\nvar toString = e => \"Buffer\" === e.constructor.name ? e.toString() : y.decode(e);\n\nasync function* streamBody(e) {\n  if (e.body[Symbol.asyncIterator]) {\n    for await (var r of e.body) {\n      yield toString(r);\n    }\n  } else {\n    var t = e.body.getReader();\n    var a;\n    try {\n      while (!(a = await t.read()).done) {\n        yield toString(a.value);\n      }\n    } finally {\n      t.cancel();\n    }\n  }\n}\n\nasync function* split(e, r) {\n  var t = \"\";\n  var a;\n  for await (var o of e) {\n    t += o;\n    while ((a = t.indexOf(r)) > -1) {\n      yield t.slice(0, a);\n      t = t.slice(a + r.length);\n    }\n  }\n}\n\nasync function* fetchOperation(e, r, t) {\n  var a = !0;\n  var o = null;\n  var n;\n  try {\n    yield await Promise.resolve();\n    var s = (n = await (e.context.fetch || fetch)(r, t)).headers.get(\"Content-Type\") || \"\";\n    var i;\n    if (/multipart\\/mixed/i.test(s)) {\n      i = async function* parseMultipartMixed(e, r) {\n        var t = e.match(h);\n        var a = \"--\" + (t ? t[1] : \"-\");\n        var o = !0;\n        var n;\n        for await (var s of split(streamBody(r), \"\\r\\n\" + a)) {\n          if (o) {\n            o = !1;\n            var i = s.indexOf(a);\n            if (i > -1) {\n              s = s.slice(i + a.length);\n            } else {\n              continue;\n            }\n          }\n          try {\n            yield n = JSON.parse(s.slice(s.indexOf(\"\\r\\n\\r\\n\") + 4));\n          } catch (e) {\n            if (!n) {\n              throw e;\n            }\n          }\n          if (n && !1 === n.hasNext) {\n            break;\n          }\n        }\n        if (n && !1 !== n.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(s, n);\n    } else if (/text\\/event-stream/i.test(s)) {\n      i = async function* parseEventStream(e) {\n        var r;\n        for await (var t of split(streamBody(e), \"\\n\\n\")) {\n          var a = t.match(m);\n          if (a) {\n            var o = a[1];\n            try {\n              yield r = JSON.parse(o);\n            } catch (e) {\n              if (!r) {\n                throw e;\n              }\n            }\n            if (r && !1 === r.hasNext) {\n              break;\n            }\n          }\n        }\n        if (r && !1 !== r.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(n);\n    } else if (!/text\\//i.test(s)) {\n      i = async function* parseJSON(e) {\n        yield JSON.parse(await e.text());\n      }(n);\n    } else {\n      i = async function* parseMaybeJSON(e) {\n        var r = await e.text();\n        try {\n          var t = JSON.parse(r);\n          if (\"production\" !== process.env.NODE_ENV) {\n            console.warn('Found response with content-type \"text/plain\" but it had a valid \"application/json\" response.');\n          }\n          yield t;\n        } catch (e) {\n          throw new Error(r);\n        }\n      }(n);\n    }\n    var f;\n    for await (var l of i) {\n      if (l.pending && !o) {\n        f = l.pending;\n      } else if (l.pending) {\n        f = [ ...f, ...l.pending ];\n      }\n      o = o ? mergeResultPatch(o, l, n, f) : makeResult(e, l, n);\n      a = !1;\n      yield o;\n      a = !0;\n    }\n    if (!o) {\n      yield o = makeResult(e, {}, n);\n    }\n  } catch (r) {\n    if (!a) {\n      throw r;\n    }\n    yield makeErrorResult(e, n && (n.status < 200 || n.status >= 300) && n.statusText ? new Error(n.statusText) : r, n);\n  }\n}\n\nfunction makeFetchSource(e, r, t) {\n  var a;\n  if (\"undefined\" != typeof AbortController) {\n    t.signal = (a = new AbortController).signal;\n  }\n  return o((() => {\n    if (a) {\n      a.abort();\n    }\n  }))(n((e => !!e))(s(fetchOperation(e, r, t))));\n}\n\nexport { CombinedError as C, makeFetchBody as a, makeErrorResult as b, mergeResultPatch as c, makeFetchURL as d, makeFetchOptions as e, makeFetchSource as f, getOperationType as g, createRequest as h, stringifyVariables as i, keyDocument as k, makeResult as m, stringifyDocument as s };\n//# sourceMappingURL=urql-core-chunk.mjs.map\n","import { Kind, OperationTypeNode } from '@0no-co/graphql.web';\n\nimport type {\n  SelectionSetNode,\n  FragmentDefinitionNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DocumentNode,\n} from '@0no-co/graphql.web';\n\n/** Support matrix to be used in the {@link makeIntrospectionQuery} builder */\nexport interface SupportedFeatures {\n  directiveIsRepeatable: boolean;\n  specifiedByURL: boolean;\n  inputValueDeprecation: boolean;\n  directiveArgumentsIsDeprecated: boolean;\n  fieldArgumentsIsDeprecated: boolean;\n}\n\n/** Data from a {@link makeIntrospectSupportQuery} result */\nexport interface IntrospectSupportQueryData {\n  directive: { fields: { name: string; args: { name: string }[] | null }[] | null } | null;\n  type: { fields: { name: string }[] | null } | null;\n  field: { fields: { name: string; args: { name: string }[] | null }[] | null } | null;\n  inputValue: { fields: { name: string }[] | null } | null;\n}\n\nconst _hasField = (\n  data: IntrospectSupportQueryData[keyof IntrospectSupportQueryData],\n  fieldName: string\n): boolean => !!data && !!data.fields && data.fields.some((field) => field.name === fieldName);\n\nconst _supportsDeprecatedArgumentsArg = (\n  data: IntrospectSupportQueryData['field' | 'directive']\n): boolean => {\n  const argsField = data && data.fields && data.fields.find((field) => field.name === 'args');\n  return !!(\n    argsField &&\n    argsField.args &&\n    argsField.args.find((arg) => arg.name === 'includeDeprecated')\n  );\n};\n\n/** Evaluates data from a {@link makeIntrospectSupportQuery} result to {@link SupportedFeatures} */\nexport const toSupportedFeatures = (data: IntrospectSupportQueryData): SupportedFeatures => ({\n  directiveIsRepeatable: _hasField(data.directive, 'isRepeatable'),\n  specifiedByURL: _hasField(data.type, 'specifiedByURL'),\n  inputValueDeprecation: _hasField(data.inputValue, 'isDeprecated'),\n  directiveArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(data.directive),\n  fieldArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(data.field),\n});\n\nlet _introspectionQuery: DocumentNode | undefined;\nlet _previousSupport: SupportedFeatures | undefined;\n/** Builds an introspection query as AST */\nexport const makeIntrospectionQuery = (support: SupportedFeatures): DocumentNode => {\n  if (_introspectionQuery && _previousSupport === support) {\n    return _introspectionQuery;\n  } else {\n    return (_introspectionQuery = _makeIntrospectionQuery((_previousSupport = support)));\n  }\n};\n\nconst _makeIntrospectionQuery = (support: SupportedFeatures): DocumentNode => ({\n  kind: Kind.DOCUMENT,\n  definitions: [\n    {\n      kind: Kind.OPERATION_DEFINITION,\n      name: { kind: Kind.NAME, value: 'IntrospectionQuery' },\n      operation: OperationTypeNode.QUERY,\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: '__schema' },\n            selectionSet: _makeSchemaSelection(support),\n          },\n        ],\n      },\n    } satisfies OperationDefinitionNode,\n\n    _makeSchemaFullTypeFragment(support),\n    _makeSchemaInputValueFragment(support),\n    _makeTypeRefFragment(),\n  ],\n});\n\n/** Builds a support matrix query resulting in {@link IntrospectSupportQueryData} results */\nexport const makeIntrospectSupportQuery = (): DocumentNode => ({\n  kind: Kind.DOCUMENT,\n  definitions: [\n    {\n      kind: Kind.OPERATION_DEFINITION,\n      name: { kind: Kind.NAME, value: 'IntrospectSupportQuery' },\n      operation: OperationTypeNode.QUERY,\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'directive' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__Directive' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: true }),\n          },\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'field' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__Field' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: true }),\n          },\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'type' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__Type' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: false }),\n          },\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'inputValue' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__InputValue' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: false }),\n          },\n        ],\n      },\n    } satisfies OperationDefinitionNode,\n  ],\n});\n\nconst _makeFieldNamesSelection = (options: { includeArgs: boolean }): SelectionSetNode => ({\n  kind: Kind.SELECTION_SET,\n  selections: [\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'fields' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n          ...(options.includeArgs\n            ? ([\n                {\n                  kind: Kind.FIELD,\n                  name: { kind: Kind.NAME, value: 'args' },\n                  selectionSet: {\n                    kind: Kind.SELECTION_SET,\n                    selections: [\n                      {\n                        kind: Kind.FIELD,\n                        name: { kind: Kind.NAME, value: 'name' },\n                      },\n                    ],\n                  },\n                },\n              ] as const)\n            : []),\n        ],\n      },\n    },\n  ],\n});\n\nconst _makeSchemaSelection = (support: SupportedFeatures): SelectionSetNode => ({\n  kind: Kind.SELECTION_SET,\n  selections: [\n    // queryType { name }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'queryType' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n      },\n    },\n    // mutationType { name }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'mutationType' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n      },\n    },\n    // subscriptionType { name }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'subscriptionType' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n      },\n    },\n    // types { ...FullType }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'types' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FRAGMENT_SPREAD,\n            name: { kind: Kind.NAME, value: 'FullType' },\n          },\n        ],\n      },\n    },\n    // directives { name description locations args }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'directives' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'description' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'locations' },\n          },\n          _makeSchemaArgsField(support.directiveArgumentsIsDeprecated),\n          ...(support.directiveIsRepeatable\n            ? ([\n                {\n                  kind: Kind.FIELD,\n                  name: { kind: Kind.NAME, value: 'isRepeatable' },\n                },\n              ] as const)\n            : []),\n        ],\n      },\n    },\n  ],\n});\n\nconst _makeSchemaFullTypeFragment = (support: SupportedFeatures): FragmentDefinitionNode => ({\n  kind: Kind.FRAGMENT_DEFINITION,\n  name: { kind: Kind.NAME, value: 'FullType' },\n  typeCondition: { kind: Kind.NAMED_TYPE, name: { kind: Kind.NAME, value: '__Type' } },\n  selectionSet: {\n    kind: Kind.SELECTION_SET,\n    selections: [\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'kind' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'name' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'description' },\n      },\n      ...(support.specifiedByURL\n        ? ([\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'specifiedByURL' },\n            },\n          ] as const)\n        : []),\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'fields' },\n        arguments: [\n          {\n            kind: Kind.ARGUMENT,\n            name: { kind: Kind.NAME, value: 'includeDeprecated' },\n            value: { kind: Kind.BOOLEAN, value: true },\n          },\n        ],\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'name' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'description' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'isDeprecated' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'deprecationReason' },\n            },\n            _makeSchemaArgsField(support.fieldArgumentsIsDeprecated),\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'type' },\n              selectionSet: {\n                kind: Kind.SELECTION_SET,\n                selections: [\n                  {\n                    kind: Kind.FRAGMENT_SPREAD,\n                    name: { kind: Kind.NAME, value: 'TypeRef' },\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'interfaces' },\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'TypeRef' },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'possibleTypes' },\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'TypeRef' },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'inputFields' },\n        arguments: support.inputValueDeprecation\n          ? [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'includeDeprecated' },\n                value: { kind: Kind.BOOLEAN, value: true },\n              },\n            ]\n          : [],\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'InputValue' },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'enumValues' },\n        arguments: [\n          {\n            kind: Kind.ARGUMENT,\n            name: { kind: Kind.NAME, value: 'includeDeprecated' },\n            value: { kind: Kind.BOOLEAN, value: true },\n          },\n        ],\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n\n          selections: [\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'name' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'description' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'isDeprecated' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'deprecationReason' },\n            },\n          ],\n        },\n      },\n    ],\n  },\n});\n\nconst _makeSchemaArgsField = (supportsValueDeprecation: boolean): FieldNode => ({\n  kind: Kind.FIELD,\n  name: { kind: Kind.NAME, value: 'args' },\n  arguments: supportsValueDeprecation\n    ? [\n        {\n          kind: Kind.ARGUMENT,\n          name: { kind: Kind.NAME, value: 'includeDeprecated' },\n          value: { kind: Kind.BOOLEAN, value: true },\n        },\n      ]\n    : [],\n  selectionSet: {\n    kind: Kind.SELECTION_SET,\n    selections: [\n      {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: { kind: Kind.NAME, value: 'InputValue' },\n      },\n    ],\n  },\n});\n\nconst _makeSchemaInputValueFragment = (support: SupportedFeatures): FragmentDefinitionNode => ({\n  kind: Kind.FRAGMENT_DEFINITION,\n  name: { kind: Kind.NAME, value: 'InputValue' },\n  typeCondition: { kind: Kind.NAMED_TYPE, name: { kind: Kind.NAME, value: '__InputValue' } },\n  selectionSet: {\n    kind: Kind.SELECTION_SET,\n    selections: [\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'name' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'description' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'defaultValue' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'type' },\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'TypeRef' },\n            },\n          ],\n        },\n      },\n      ...(support.inputValueDeprecation\n        ? ([\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'isDeprecated' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'deprecationReason' },\n            },\n          ] as const)\n        : []),\n    ],\n  },\n});\n\nconst _makeTypeRefFragment = (): FragmentDefinitionNode => ({\n  kind: Kind.FRAGMENT_DEFINITION,\n  name: { kind: Kind.NAME, value: 'TypeRef' },\n  typeCondition: { kind: Kind.NAMED_TYPE, name: { kind: Kind.NAME, value: '__Type' } },\n  selectionSet: _makeTypeRefSelection(0),\n});\n\nconst _makeTypeRefSelection = (depth: number): SelectionSetNode => ({\n  kind: Kind.SELECTION_SET,\n  selections:\n    depth < 9\n      ? [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'kind' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'ofType' },\n            selectionSet: _makeTypeRefSelection(depth + 1),\n          },\n        ]\n      : [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'kind' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n});\n","import type { IntrospectionQuery } from 'graphql';\nimport { buildSchema, buildClientSchema, executeSync } from 'graphql';\nimport { CombinedError } from '@urql/core';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\nimport { makeIntrospectionQuery } from './query';\nimport type { SupportedFeatures } from './query';\n\nimport type { SchemaLoader, SchemaLoaderResult, OnSchemaUpdate } from './types';\n\ninterface LoadFromSDLConfig {\n  assumeValid?: boolean;\n  file: string;\n}\n\nconst ALL_SUPPORTED_FEATURES: SupportedFeatures = {\n  directiveIsRepeatable: true,\n  specifiedByURL: true,\n  inputValueDeprecation: true,\n  directiveArgumentsIsDeprecated: true,\n  fieldArgumentsIsDeprecated: true,\n};\n\nexport function loadFromSDL(config: LoadFromSDLConfig): SchemaLoader {\n  const subscriptions = new Set<OnSchemaUpdate>();\n\n  let controller: AbortController | null = null;\n  let result: SchemaLoaderResult | null = null;\n\n  const load = async (): Promise<SchemaLoaderResult> => {\n    const ext = path.extname(config.file);\n    const data = await fs.readFile(config.file, { encoding: 'utf8' });\n    if (ext === '.json') {\n      const introspection = JSON.parse(data) as IntrospectionQuery | null;\n      if (!introspection || !introspection.__schema) {\n        throw new Error(\n          'Parsing JSON introspection data failed.\\n' +\n            'The JSON payload did not evaluate to an introspection schema.'\n        );\n      }\n      return {\n        introspection,\n        schema: buildClientSchema(introspection, { assumeValid: !!config.assumeValid }),\n      };\n    } else {\n      const schema = buildSchema(data, { assumeValidSDL: !!config.assumeValid });\n      const query = makeIntrospectionQuery(ALL_SUPPORTED_FEATURES);\n      const queryResult = executeSync({ schema, document: query });\n      if (queryResult.errors) {\n        throw new CombinedError({ graphQLErrors: queryResult.errors as any[] });\n      } else if (queryResult.data) {\n        const introspection = queryResult.data as unknown as IntrospectionQuery;\n        return { introspection, schema };\n      } else {\n        throw new Error(\n          'Executing introspection against SDL schema failed.\\n' +\n            '`graphql` failed to return any schema data or error.'\n        );\n      }\n    }\n  };\n\n  const watch = async () => {\n    controller = new AbortController();\n    const watcher = fs.watch(config.file, {\n      signal: controller.signal,\n      persistent: false,\n    });\n    try {\n      for await (const _event of watcher) {\n        if ((result = await load())) {\n          for (const subscriber of subscriptions) subscriber(result);\n        }\n      }\n    } catch (error: any) {\n      if (error.name !== 'AbortError') throw error;\n    } finally {\n      controller = null;\n    }\n  };\n\n  return {\n    async load(reload?: boolean) {\n      return reload || !result ? (result = await load()) : result;\n    },\n    notifyOnUpdate(onUpdate) {\n      if (!subscriptions.size) watch();\n      subscriptions.add(onUpdate);\n      return () => {\n        subscriptions.delete(onUpdate);\n        if (!subscriptions.size && controller) {\n          controller.abort();\n        }\n      };\n    },\n    async loadIntrospection() {\n      const result = await this.load();\n      return result && result.introspection;\n    },\n    async loadSchema() {\n      const result = await this.load();\n      return result && result.schema;\n    },\n  };\n}\n","import { makeSubject as r, mergeMap as e, filter as t, takeUntil as a, debounce as o, fromValue as n, merge as i } from \"wonka\";\n\nimport { makeOperation as u } from \"@urql/core\";\n\nvar retryExchange = y => {\n  var {retryIf: d, retryWith: s} = y;\n  var l = y.initialDelayMs || 1e3;\n  var p = y.maxDelayMs || 15e3;\n  var m = y.maxNumberAttempts || 2;\n  var c = null != y.randomDelay ? !!y.randomDelay : !0;\n  return ({forward: y, dispatchDebug: v}) => f => {\n    var {source: h, next: x} = r();\n    var E = e((r => {\n      var e = r.context.retry || {\n        count: 0,\n        delay: null\n      };\n      var i = ++e.count;\n      var y = e.delay || l;\n      var d = Math.random() + 1.5;\n      if (c) {\n        if (y * d < p) {\n          y *= d;\n        } else {\n          y = p;\n        }\n      } else {\n        y = Math.min(i * l, p);\n      }\n      e.delay = y;\n      var s = t((e => (\"query\" === e.kind || \"teardown\" === e.kind) && e.key === r.key))(f);\n      \"production\" !== process.env.NODE_ENV && v({\n        type: \"retryAttempt\",\n        message: `The operation has failed and a retry has been triggered (${i} / ${m})`,\n        operation: r,\n        data: {\n          retryCount: i,\n          delayAmount: y\n        },\n        source: \"retryExchange\"\n      });\n      return a(s)(o((() => y))(n(u(r.kind, r, {\n        ...r.context,\n        retry: e\n      }))));\n    }))(h);\n    return t((r => {\n      var e = r.operation.context.retry;\n      if (!(r.error && (d ? d(r.error, r.operation) : s || r.error.networkError))) {\n        if (e) {\n          e.count = 0;\n          e.delay = null;\n        }\n        return !0;\n      }\n      if (!((e && e.count || 0) >= m - 1)) {\n        var t = s ? s(r.error, r.operation) : r.operation;\n        if (!t) {\n          return !0;\n        }\n        x(t);\n        return !1;\n      }\n      \"production\" !== process.env.NODE_ENV && v({\n        type: \"retryExhausted\",\n        message: \"Maximum number of retries has been reached. No further retries will be performed.\",\n        operation: r.operation,\n        source: \"retryExchange\"\n      });\n      return !0;\n    }))(y(i([ f, E ])));\n  };\n};\n\nexport { retryExchange };\n//# sourceMappingURL=urql-exchange-retry.mjs.map\n","import type { IntrospectionQuery } from 'graphql';\nimport { buildClientSchema } from 'graphql';\nimport { Client, fetchExchange } from '@urql/core';\nimport { retryExchange } from '@urql/exchange-retry';\n\nimport { makeIntrospectionQuery, makeIntrospectSupportQuery, toSupportedFeatures } from './query';\nimport type { SupportedFeatures, IntrospectSupportQueryData } from './query';\n\nimport type { SchemaLoader, SchemaLoaderResult, OnSchemaUpdate } from './types';\n\ninterface LoadFromURLConfig {\n  url: URL | string;\n  headers?: HeadersInit;\n  interval?: number;\n}\n\nconst ALL_SUPPORTED_FEATURES: SupportedFeatures = {\n  directiveIsRepeatable: true,\n  specifiedByURL: true,\n  inputValueDeprecation: true,\n  directiveArgumentsIsDeprecated: true,\n  fieldArgumentsIsDeprecated: true,\n};\n\nconst NO_SUPPORTED_FEATURES: SupportedFeatures = {\n  directiveIsRepeatable: false,\n  specifiedByURL: false,\n  inputValueDeprecation: false,\n  directiveArgumentsIsDeprecated: false,\n  fieldArgumentsIsDeprecated: false,\n};\n\nexport function loadFromURL(config: LoadFromURLConfig): SchemaLoader {\n  const interval = config.interval || 60_000;\n  const subscriptions = new Set<OnSchemaUpdate>();\n\n  let timeoutID: NodeJS.Timeout | null = null;\n  let supportedFeatures: SupportedFeatures | null = null;\n  let result: SchemaLoaderResult | null = null;\n\n  const client = new Client({\n    url: `${config.url}`,\n    fetchOptions: { headers: config.headers },\n    exchanges: [\n      retryExchange({\n        initialDelayMs: 200,\n        maxDelayMs: 1_500,\n        maxNumberAttempts: 3,\n        retryWith(error, operation) {\n          if (error.networkError) process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n          return operation;\n        },\n      }),\n      fetchExchange,\n    ],\n  });\n\n  const scheduleUpdate = () => {\n    if (subscriptions.size && !timeoutID) {\n      timeoutID = setTimeout(async () => {\n        timeoutID = null;\n        try {\n          result = await load();\n        } catch (_error) {\n          result = null;\n        }\n        if (result) for (const subscriber of subscriptions) subscriber(result);\n      }, interval);\n    }\n  };\n\n  const introspect = async (support: SupportedFeatures): Promise<SchemaLoaderResult> => {\n    const query = makeIntrospectionQuery(support);\n    const introspectionResult = await client.query<IntrospectionQuery>(query, {});\n    try {\n      if (introspectionResult.error) {\n        throw introspectionResult.error;\n      } else if (introspectionResult.data) {\n        const introspection = introspectionResult.data;\n        return {\n          introspection,\n          schema: buildClientSchema(introspection, { assumeValid: true }),\n        };\n      } else {\n        throw new Error(\n          'Executing introspection against API failed.\\n' +\n            'The API failed to return any schema data or error.'\n        );\n      }\n    } finally {\n      scheduleUpdate();\n    }\n  };\n\n  const load = async (): Promise<SchemaLoaderResult> => {\n    if (!supportedFeatures) {\n      const query = makeIntrospectSupportQuery();\n      const supportResult = await client.query<IntrospectSupportQueryData>(query, {});\n      if (supportResult.error && supportResult.error.graphQLErrors.length > 0) {\n        // If we failed to determine support, we try to activate all introspection features\n        const _result = await introspect(ALL_SUPPORTED_FEATURES);\n        if (_result) {\n          // If we succeed, we can return the introspection and enable all introspection features\n          supportedFeatures = ALL_SUPPORTED_FEATURES;\n          return _result;\n        } else {\n          // Otherwise, we assume no extra introspection features are supported,\n          // since all introspection spec additions were made in a single spec revision\n          supportedFeatures = NO_SUPPORTED_FEATURES;\n        }\n      } else if (supportResult.data && !supportResult.error) {\n        // Succeeding the support query, we get the supported features\n        supportedFeatures = toSupportedFeatures(supportResult.data);\n      } else if (supportResult.error) {\n        // On misc. error, we rethrow and reset supported features\n        supportedFeatures = null;\n        throw supportResult.error;\n      } else {\n        // Otherwise we assume no features are supported\n        supportedFeatures = NO_SUPPORTED_FEATURES;\n      }\n    }\n    return introspect(supportedFeatures);\n  };\n\n  return {\n    async load(reload?: boolean) {\n      return reload || !result ? (result = await load()) : result;\n    },\n    notifyOnUpdate(onUpdate) {\n      subscriptions.add(onUpdate);\n      return () => {\n        subscriptions.delete(onUpdate);\n        if (!subscriptions.size && timeoutID) {\n          clearTimeout(timeoutID);\n          timeoutID = null;\n        }\n      };\n    },\n    async loadIntrospection() {\n      const result = await this.load();\n      return result && result.introspection;\n    },\n    async loadSchema() {\n      const result = await this.load();\n      return result && result.schema;\n    },\n  };\n}\n","export type * from './types';\n\nimport path from 'node:path';\nimport type { SchemaLoader, SchemaOrigin } from './types';\nimport { loadFromSDL } from './sdl';\nimport { loadFromURL } from './url';\n\nexport { loadFromSDL, loadFromURL };\n\nconst getURLConfig = (origin: SchemaOrigin | null) => {\n  try {\n    return origin\n      ? {\n          url: new URL(typeof origin === 'object' ? origin.url : origin),\n          headers: typeof origin === 'object' ? origin.headers : undefined,\n        }\n      : null;\n  } catch (_error) {\n    return null;\n  }\n};\n\nexport interface LoadConfig {\n  origin: SchemaOrigin;\n  rootPath?: string;\n  fetchInterval?: number;\n  assumeValid?: boolean;\n}\n\nexport function load(config: LoadConfig): SchemaLoader {\n  const urlOrigin = getURLConfig(config.origin);\n  if (urlOrigin) {\n    return loadFromURL({ ...urlOrigin, interval: config.fetchInterval });\n  } else if (typeof config.origin === 'string') {\n    const file = config.rootPath ? path.resolve(config.rootPath, config.origin) : config.origin;\n    const assumeValid = config.assumeValid != null ? config.assumeValid : true;\n    return loadFromSDL({ file, assumeValid });\n  } else {\n    throw new Error(`Configuration contains an invalid \"schema\" option`);\n  }\n}\n","import * as path from 'node:path';\n\nexport const cwd = process.cwd();\n\nexport const maybeRelative = (filePath: string): string => {\n  const relative = path.relative(cwd, filePath);\n  return !relative.startsWith('..') ? relative : filePath;\n};\n","import type { Diagnostic } from 'typescript';\nimport { maybeRelative } from './helpers';\n\nexport class TSError extends Error {\n  readonly name: 'TSError';\n  readonly diagnostic: Diagnostic;\n  constructor(diagnostic: Diagnostic) {\n    let message =\n      typeof diagnostic.messageText !== 'string'\n        ? diagnostic.messageText.messageText\n        : diagnostic.messageText;\n    if (diagnostic.file) message += ` (${maybeRelative(diagnostic.file.fileName)})`;\n    super(message);\n    this.name = 'TSError';\n    this.diagnostic = diagnostic;\n  }\n}\n\nexport class TadaError extends Error {\n  readonly name: 'TadaError';\n  constructor(message: string) {\n    super(message);\n    this.name = 'TadaError';\n  }\n}\n","import { TadaError } from './errors';\nimport type { SchemaOrigin } from './loaders/types';\n\nexport interface GraphQLSPConfig {\n  schema: SchemaOrigin;\n  tadaOutputLocation?: string;\n  tadaTurboLocation?: string;\n  tadaPersistedLocation?: string;\n  template?: string;\n}\n\nexport const parseConfig = (input: Record<string, unknown>) => {\n  if (input.schema && typeof input.schema === 'object') {\n    const { schema } = input;\n    if (!('url' in schema)) {\n      throw new TadaError('Configuration contains a `schema` object, but no `url` property');\n    }\n\n    if ('headers' in schema && schema.headers && typeof schema.headers === 'object') {\n      for (const key in schema.headers) {\n        if (schema.headers[key] && typeof schema.headers[key] !== 'string') {\n          throw new TadaError(\n            'Headers at `schema.headers` contain a non-string value at key: ' + key\n          );\n        }\n      }\n    } else if ('headers' in schema) {\n      throw new TadaError(\n        \"Configuration contains a `schema.headers` property, but it's not an object\"\n      );\n    }\n  } else if (typeof input.schema !== 'string') {\n    throw new TadaError('Configuration is missing a `schema` property');\n  } else if (\n    'tadaOutputLocation' in input &&\n    input.tadaOutputLocation &&\n    typeof input.tadaOutputLocation !== 'string'\n  ) {\n    throw new TadaError(\n      \"Configuration contains a `tadaOutputLocation` property, but it's not a file path\"\n    );\n  } else if (\n    'tadaTurboLocation' in input &&\n    input.tadaTurboLocation &&\n    typeof input.tadaTurboLocation !== 'string'\n  ) {\n    throw new TadaError(\n      \"Configuration contains a `tadaTurboLocation` property, but it's not a file path\"\n    );\n  } else if (\n    'tadaPersistedLocation' in input &&\n    input.tadaPersistedLocation &&\n    typeof input.tadaPersistedLocation !== 'string'\n  ) {\n    throw new TadaError(\n      \"Configuration contains a `tadaPersistedLocation` property, but it's not a file path\"\n    );\n  } else if ('template' in input && input.template && typeof input.template !== 'string') {\n    throw new TadaError(\"Configuration contains a `template` property, but it's not a string\");\n  }\n\n  return input as any as GraphQLSPConfig;\n};\n","import * as path from 'node:path';\nimport * as fs from 'node:fs/promises';\nimport { createRequire } from 'node:module';\nimport type { Stats } from 'node:fs';\n\nimport type { TsConfigJson } from 'type-fest';\nimport { parseConfigFileTextToJson } from 'typescript';\n\nimport { cwd, maybeRelative } from './helpers';\nimport { TSError, TadaError } from './errors';\n\nconst TSCONFIG = 'tsconfig.json';\n\nconst isFile = (stat: Stats): boolean => stat.isFile();\nconst isDir = (stat: Stats): boolean => stat.isDirectory();\nconst stat = (file: string, predicate = isFile): Promise<boolean> =>\n  fs\n    .stat(file)\n    .then(predicate)\n    .catch(() => false);\n\nconst _resolve =\n  typeof require !== 'undefined'\n    ? require.resolve.bind(require)\n    : createRequire(import.meta.url).resolve;\nconst resolveExtend = async (extend: string, from: string) => {\n  try {\n    return toTSConfigPath(_resolve(extend, { paths: [from] }));\n  } catch (_error) {\n    return null;\n  }\n};\n\nconst toTSConfigPath = (tsconfigPath: string): string =>\n  path.extname(tsconfigPath) !== '.json'\n    ? path.resolve(cwd, tsconfigPath, TSCONFIG)\n    : path.resolve(cwd, tsconfigPath);\n\nexport const readTSConfigFile = async (filePath: string): Promise<TsConfigJson> => {\n  const tsconfigPath = toTSConfigPath(filePath);\n  const contents = await fs.readFile(tsconfigPath, 'utf8');\n  const result = parseConfigFileTextToJson(tsconfigPath, contents);\n  if (result.error) throw new TSError(result.error);\n  return result.config || {};\n};\n\nexport const findTSConfigFile = async (targetPath?: string): Promise<string | null> => {\n  let tsconfigPath = toTSConfigPath(targetPath || cwd);\n  const rootPath = toTSConfigPath(path.resolve(tsconfigPath, '/'));\n  while (tsconfigPath !== rootPath) {\n    if (await stat(tsconfigPath)) return tsconfigPath;\n    const gitPath = path.resolve(tsconfigPath, '..', '.git');\n    if (await stat(gitPath, isDir)) return null;\n    const parentPath = toTSConfigPath(path.resolve(tsconfigPath, '..', '..'));\n    if (parentPath === tsconfigPath) break;\n    tsconfigPath = parentPath;\n  }\n  return null;\n};\n\nconst getPluginConfig = (tsconfig: TsConfigJson | null): Record<string, unknown> | null =>\n  (tsconfig &&\n    tsconfig.compilerOptions &&\n    tsconfig.compilerOptions.plugins &&\n    tsconfig.compilerOptions.plugins.find(\n      (x) => x.name === '@0no-co/graphqlsp' || x.name === 'gql.tada/lsp'\n    )) ||\n  null;\n\nexport interface LoadConfigResult {\n  pluginConfig: Record<string, unknown>;\n  configPath: string;\n  rootPath: string;\n}\n\nexport const loadConfig = async (targetPath?: string): Promise<LoadConfigResult> => {\n  const rootTsconfigPath = await findTSConfigFile(targetPath);\n  if (!rootTsconfigPath) {\n    throw new TadaError(\n      targetPath\n        ? `No tsconfig.json found at or above: ${maybeRelative(targetPath)}`\n        : 'No tsconfig.json found at or above current working directory'\n    );\n  }\n  const tsconfig = await readTSConfigFile(rootTsconfigPath);\n  const pluginConfig = getPluginConfig(tsconfig);\n  if (pluginConfig) {\n    return {\n      pluginConfig,\n      configPath: rootTsconfigPath,\n      rootPath: path.dirname(rootTsconfigPath),\n    };\n  }\n\n  if (Array.isArray(tsconfig.extends)) {\n    for (let extend of tsconfig.extends) {\n      if (path.extname(extend) !== '.json') extend += '.json';\n      try {\n        const tsconfigPath = await resolveExtend(extend, path.dirname(rootTsconfigPath));\n        if (tsconfigPath) {\n          const config = loadConfig(targetPath);\n          return {\n            ...config,\n            rootPath: path.dirname(rootTsconfigPath),\n          };\n        }\n      } catch (_error) {}\n    }\n  } else if (tsconfig.extends) {\n    try {\n      const tsconfigPath = await resolveExtend(tsconfig.extends, path.dirname(rootTsconfigPath));\n      if (tsconfigPath) {\n        const config = loadConfig(targetPath);\n        return {\n          ...config,\n          rootPath: path.dirname(rootTsconfigPath),\n        };\n      }\n    } catch (_error) {}\n  }\n\n  throw new TadaError(\n    `Could not find a valid GraphQLSP plugin entry in: ${maybeRelative(rootTsconfigPath)}`\n  );\n};\n\n/** @deprecated Use {@link loadConfig} instead */\nexport const resolveTypeScriptRootDir = async (\n  tsconfigPath: string\n): Promise<string | undefined> => {\n  try {\n    const result = await loadConfig(tsconfigPath);\n    return path.dirname(result.configPath);\n  } catch (_error) {\n    return undefined;\n  }\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionNamedTypeRef,\n  IntrospectionOutputTypeRef,\n  IntrospectionInputTypeRef,\n  IntrospectionInputValue,\n  IntrospectionEnumValue,\n  IntrospectionField,\n} from 'graphql';\n\nfunction nameCompare(objA: { name: string }, objB: { name: string }) {\n  return objA.name < objB.name ? -1 : objA.name > objB.name ? 1 : 0;\n}\n\nfunction mapTypeRef<const T extends IntrospectionTypeRef>(fromType: T): T;\nfunction mapTypeRef(fromType: IntrospectionTypeRef): IntrospectionTypeRef;\nfunction mapTypeRef(fromType: IntrospectionOutputTypeRef): IntrospectionOutputTypeRef;\nfunction mapTypeRef(fromType: IntrospectionInputTypeRef): IntrospectionInputTypeRef;\n\nfunction mapTypeRef(fromType: IntrospectionTypeRef): IntrospectionTypeRef {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n      return {\n        kind: fromType.kind,\n        ofType: mapTypeRef(fromType.ofType),\n      };\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapTypeRef(fromType.ofType),\n      };\n    case 'ENUM':\n    case 'INPUT_OBJECT':\n    case 'SCALAR':\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return {\n        kind: fromType.kind,\n        name: fromType.name,\n      };\n  }\n}\n\nfunction mapEnumValue(value: IntrospectionEnumValue): IntrospectionEnumValue {\n  return {\n    name: value.name,\n    isDeprecated: !!value.isDeprecated,\n    deprecationReason: undefined,\n  };\n}\n\nfunction mapInputField(value: IntrospectionInputValue): IntrospectionInputValue {\n  return {\n    name: value.name,\n    type: mapTypeRef(value.type),\n    defaultValue: value.defaultValue || undefined,\n  };\n}\n\nfunction mapField(field: IntrospectionField): IntrospectionField {\n  return {\n    name: field.name,\n    type: mapTypeRef(field.type),\n    args: field.args ? field.args.map(mapInputField).sort(nameCompare) : [],\n    isDeprecated: !!field.isDeprecated,\n    deprecationReason: undefined,\n  };\n}\n\nfunction mapPossibleType<T extends IntrospectionNamedTypeRef>(ref: T): T {\n  return {\n    kind: ref.kind,\n    name: ref.name,\n  } as T;\n}\n\nfunction minifyIntrospectionType(type: IntrospectionType): IntrospectionType {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(mapEnumValue),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(mapInputField),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields ? type.fields.map(mapField).sort(nameCompare) : [],\n        interfaces: type.interfaces ? type.interfaces.map(mapPossibleType).sort(nameCompare) : [],\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields ? type.fields.map(mapField).sort(nameCompare) : [],\n        interfaces: type.interfaces ? type.interfaces.map(mapPossibleType).sort(nameCompare) : [],\n        possibleTypes: type.possibleTypes\n          ? type.possibleTypes.map(mapPossibleType).sort(nameCompare)\n          : [],\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes\n          ? type.possibleTypes.map(mapPossibleType).sort(nameCompare)\n          : [],\n      };\n  }\n}\n\n/** Minifies an {@link IntrospectionQuery} for use with Graphcache or the `populateExchange`.\n *\n * @param schema - An {@link IntrospectionQuery} object to be minified.\n * @param opts - An optional {@link MinifySchemaOptions} configuration object.\n * @returns the minified {@link IntrospectionQuery} object.\n *\n * @remarks\n * `minifyIntrospectionQuery` reduces the size of an {@link IntrospectionQuery} by\n * removing data and information that a client-side consumer, like Graphcache or the\n * `populateExchange`, may not require.\n *\n * At the very least, it will remove system types, descriptions, depreactions,\n * and source locations. Unless disabled via the options passed, it will also\n * by default remove all scalars, enums, inputs, and directives.\n *\n * @throws\n * If `schema` receives an object that isn’t an {@link IntrospectionQuery}, a\n * {@link TypeError} will be thrown.\n */\nexport const minifyIntrospectionQuery = (schema: IntrospectionQuery): IntrospectionQuery => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter((type) => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            type.kind === 'SCALAR' ||\n            type.kind === 'ENUM' ||\n            type.kind === 'INPUT_OBJECT' ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType)\n    .sort(nameCompare);\n\n  return {\n    __schema: {\n      queryType: {\n        kind: queryType.kind,\n        name: queryType.name,\n      },\n      mutationType: mutationType\n        ? {\n            kind: mutationType.kind,\n            name: mutationType.name,\n          }\n        : null,\n      subscriptionType: subscriptionType\n        ? {\n            kind: subscriptionType.kind,\n            name: subscriptionType.name,\n          }\n        : null,\n      types: minifiedTypes,\n      directives: [],\n    },\n  };\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionEnumValue,\n  IntrospectionInputValue,\n  IntrospectionTypeRef,\n  IntrospectionNamedTypeRef,\n  IntrospectionField,\n} from 'graphql';\n\nconst printName = (input: string | undefined | null): string => (input ? `'${input}'` : 'never');\n\nconst printTypeRef = (typeRef: IntrospectionTypeRef) => {\n  if (typeRef.kind === 'NON_NULL') {\n    return `{ kind: 'NON_NULL'; name: never; ofType: ${printTypeRef(typeRef.ofType)}; }`;\n  } else if (typeRef.kind === 'LIST') {\n    return `{ kind: 'LIST'; name: never; ofType: ${printTypeRef(typeRef.ofType)}; }`;\n  } else {\n    return `{ kind: ${printName(typeRef.kind)}; name: ${printName(typeRef.name)}; ofType: null; }`;\n  }\n};\n\nconst printInputFields = (inputFields: readonly IntrospectionInputValue[]) => {\n  let output = '';\n  for (const inputField of inputFields) {\n    if (output) output += ', ';\n    const name = printName(inputField.name);\n    const type = printTypeRef(inputField.type);\n    const defaultValue = inputField.defaultValue ? JSON.stringify(inputField.defaultValue) : 'null';\n    output += `{ name: ${name}; type: ${type}; defaultValue: ${defaultValue} }`;\n  }\n  return `[${output}]`;\n};\n\nconst printNamedTypes = (\n  values: readonly (IntrospectionEnumValue | IntrospectionNamedTypeRef)[]\n) => {\n  if (!values.length) return 'never';\n  let output = '';\n  for (const value of values) {\n    if (output) output += ' | ';\n    output += printName(value.name);\n  }\n  return output;\n};\n\nconst printFields = (fields: readonly IntrospectionField[]) => {\n  let output = '';\n  for (const field of fields) {\n    const name = printName(field.name);\n    const type = printTypeRef(field.type);\n    output += `${printName(field.name)}: { name: ${name}; type: ${type} }; `;\n  }\n  return `{ ${output}}`;\n};\n\nexport const printIntrospectionType = (type: IntrospectionType) => {\n  if (type.kind === 'ENUM') {\n    const values = printNamedTypes(type.enumValues);\n    return `{ name: ${printName(type.name)}; enumValues: ${values}; }`;\n  } else if (type.kind === 'INPUT_OBJECT') {\n    const fields = printInputFields(type.inputFields);\n    return `{ kind: 'INPUT_OBJECT'; name: ${printName(type.name)}; inputFields: ${fields}; }`;\n  } else if (type.kind === 'OBJECT') {\n    const fields = printFields(type.fields);\n    return `{ kind: 'OBJECT'; name: ${printName(type.name)}; fields: ${fields}; }`;\n  } else if (type.kind === 'INTERFACE') {\n    const name = printName(type.name);\n    const fields = printFields(type.fields);\n    const possibleTypes = printNamedTypes(type.possibleTypes);\n    return `{ kind: 'INTERFACE'; name: ${name}; fields: ${fields}; possibleTypes: ${possibleTypes}; }`;\n  } else if (type.kind === 'UNION') {\n    const name = printName(type.name);\n    const possibleTypes = printNamedTypes(type.possibleTypes);\n    return `{ kind: 'UNION'; name: ${name}; fields: {}; possibleTypes: ${possibleTypes}; }`;\n  } else {\n    return 'unknown';\n  }\n};\n\nexport function preprocessIntrospection({ __schema: schema }: IntrospectionQuery): string {\n  const queryName = printName(schema.queryType.name);\n  const mutationName = printName(schema.mutationType && schema.mutationType.name);\n  const subscriptionName = printName(schema.subscriptionType && schema.subscriptionType.name);\n\n  let evaluatedTypes = '';\n  for (const type of schema.types) {\n    const typeStr = printIntrospectionType(type);\n    if (evaluatedTypes) evaluatedTypes += '\\n';\n    evaluatedTypes += `    ${printName(type.name)}: ${typeStr};`;\n  }\n\n  return (\n    '{\\n' +\n    `  query: ${queryName};\\n` +\n    `  mutation: ${mutationName};\\n` +\n    `  subscription: ${subscriptionName};\\n` +\n    `  types: {\\n${evaluatedTypes}\\n  };\\n}`\n  );\n}\n","const PREAMBLE_IGNORE = ['/* eslint-disable */', '/* prettier-ignore */'].join('\\n') + '\\n';\n\nconst ANNOTATION_DTS = [\n  '/** An IntrospectionQuery representation of your schema.',\n  ' *',\n  ' * @remarks',\n  ' * This is an introspection of your schema saved as a file by GraphQLSP.',\n  ' * It will automatically be used by `gql.tada` to infer the types of your GraphQL documents.',\n  ' * If you need to reuse this data or update your `scalars`, update `tadaOutputLocation` to',\n  ' * instead save to a .ts instead of a .d.ts file.',\n  ' */',\n].join('\\n');\n\nconst ANNOTATION_TS = [\n  '/** An IntrospectionQuery representation of your schema.',\n  ' *',\n  ' * @remarks',\n  ' * This is an introspection of your schema saved as a file by GraphQLSP.',\n  ' * You may import it to create a `graphql()` tag function with `gql.tada`',\n  ' * by importing it and passing it to `initGraphQLTada<>()`.',\n  ' *',\n  ' * @example',\n  ' * ```',\n  \" * import { initGraphQLTada } from 'gql.tada';\",\n  \" * import type { introspection } from './introspection';\",\n  ' *',\n  ' * export const graphql = initGraphQLTada<{',\n  ' *   introspection: typeof introspection;',\n  ' *   scalars: {',\n  ' *     DateTime: string;',\n  ' *     Json: any;',\n  ' *   };',\n  ' * }>();',\n  ' * ```',\n  ' */',\n].join('\\n');\n\nexport { PREAMBLE_IGNORE, ANNOTATION_DTS, ANNOTATION_TS };\n","import type { IntrospectionQuery } from 'graphql';\n\nimport { TadaError } from '../errors';\nimport { PREAMBLE_IGNORE, ANNOTATION_DTS, ANNOTATION_TS } from './constants';\nimport { preprocessIntrospection } from './preprocess';\n\nconst stringifyJson = (input: unknown | string): string =>\n  typeof input === 'string' ? input : JSON.stringify(input, null, 2);\n\ninterface OutputIntrospectionFileOptions {\n  fileType: '.ts' | '.d.ts' | string;\n  shouldPreprocess?: boolean;\n}\n\nexport function outputIntrospectionFile(\n  introspection: IntrospectionQuery | string,\n  opts: OutputIntrospectionFileOptions\n): string {\n  if (/\\.d\\.ts$/.test(opts.fileType)) {\n    const json =\n      typeof introspection !== 'string' && opts.shouldPreprocess\n        ? preprocessIntrospection(introspection)\n        : stringifyJson(introspection);\n    return [\n      PREAMBLE_IGNORE,\n      ANNOTATION_DTS,\n      `export type introspection = ${json};\\n`,\n      \"import * as gqlTada from 'gql.tada';\\n\",\n      \"declare module 'gql.tada' {\",\n      '  interface setupSchema {',\n      '    introspection: introspection',\n      '  }',\n      '}',\n    ].join('\\n');\n  } else if (/\\.ts$/.test(opts.fileType)) {\n    const json = stringifyJson(introspection);\n    return [\n      PREAMBLE_IGNORE,\n      ANNOTATION_TS,\n      `const introspection = ${json} as const;\\n`,\n      'export { introspection };',\n    ].join('\\n');\n  }\n\n  throw new TadaError(\n    `No available introspection format for \"${opts.fileType}\" (expected \".ts\" or \".d.ts\")`\n  );\n}\n"],"names":["compilerOptions","rootDir","moduleResolution","ModuleResolutionKind","Bundler","skipLibCheck","skipDefaultLibCheck","allowImportingTsExtensions","allowSyntheticDefaultImports","resolvePackageJsonExports","resolvePackageJsonImports","resolveJsonModule","esModuleInterop","jsx","JsxEmit","Preserve","target","ScriptTarget","Latest","checkJs","allowJs","strict","noEmit","noLib","disableReferencedProjectLoad","disableSourceOfProjectReferenceRedirect","disableSizeLimit","disableSolutionSearching","File$1","File","constructor","name","data","this","cache","createTargetCache","ES3","ES5","ES2015","ES2016","ES2017","ES2018","ES2019","ES2020","ES2021","ES2022","JSON","normalize","text","toSourceFile","opts","languageVersion","getTargetCache","key","setTargetCache","value","createSourceFile","toString","toBuffer","TextEncoder","encode","TextDecoder","decode","Directory","children","Object","create","files","getOrCreateDirectory","filename","path","startsWith","sep","split","slice","requireResolve","require","resolve","createRequire","url","async","importModule","host","id","request","module","paths","Error","fromBasePath","dirname","toBasePath","walk","directory","entry","fs","readdir","fromFilePath","join","stat","isDirectory","toFilePath","relative","readFile","encoding","writeFile","importLib","LIB_PATH","contents","Promise","all","map","libFile","getDefaultLibFileName","resolveModuleFile","from","slashIndex","indexOf","subpath","ROOT_LIB_DTS_PATH","createProgram","rootNames","tsCreateProgram","createVirtualHost","createModuleResolutionCache","root","getCanonicalFileName","getCurrentDirectory","getNewLine","getModuleResolutionCache","useCaseSensitiveFileNames","fileExists","parts","i","length","directoryExists","directoryName","content","getDirectories","keys","file","getSourceFile","languageVersionOrOptions","resolveModuleNames","moduleNames","containingFile","resolvedModules","moduleName","result","resolveModuleName","push","resolvedModule","rehydrateGraphQlError","r","message","extensions","e","nodes","source","positions","CombinedError","graphQLErrors","t","a","networkError","super","response","_hasField","fieldName","fields","some","field","_supportsDeprecatedArgumentsArg","argsField","find","args","arg","toSupportedFeatures","directiveIsRepeatable","directive","specifiedByURL","type","inputValueDeprecation","inputValue","directiveArgumentsIsDeprecated","fieldArgumentsIsDeprecated","_introspectionQuery","_previousSupport","makeIntrospectionQuery","support","_makeIntrospectionQuery","kind","Kind","DOCUMENT","definitions","OPERATION_DEFINITION","NAME","operation","OperationTypeNode","QUERY","selectionSet","SELECTION_SET","selections","FIELD","_makeSchemaSelection","_makeSchemaFullTypeFragment","_makeSchemaInputValueFragment","_makeTypeRefFragment","makeIntrospectSupportQuery","alias","arguments","ARGUMENT","STRING","_makeFieldNamesSelection","includeArgs","options","FRAGMENT_SPREAD","_makeSchemaArgsField","FRAGMENT_DEFINITION","typeCondition","NAMED_TYPE","BOOLEAN","supportsValueDeprecation","_makeTypeRefSelection","depth","ALL_SUPPORTED_FEATURES","loadFromSDL","config","subscriptions","Set","controller","load","ext","extname","introspection","parse","__schema","schema","buildClientSchema","assumeValid","buildSchema","assumeValidSDL","query","queryResult","executeSync","document","errors","reload","notifyOnUpdate","onUpdate","size","AbortController","watcher","watch","signal","persistent","_event","subscriber","error","add","delete","abort","loadIntrospection","loadSchema","retryExchange","y","retryIf","d","retryWith","s","l","initialDelayMs","p","maxDelayMs","m","maxNumberAttempts","c","randomDelay","forward","dispatchDebug","v","f","h","next","x","E","context","retry","count","delay","Math","random","min","process","env","NODE_ENV","retryCount","delayAmount","o","n","u","NO_SUPPORTED_FEATURES","loadFromURL","interval","timeoutID","supportedFeatures","client","Client","fetchOptions","headers","exchanges","NODE_TLS_REJECT_UNAUTHORIZED","fetchExchange","introspect","introspectionResult","scheduleUpdate","setTimeout","_error","supportResult","_result","clearTimeout","urlOrigin","origin","URL","undefined","getURLConfig","fetchInterval","rootPath","cwd","maybeRelative","filePath","TSError","diagnostic","messageText","fileName","TadaError","parseConfig","input","tadaOutputLocation","tadaTurboLocation","tadaPersistedLocation","template","isFile","isDir","predicate","then","catch","_resolve","bind","resolveExtend","extend","toTSConfigPath","tsconfigPath","readTSConfigFile","parseConfigFileTextToJson","findTSConfigFile","targetPath","gitPath","parentPath","loadConfig","rootTsconfigPath","tsconfig","pluginConfig","plugins","getPluginConfig","configPath","Array","isArray","extends","resolveTypeScriptRootDir","nameCompare","objA","objB","mapTypeRef","fromType","ofType","mapEnumValue","isDeprecated","deprecationReason","mapInputField","defaultValue","mapField","sort","mapPossibleType","ref","minifyIntrospectionType","enumValues","inputFields","interfaces","possibleTypes","minifyIntrospectionQuery","TypeError","queryType","mutationType","subscriptionType","types","minifiedTypes","filter","directives","printName","printTypeRef","typeRef","printNamedTypes","values","output","printFields","printIntrospectionType","inputField","stringify","printInputFields","preprocessIntrospection","queryName","mutationName","subscriptionName","evaluatedTypes","typeStr","PREAMBLE_IGNORE","ANNOTATION_DTS","ANNOTATION_TS","stringifyJson","outputIntrospectionFile","test","fileType","json","shouldPreprocess"],"mappings":"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","x_google_ignoreList":[5,8]}