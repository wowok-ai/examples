{"version":3,"file":"gql-tada-internal.mjs","sources":["../../../node_modules/.pnpm/@urql+core@5.0.2_graphql@16.8.1/node_modules/@urql/core/dist/urql-core-chunk.mjs","../src/loaders/query.ts","../src/loaders/sdl.ts","../../../node_modules/.pnpm/@urql+exchange-retry@1.2.1_graphql@16.8.1/node_modules/@urql/exchange-retry/dist/urql-exchange-retry.mjs","../src/loaders/url.ts","../src/loaders/index.ts","../src/helpers.ts","../src/errors.ts","../src/config.ts","../src/resolve.ts","../src/introspection/minify.ts","../src/introspection/preprocess.ts","../src/introspection/constants.ts","../src/introspection/output.ts"],"sourcesContent":["import { GraphQLError as e, print as r, parse as t, Kind as a } from \"@0no-co/graphql.web\";\n\nimport { onEnd as o, filter as n, fromAsyncIterable as s } from \"wonka\";\n\nvar rehydrateGraphQlError = r => {\n  if (r && r.message && (r.extensions || \"GraphQLError\" === r.name)) {\n    return r;\n  } else if (\"object\" == typeof r && r.message) {\n    return new e(r.message, r.nodes, r.source, r.positions, r.path, r, r.extensions || {});\n  } else {\n    return new e(r);\n  }\n};\n\nclass CombinedError extends Error {\n  constructor(e) {\n    var r = (e.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((e, r) => {\n      var t = \"\";\n      if (e) {\n        return `[Network] ${e.message}`;\n      }\n      if (r) {\n        for (var a of r) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(e.networkError, r);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = r;\n    this.networkError = e.networkError;\n    this.response = e.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\nvar phash = (e, r) => {\n  var t = 0 | (r || 5381);\n  for (var a = 0, o = 0 | e.length; a < o; a++) {\n    t = (t << 5) + t + e.charCodeAt(a);\n  }\n  return t;\n};\n\nvar i = new Set;\n\nvar f = new WeakMap;\n\nvar stringify = e => {\n  if (null === e || i.has(e)) {\n    return \"null\";\n  } else if (\"object\" != typeof e) {\n    return JSON.stringify(e) || \"\";\n  } else if (e.toJSON) {\n    return stringify(e.toJSON());\n  } else if (Array.isArray(e)) {\n    var r = \"[\";\n    for (var t of e) {\n      if (r.length > 1) {\n        r += \",\";\n      }\n      r += stringify(t) || \"null\";\n    }\n    return r += \"]\";\n  } else if (l !== NoopConstructor && e instanceof l || c !== NoopConstructor && e instanceof c) {\n    return \"null\";\n  }\n  var a = Object.keys(e).sort();\n  if (!a.length && e.constructor && Object.getPrototypeOf(e).constructor !== Object.prototype.constructor) {\n    var o = f.get(e) || Math.random().toString(36).slice(2);\n    f.set(e, o);\n    return stringify({\n      __key: o\n    });\n  }\n  i.add(e);\n  var n = \"{\";\n  for (var s of a) {\n    var d = stringify(e[s]);\n    if (d) {\n      if (n.length > 1) {\n        n += \",\";\n      }\n      n += stringify(s) + \":\" + d;\n    }\n  }\n  i.delete(e);\n  return n += \"}\";\n};\n\nvar extract = (e, r, t) => {\n  if (null == t || \"object\" != typeof t || t.toJSON || i.has(t)) {} else if (Array.isArray(t)) {\n    for (var a = 0, o = t.length; a < o; a++) {\n      extract(e, `${r}.${a}`, t[a]);\n    }\n  } else if (t instanceof l || t instanceof c) {\n    e.set(r, t);\n  } else {\n    i.add(t);\n    for (var n of Object.keys(t)) {\n      extract(e, `${r}.${n}`, t[n]);\n    }\n  }\n};\n\nvar stringifyVariables = e => {\n  i.clear();\n  return stringify(e);\n};\n\nclass NoopConstructor {}\n\nvar l = \"undefined\" != typeof File ? File : NoopConstructor;\n\nvar c = \"undefined\" != typeof Blob ? Blob : NoopConstructor;\n\nvar d = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\n\nvar v = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\n\nvar replaceOutsideStrings = (e, r) => r % 2 == 0 ? e.replace(v, \"\\n\") : e;\n\nvar sanitizeDocument = e => e.split(d).map(replaceOutsideStrings).join(\"\").trim();\n\nvar p = new Map;\n\nvar u = new Map;\n\nvar stringifyDocument = e => {\n  var t;\n  if (\"string\" == typeof e) {\n    t = sanitizeDocument(e);\n  } else if (e.loc && u.get(e.__key) === e) {\n    t = e.loc.source.body;\n  } else {\n    t = p.get(e) || sanitizeDocument(r(e));\n    p.set(e, t);\n  }\n  if (\"string\" != typeof e && !e.loc) {\n    e.loc = {\n      start: 0,\n      end: t.length,\n      source: {\n        body: t,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return t;\n};\n\nvar hashDocument = e => {\n  var r = phash(stringifyDocument(e));\n  if (e.definitions) {\n    var t = getOperationName(e);\n    if (t) {\n      r = phash(`\\n# ${t}`, r);\n    }\n  }\n  return r;\n};\n\nvar keyDocument = e => {\n  var r;\n  var a;\n  if (\"string\" == typeof e) {\n    r = hashDocument(e);\n    a = u.get(r) || t(e, {\n      noLocation: !0\n    });\n  } else {\n    r = e.__key || hashDocument(e);\n    a = u.get(r) || e;\n  }\n  if (!a.loc) {\n    stringifyDocument(a);\n  }\n  a.__key = r;\n  u.set(r, a);\n  return a;\n};\n\nvar createRequest = (e, r, t) => {\n  var a = r || {};\n  var o = keyDocument(e);\n  var n = stringifyVariables(a);\n  var s = o.__key;\n  if (\"{}\" !== n) {\n    s = phash(n, s);\n  }\n  return {\n    key: s,\n    query: o,\n    variables: a,\n    extensions: t\n  };\n};\n\nvar getOperationName = e => {\n  for (var r of e.definitions) {\n    if (r.kind === a.OPERATION_DEFINITION) {\n      return r.name ? r.name.value : void 0;\n    }\n  }\n};\n\nvar getOperationType = e => {\n  for (var r of e.definitions) {\n    if (r.kind === a.OPERATION_DEFINITION) {\n      return r.operation;\n    }\n  }\n};\n\nvar makeResult = (e, r, t) => {\n  if (!(\"data\" in r || \"errors\" in r && Array.isArray(r.errors))) {\n    throw new Error(\"No Content\");\n  }\n  var a = \"subscription\" === e.kind;\n  return {\n    operation: e,\n    data: r.data,\n    error: Array.isArray(r.errors) ? new CombinedError({\n      graphQLErrors: r.errors,\n      response: t\n    }) : void 0,\n    extensions: r.extensions ? {\n      ...r.extensions\n    } : void 0,\n    hasNext: null == r.hasNext ? a : r.hasNext,\n    stale: !1\n  };\n};\n\nvar deepMerge = (e, r) => {\n  if (\"object\" == typeof e && null != e) {\n    if (!e.constructor || e.constructor === Object || Array.isArray(e)) {\n      e = Array.isArray(e) ? [ ...e ] : {\n        ...e\n      };\n      for (var t of Object.keys(r)) {\n        e[t] = deepMerge(e[t], r[t]);\n      }\n      return e;\n    }\n  }\n  return r;\n};\n\nvar mergeResultPatch = (e, r, t, a) => {\n  var o = e.error ? e.error.graphQLErrors : [];\n  var n = !!e.extensions || !!(r.payload || r).extensions;\n  var s = {\n    ...e.extensions,\n    ...(r.payload || r).extensions\n  };\n  var i = r.incremental;\n  if (\"path\" in r) {\n    i = [ r ];\n  }\n  var f = {\n    data: e.data\n  };\n  if (i) {\n    var _loop = function(e) {\n      if (Array.isArray(e.errors)) {\n        o.push(...e.errors);\n      }\n      if (e.extensions) {\n        Object.assign(s, e.extensions);\n        n = !0;\n      }\n      var r = \"data\";\n      var t = f;\n      var i = [];\n      if (e.path) {\n        i = e.path;\n      } else if (a) {\n        var l = a.find((r => r.id === e.id));\n        if (e.subPath) {\n          i = [ ...l.path, ...e.subPath ];\n        } else {\n          i = l.path;\n        }\n      }\n      for (var c = 0, d = i.length; c < d; r = i[c++]) {\n        t = t[r] = Array.isArray(t[r]) ? [ ...t[r] ] : {\n          ...t[r]\n        };\n      }\n      if (e.items) {\n        var v = +r >= 0 ? r : 0;\n        for (var p = 0, u = e.items.length; p < u; p++) {\n          t[v + p] = deepMerge(t[v + p], e.items[p]);\n        }\n      } else if (void 0 !== e.data) {\n        t[r] = deepMerge(t[r], e.data);\n      }\n    };\n    for (var l of i) {\n      _loop(l);\n    }\n  } else {\n    f.data = (r.payload || r).data || e.data;\n    o = r.errors || r.payload && r.payload.errors || o;\n  }\n  return {\n    operation: e.operation,\n    data: f.data,\n    error: o.length ? new CombinedError({\n      graphQLErrors: o,\n      response: t\n    }) : void 0,\n    extensions: n ? s : void 0,\n    hasNext: null != r.hasNext ? r.hasNext : e.hasNext,\n    stale: !1\n  };\n};\n\nvar makeErrorResult = (e, r, t) => ({\n  operation: e,\n  data: void 0,\n  error: new CombinedError({\n    networkError: r,\n    response: t\n  }),\n  extensions: void 0,\n  hasNext: !1,\n  stale: !1\n});\n\nfunction makeFetchBody(e) {\n  var r = {\n    query: void 0,\n    documentId: void 0,\n    operationName: getOperationName(e.query),\n    variables: e.variables || void 0,\n    extensions: e.extensions\n  };\n  if (\"documentId\" in e.query && e.query.documentId && (!e.query.definitions || !e.query.definitions.length)) {\n    r.documentId = e.query.documentId;\n  } else if (!e.extensions || !e.extensions.persistedQuery || e.extensions.persistedQuery.miss) {\n    r.query = stringifyDocument(e.query);\n  }\n  return r;\n}\n\nvar makeFetchURL = (e, r) => {\n  var t = \"query\" === e.kind && e.context.preferGetMethod;\n  if (!t || !r) {\n    return e.context.url;\n  }\n  var a = splitOutSearchParams(e.context.url);\n  for (var o in r) {\n    var n = r[o];\n    if (n) {\n      a[1].set(o, \"object\" == typeof n ? stringifyVariables(n) : n);\n    }\n  }\n  var s = a.join(\"?\");\n  if (s.length > 2047 && \"force\" !== t) {\n    e.context.preferGetMethod = !1;\n    return e.context.url;\n  }\n  return s;\n};\n\nvar splitOutSearchParams = e => {\n  var r = e.indexOf(\"?\");\n  return r > -1 ? [ e.slice(0, r), new URLSearchParams(e.slice(r + 1)) ] : [ e, new URLSearchParams ];\n};\n\nvar serializeBody = (e, r) => {\n  if (r && !(\"query\" === e.kind && !!e.context.preferGetMethod)) {\n    var t = stringifyVariables(r);\n    var a = (e => {\n      var r = new Map;\n      if (l !== NoopConstructor || c !== NoopConstructor) {\n        i.clear();\n        extract(r, \"variables\", e);\n      }\n      return r;\n    })(r.variables);\n    if (a.size) {\n      var o = new FormData;\n      o.append(\"operations\", t);\n      o.append(\"map\", stringifyVariables({\n        ...[ ...a.keys() ].map((e => [ e ]))\n      }));\n      var n = 0;\n      for (var s of a.values()) {\n        o.append(\"\" + n++, s);\n      }\n      return o;\n    }\n    return t;\n  }\n};\n\nvar makeFetchOptions = (e, r) => {\n  var t = {\n    accept: \"subscription\" === e.kind ? \"text/event-stream, multipart/mixed\" : \"application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed\"\n  };\n  var a = (\"function\" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions) || {};\n  if (a.headers) {\n    if ((e => \"has\" in e && !Object.keys(e).length)(a.headers)) {\n      a.headers.forEach(((e, r) => {\n        t[r] = e;\n      }));\n    } else if (Array.isArray(a.headers)) {\n      a.headers.forEach(((e, r) => {\n        if (Array.isArray(e)) {\n          if (t[e[0]]) {\n            t[e[0]] = `${t[e[0]]},${e[1]}`;\n          } else {\n            t[e[0]] = e[1];\n          }\n        } else {\n          t[r] = e;\n        }\n      }));\n    } else {\n      for (var o in a.headers) {\n        t[o.toLowerCase()] = a.headers[o];\n      }\n    }\n  }\n  var n = serializeBody(e, r);\n  if (\"string\" == typeof n && !t[\"content-type\"]) {\n    t[\"content-type\"] = \"application/json\";\n  }\n  return {\n    ...a,\n    method: n ? \"POST\" : \"GET\",\n    body: n,\n    headers: t\n  };\n};\n\nvar y = \"undefined\" != typeof TextDecoder ? new TextDecoder : null;\n\nvar h = /boundary=\"?([^=\";]+)\"?/i;\n\nvar m = /data: ?([^\\n]+)/;\n\nvar toString = e => \"Buffer\" === e.constructor.name ? e.toString() : y.decode(e);\n\nasync function* streamBody(e) {\n  if (e.body[Symbol.asyncIterator]) {\n    for await (var r of e.body) {\n      yield toString(r);\n    }\n  } else {\n    var t = e.body.getReader();\n    var a;\n    try {\n      while (!(a = await t.read()).done) {\n        yield toString(a.value);\n      }\n    } finally {\n      t.cancel();\n    }\n  }\n}\n\nasync function* split(e, r) {\n  var t = \"\";\n  var a;\n  for await (var o of e) {\n    t += o;\n    while ((a = t.indexOf(r)) > -1) {\n      yield t.slice(0, a);\n      t = t.slice(a + r.length);\n    }\n  }\n}\n\nasync function* fetchOperation(e, r, t) {\n  var a = !0;\n  var o = null;\n  var n;\n  try {\n    yield await Promise.resolve();\n    var s = (n = await (e.context.fetch || fetch)(r, t)).headers.get(\"Content-Type\") || \"\";\n    var i;\n    if (/multipart\\/mixed/i.test(s)) {\n      i = async function* parseMultipartMixed(e, r) {\n        var t = e.match(h);\n        var a = \"--\" + (t ? t[1] : \"-\");\n        var o = !0;\n        var n;\n        for await (var s of split(streamBody(r), \"\\r\\n\" + a)) {\n          if (o) {\n            o = !1;\n            var i = s.indexOf(a);\n            if (i > -1) {\n              s = s.slice(i + a.length);\n            } else {\n              continue;\n            }\n          }\n          try {\n            yield n = JSON.parse(s.slice(s.indexOf(\"\\r\\n\\r\\n\") + 4));\n          } catch (e) {\n            if (!n) {\n              throw e;\n            }\n          }\n          if (n && !1 === n.hasNext) {\n            break;\n          }\n        }\n        if (n && !1 !== n.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(s, n);\n    } else if (/text\\/event-stream/i.test(s)) {\n      i = async function* parseEventStream(e) {\n        var r;\n        for await (var t of split(streamBody(e), \"\\n\\n\")) {\n          var a = t.match(m);\n          if (a) {\n            var o = a[1];\n            try {\n              yield r = JSON.parse(o);\n            } catch (e) {\n              if (!r) {\n                throw e;\n              }\n            }\n            if (r && !1 === r.hasNext) {\n              break;\n            }\n          }\n        }\n        if (r && !1 !== r.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(n);\n    } else if (!/text\\//i.test(s)) {\n      i = async function* parseJSON(e) {\n        yield JSON.parse(await e.text());\n      }(n);\n    } else {\n      i = async function* parseMaybeJSON(e) {\n        var r = await e.text();\n        try {\n          var t = JSON.parse(r);\n          if (\"production\" !== process.env.NODE_ENV) {\n            console.warn('Found response with content-type \"text/plain\" but it had a valid \"application/json\" response.');\n          }\n          yield t;\n        } catch (e) {\n          throw new Error(r);\n        }\n      }(n);\n    }\n    var f;\n    for await (var l of i) {\n      if (l.pending && !o) {\n        f = l.pending;\n      } else if (l.pending) {\n        f = [ ...f, ...l.pending ];\n      }\n      o = o ? mergeResultPatch(o, l, n, f) : makeResult(e, l, n);\n      a = !1;\n      yield o;\n      a = !0;\n    }\n    if (!o) {\n      yield o = makeResult(e, {}, n);\n    }\n  } catch (r) {\n    if (!a) {\n      throw r;\n    }\n    yield makeErrorResult(e, n && (n.status < 200 || n.status >= 300) && n.statusText ? new Error(n.statusText) : r, n);\n  }\n}\n\nfunction makeFetchSource(e, r, t) {\n  var a;\n  if (\"undefined\" != typeof AbortController) {\n    t.signal = (a = new AbortController).signal;\n  }\n  return o((() => {\n    if (a) {\n      a.abort();\n    }\n  }))(n((e => !!e))(s(fetchOperation(e, r, t))));\n}\n\nexport { CombinedError as C, makeFetchBody as a, makeErrorResult as b, mergeResultPatch as c, makeFetchURL as d, makeFetchOptions as e, makeFetchSource as f, getOperationType as g, createRequest as h, stringifyVariables as i, keyDocument as k, makeResult as m, stringifyDocument as s };\n//# sourceMappingURL=urql-core-chunk.mjs.map\n","import { Kind, OperationTypeNode } from '@0no-co/graphql.web';\n\nimport type {\n  SelectionSetNode,\n  FragmentDefinitionNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DocumentNode,\n} from '@0no-co/graphql.web';\n\n/** Support matrix to be used in the {@link makeIntrospectionQuery} builder */\nexport interface SupportedFeatures {\n  directiveIsRepeatable: boolean;\n  specifiedByURL: boolean;\n  inputValueDeprecation: boolean;\n  directiveArgumentsIsDeprecated: boolean;\n  fieldArgumentsIsDeprecated: boolean;\n}\n\n/** Data from a {@link makeIntrospectSupportQuery} result */\nexport interface IntrospectSupportQueryData {\n  directive: { fields: { name: string; args: { name: string }[] | null }[] | null } | null;\n  type: { fields: { name: string }[] | null } | null;\n  field: { fields: { name: string; args: { name: string }[] | null }[] | null } | null;\n  inputValue: { fields: { name: string }[] | null } | null;\n}\n\nconst _hasField = (\n  data: IntrospectSupportQueryData[keyof IntrospectSupportQueryData],\n  fieldName: string\n): boolean => !!data && !!data.fields && data.fields.some((field) => field.name === fieldName);\n\nconst _supportsDeprecatedArgumentsArg = (\n  data: IntrospectSupportQueryData['field' | 'directive']\n): boolean => {\n  const argsField = data && data.fields && data.fields.find((field) => field.name === 'args');\n  return !!(\n    argsField &&\n    argsField.args &&\n    argsField.args.find((arg) => arg.name === 'includeDeprecated')\n  );\n};\n\n/** Evaluates data from a {@link makeIntrospectSupportQuery} result to {@link SupportedFeatures} */\nexport const toSupportedFeatures = (data: IntrospectSupportQueryData): SupportedFeatures => ({\n  directiveIsRepeatable: _hasField(data.directive, 'isRepeatable'),\n  specifiedByURL: _hasField(data.type, 'specifiedByURL'),\n  inputValueDeprecation: _hasField(data.inputValue, 'isDeprecated'),\n  directiveArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(data.directive),\n  fieldArgumentsIsDeprecated: _supportsDeprecatedArgumentsArg(data.field),\n});\n\nlet _introspectionQuery: DocumentNode | undefined;\nlet _previousSupport: SupportedFeatures | undefined;\n/** Builds an introspection query as AST */\nexport const makeIntrospectionQuery = (support: SupportedFeatures): DocumentNode => {\n  if (_introspectionQuery && _previousSupport === support) {\n    return _introspectionQuery;\n  } else {\n    return (_introspectionQuery = _makeIntrospectionQuery((_previousSupport = support)));\n  }\n};\n\nconst _makeIntrospectionQuery = (support: SupportedFeatures): DocumentNode => ({\n  kind: Kind.DOCUMENT,\n  definitions: [\n    {\n      kind: Kind.OPERATION_DEFINITION,\n      name: { kind: Kind.NAME, value: 'IntrospectionQuery' },\n      operation: OperationTypeNode.QUERY,\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: '__schema' },\n            selectionSet: _makeSchemaSelection(support),\n          },\n        ],\n      },\n    } satisfies OperationDefinitionNode,\n\n    _makeSchemaFullTypeFragment(support),\n    _makeSchemaInputValueFragment(support),\n    _makeTypeRefFragment(),\n  ],\n});\n\n/** Builds a support matrix query resulting in {@link IntrospectSupportQueryData} results */\nexport const makeIntrospectSupportQuery = (): DocumentNode => ({\n  kind: Kind.DOCUMENT,\n  definitions: [\n    {\n      kind: Kind.OPERATION_DEFINITION,\n      name: { kind: Kind.NAME, value: 'IntrospectSupportQuery' },\n      operation: OperationTypeNode.QUERY,\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'directive' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__Directive' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: true }),\n          },\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'field' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__Field' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: true }),\n          },\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'type' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__Type' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: false }),\n          },\n          {\n            kind: Kind.FIELD,\n            alias: { kind: Kind.NAME, value: 'inputValue' },\n            name: { kind: Kind.NAME, value: '__type' },\n            arguments: [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'name' },\n                value: { kind: Kind.STRING, value: '__InputValue' },\n              },\n            ],\n            selectionSet: _makeFieldNamesSelection({ includeArgs: false }),\n          },\n        ],\n      },\n    } satisfies OperationDefinitionNode,\n  ],\n});\n\nconst _makeFieldNamesSelection = (options: { includeArgs: boolean }): SelectionSetNode => ({\n  kind: Kind.SELECTION_SET,\n  selections: [\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'fields' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n          ...(options.includeArgs\n            ? ([\n                {\n                  kind: Kind.FIELD,\n                  name: { kind: Kind.NAME, value: 'args' },\n                  selectionSet: {\n                    kind: Kind.SELECTION_SET,\n                    selections: [\n                      {\n                        kind: Kind.FIELD,\n                        name: { kind: Kind.NAME, value: 'name' },\n                      },\n                    ],\n                  },\n                },\n              ] as const)\n            : []),\n        ],\n      },\n    },\n  ],\n});\n\nconst _makeSchemaSelection = (support: SupportedFeatures): SelectionSetNode => ({\n  kind: Kind.SELECTION_SET,\n  selections: [\n    // queryType { name }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'queryType' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n      },\n    },\n    // mutationType { name }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'mutationType' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n      },\n    },\n    // subscriptionType { name }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'subscriptionType' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n      },\n    },\n    // types { ...FullType }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'types' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FRAGMENT_SPREAD,\n            name: { kind: Kind.NAME, value: 'FullType' },\n          },\n        ],\n      },\n    },\n    // directives { name description locations args }\n    {\n      kind: Kind.FIELD,\n      name: { kind: Kind.NAME, value: 'directives' },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'description' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'locations' },\n          },\n          _makeSchemaArgsField(support.directiveArgumentsIsDeprecated),\n          ...(support.directiveIsRepeatable\n            ? ([\n                {\n                  kind: Kind.FIELD,\n                  name: { kind: Kind.NAME, value: 'isRepeatable' },\n                },\n              ] as const)\n            : []),\n        ],\n      },\n    },\n  ],\n});\n\nconst _makeSchemaFullTypeFragment = (support: SupportedFeatures): FragmentDefinitionNode => ({\n  kind: Kind.FRAGMENT_DEFINITION,\n  name: { kind: Kind.NAME, value: 'FullType' },\n  typeCondition: { kind: Kind.NAMED_TYPE, name: { kind: Kind.NAME, value: '__Type' } },\n  selectionSet: {\n    kind: Kind.SELECTION_SET,\n    selections: [\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'kind' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'name' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'description' },\n      },\n      ...(support.specifiedByURL\n        ? ([\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'specifiedByURL' },\n            },\n          ] as const)\n        : []),\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'fields' },\n        arguments: [\n          {\n            kind: Kind.ARGUMENT,\n            name: { kind: Kind.NAME, value: 'includeDeprecated' },\n            value: { kind: Kind.BOOLEAN, value: true },\n          },\n        ],\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'name' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'description' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'isDeprecated' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'deprecationReason' },\n            },\n            _makeSchemaArgsField(support.fieldArgumentsIsDeprecated),\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'type' },\n              selectionSet: {\n                kind: Kind.SELECTION_SET,\n                selections: [\n                  {\n                    kind: Kind.FRAGMENT_SPREAD,\n                    name: { kind: Kind.NAME, value: 'TypeRef' },\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'interfaces' },\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'TypeRef' },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'possibleTypes' },\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'TypeRef' },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'inputFields' },\n        arguments: support.inputValueDeprecation\n          ? [\n              {\n                kind: Kind.ARGUMENT,\n                name: { kind: Kind.NAME, value: 'includeDeprecated' },\n                value: { kind: Kind.BOOLEAN, value: true },\n              },\n            ]\n          : [],\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'InputValue' },\n            },\n          ],\n        },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'enumValues' },\n        arguments: [\n          {\n            kind: Kind.ARGUMENT,\n            name: { kind: Kind.NAME, value: 'includeDeprecated' },\n            value: { kind: Kind.BOOLEAN, value: true },\n          },\n        ],\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n\n          selections: [\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'name' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'description' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'isDeprecated' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'deprecationReason' },\n            },\n          ],\n        },\n      },\n    ],\n  },\n});\n\nconst _makeSchemaArgsField = (supportsValueDeprecation: boolean): FieldNode => ({\n  kind: Kind.FIELD,\n  name: { kind: Kind.NAME, value: 'args' },\n  arguments: supportsValueDeprecation\n    ? [\n        {\n          kind: Kind.ARGUMENT,\n          name: { kind: Kind.NAME, value: 'includeDeprecated' },\n          value: { kind: Kind.BOOLEAN, value: true },\n        },\n      ]\n    : [],\n  selectionSet: {\n    kind: Kind.SELECTION_SET,\n    selections: [\n      {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: { kind: Kind.NAME, value: 'InputValue' },\n      },\n    ],\n  },\n});\n\nconst _makeSchemaInputValueFragment = (support: SupportedFeatures): FragmentDefinitionNode => ({\n  kind: Kind.FRAGMENT_DEFINITION,\n  name: { kind: Kind.NAME, value: 'InputValue' },\n  typeCondition: { kind: Kind.NAMED_TYPE, name: { kind: Kind.NAME, value: '__InputValue' } },\n  selectionSet: {\n    kind: Kind.SELECTION_SET,\n    selections: [\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'name' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'description' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'defaultValue' },\n      },\n      {\n        kind: Kind.FIELD,\n        name: { kind: Kind.NAME, value: 'type' },\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: Kind.FRAGMENT_SPREAD,\n              name: { kind: Kind.NAME, value: 'TypeRef' },\n            },\n          ],\n        },\n      },\n      ...(support.inputValueDeprecation\n        ? ([\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'isDeprecated' },\n            },\n            {\n              kind: Kind.FIELD,\n              name: { kind: Kind.NAME, value: 'deprecationReason' },\n            },\n          ] as const)\n        : []),\n    ],\n  },\n});\n\nconst _makeTypeRefFragment = (): FragmentDefinitionNode => ({\n  kind: Kind.FRAGMENT_DEFINITION,\n  name: { kind: Kind.NAME, value: 'TypeRef' },\n  typeCondition: { kind: Kind.NAMED_TYPE, name: { kind: Kind.NAME, value: '__Type' } },\n  selectionSet: _makeTypeRefSelection(0),\n});\n\nconst _makeTypeRefSelection = (depth: number): SelectionSetNode => ({\n  kind: Kind.SELECTION_SET,\n  selections:\n    depth < 9\n      ? [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'kind' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'ofType' },\n            selectionSet: _makeTypeRefSelection(depth + 1),\n          },\n        ]\n      : [\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'kind' },\n          },\n          {\n            kind: Kind.FIELD,\n            name: { kind: Kind.NAME, value: 'name' },\n          },\n        ],\n});\n","import type { IntrospectionQuery } from 'graphql';\nimport { buildSchema, buildClientSchema, executeSync } from 'graphql';\nimport { CombinedError } from '@urql/core';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\nimport { makeIntrospectionQuery } from './query';\nimport type { SupportedFeatures } from './query';\n\nimport type { SchemaLoader, SchemaLoaderResult, OnSchemaUpdate } from './types';\n\ninterface LoadFromSDLConfig {\n  name?: string;\n  assumeValid?: boolean;\n  file: string;\n}\n\nconst ALL_SUPPORTED_FEATURES: SupportedFeatures = {\n  directiveIsRepeatable: true,\n  specifiedByURL: true,\n  inputValueDeprecation: true,\n  directiveArgumentsIsDeprecated: true,\n  fieldArgumentsIsDeprecated: true,\n};\n\nexport function loadFromSDL(config: LoadFromSDLConfig): SchemaLoader {\n  const subscriptions = new Set<OnSchemaUpdate>();\n\n  let controller: AbortController | null = null;\n  let result: SchemaLoaderResult | null = null;\n\n  const load = async (): Promise<SchemaLoaderResult> => {\n    const ext = path.extname(config.file);\n    const data = await fs.readFile(config.file, { encoding: 'utf8' });\n    if (ext === '.json') {\n      const introspection = JSON.parse(data) as IntrospectionQuery | null;\n      if (!introspection || !introspection.__schema) {\n        throw new Error(\n          'Parsing JSON introspection data failed.\\n' +\n            'The JSON payload did not evaluate to an introspection schema.'\n        );\n      }\n      return {\n        introspection: {\n          ...introspection,\n          name: config.name,\n        },\n        schema: buildClientSchema(introspection, { assumeValid: !!config.assumeValid }),\n      };\n    } else {\n      const schema = buildSchema(data, { assumeValidSDL: !!config.assumeValid });\n      const query = makeIntrospectionQuery(ALL_SUPPORTED_FEATURES);\n      const queryResult = executeSync({ schema, document: query });\n      if (queryResult.errors) {\n        throw new CombinedError({ graphQLErrors: queryResult.errors as any[] });\n      } else if (queryResult.data) {\n        const introspection = {\n          ...(queryResult.data as unknown as IntrospectionQuery),\n          name: config.name,\n        };\n        return { introspection, schema };\n      } else {\n        throw new Error(\n          'Executing introspection against SDL schema failed.\\n' +\n            '`graphql` failed to return any schema data or error.'\n        );\n      }\n    }\n  };\n\n  const watch = async () => {\n    controller = new AbortController();\n    const watcher = fs.watch(config.file, {\n      signal: controller.signal,\n      persistent: false,\n    });\n    try {\n      for await (const _event of watcher) {\n        if ((result = await load())) {\n          for (const subscriber of subscriptions) subscriber(result);\n        }\n      }\n    } catch (error: any) {\n      if (error.name !== 'AbortError') throw error;\n    } finally {\n      controller = null;\n    }\n  };\n\n  return {\n    get name() {\n      return config.name;\n    },\n    async load(reload?: boolean) {\n      return reload || !result ? (result = await load()) : result;\n    },\n    notifyOnUpdate(onUpdate) {\n      if (!subscriptions.size) watch();\n      subscriptions.add(onUpdate);\n      return () => {\n        subscriptions.delete(onUpdate);\n        if (!subscriptions.size && controller) {\n          controller.abort();\n        }\n      };\n    },\n    async loadIntrospection() {\n      const result = await this.load();\n      return result && result.introspection;\n    },\n    async loadSchema() {\n      const result = await this.load();\n      return result && result.schema;\n    },\n  };\n}\n","import { makeSubject as r, mergeMap as e, filter as t, takeUntil as a, debounce as o, fromValue as n, merge as i } from \"wonka\";\n\nimport { makeOperation as u } from \"@urql/core\";\n\nvar retryExchange = y => {\n  var {retryIf: d, retryWith: s} = y;\n  var l = y.initialDelayMs || 1e3;\n  var p = y.maxDelayMs || 15e3;\n  var m = y.maxNumberAttempts || 2;\n  var c = null != y.randomDelay ? !!y.randomDelay : !0;\n  return ({forward: y, dispatchDebug: v}) => f => {\n    var {source: h, next: x} = r();\n    var E = e((r => {\n      var e = r.context.retry || {\n        count: 0,\n        delay: null\n      };\n      var i = ++e.count;\n      var y = e.delay || l;\n      var d = Math.random() + 1.5;\n      if (c) {\n        if (y * d < p) {\n          y *= d;\n        } else {\n          y = p;\n        }\n      } else {\n        y = Math.min(i * l, p);\n      }\n      e.delay = y;\n      var s = t((e => (\"query\" === e.kind || \"teardown\" === e.kind) && e.key === r.key))(f);\n      \"production\" !== process.env.NODE_ENV && v({\n        type: \"retryAttempt\",\n        message: `The operation has failed and a retry has been triggered (${i} / ${m})`,\n        operation: r,\n        data: {\n          retryCount: i,\n          delayAmount: y\n        },\n        source: \"retryExchange\"\n      });\n      return a(s)(o((() => y))(n(u(r.kind, r, {\n        ...r.context,\n        retry: e\n      }))));\n    }))(h);\n    return t((r => {\n      var e = r.operation.context.retry;\n      if (!(r.error && (d ? d(r.error, r.operation) : s || r.error.networkError))) {\n        if (e) {\n          e.count = 0;\n          e.delay = null;\n        }\n        return !0;\n      }\n      if (!((e && e.count || 0) >= m - 1)) {\n        var t = s ? s(r.error, r.operation) : r.operation;\n        if (!t) {\n          return !0;\n        }\n        x(t);\n        return !1;\n      }\n      \"production\" !== process.env.NODE_ENV && v({\n        type: \"retryExhausted\",\n        message: \"Maximum number of retries has been reached. No further retries will be performed.\",\n        operation: r.operation,\n        source: \"retryExchange\"\n      });\n      return !0;\n    }))(y(i([ f, E ])));\n  };\n};\n\nexport { retryExchange };\n//# sourceMappingURL=urql-exchange-retry.mjs.map\n","import type { IntrospectionQuery } from 'graphql';\nimport { buildClientSchema } from 'graphql';\nimport { Client, fetchExchange } from '@urql/core';\nimport { retryExchange } from '@urql/exchange-retry';\n\nimport { makeIntrospectionQuery, makeIntrospectSupportQuery, toSupportedFeatures } from './query';\nimport type { SupportedFeatures, IntrospectSupportQueryData } from './query';\n\nimport type { SchemaLoader, SchemaLoaderResult, OnSchemaUpdate } from './types';\n\ninterface LoadFromURLConfig {\n  name?: string;\n  url: URL | string;\n  headers?: HeadersInit;\n  interval?: number;\n}\n\nconst ALL_SUPPORTED_FEATURES: SupportedFeatures = {\n  directiveIsRepeatable: true,\n  specifiedByURL: true,\n  inputValueDeprecation: true,\n  directiveArgumentsIsDeprecated: true,\n  fieldArgumentsIsDeprecated: true,\n};\n\nconst NO_SUPPORTED_FEATURES: SupportedFeatures = {\n  directiveIsRepeatable: false,\n  specifiedByURL: false,\n  inputValueDeprecation: false,\n  directiveArgumentsIsDeprecated: false,\n  fieldArgumentsIsDeprecated: false,\n};\n\nexport function loadFromURL(config: LoadFromURLConfig): SchemaLoader {\n  const interval = config.interval || 60_000;\n  const subscriptions = new Set<OnSchemaUpdate>();\n\n  let timeoutID: NodeJS.Timeout | null = null;\n  let supportedFeatures: SupportedFeatures | null = null;\n  let result: SchemaLoaderResult | null = null;\n\n  const client = new Client({\n    url: `${config.url}`,\n    fetchOptions: { headers: config.headers },\n    exchanges: [\n      retryExchange({\n        initialDelayMs: 200,\n        maxDelayMs: 1_500,\n        maxNumberAttempts: 3,\n        retryWith(error, operation) {\n          if (error.networkError) process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n          return operation;\n        },\n      }),\n      fetchExchange,\n    ],\n  });\n\n  const scheduleUpdate = () => {\n    if (subscriptions.size && !timeoutID) {\n      timeoutID = setTimeout(async () => {\n        timeoutID = null;\n        try {\n          result = await load();\n        } catch (_error) {\n          result = null;\n        }\n        if (result) for (const subscriber of subscriptions) subscriber(result);\n      }, interval);\n    }\n  };\n\n  const introspect = async (support: SupportedFeatures): Promise<SchemaLoaderResult> => {\n    const query = makeIntrospectionQuery(support);\n    const introspectionResult = await client.query<IntrospectionQuery>(query, {});\n    try {\n      if (introspectionResult.error) {\n        throw introspectionResult.error;\n      } else if (introspectionResult.data) {\n        const introspection = introspectionResult.data;\n        return {\n          introspection: {\n            ...introspection,\n            name: config.name,\n          },\n          schema: buildClientSchema(introspection, { assumeValid: true }),\n        };\n      } else {\n        throw new Error(\n          'Executing introspection against API failed.\\n' +\n            'The API failed to return any schema data or error.'\n        );\n      }\n    } finally {\n      scheduleUpdate();\n    }\n  };\n\n  const load = async (): Promise<SchemaLoaderResult> => {\n    if (!supportedFeatures) {\n      const query = makeIntrospectSupportQuery();\n      const supportResult = await client.query<IntrospectSupportQueryData>(query, {});\n      if (supportResult.error && supportResult.error.graphQLErrors.length > 0) {\n        // If we failed to determine support, we try to activate all introspection features\n        const _result = await introspect(ALL_SUPPORTED_FEATURES);\n        if (_result) {\n          // If we succeed, we can return the introspection and enable all introspection features\n          supportedFeatures = ALL_SUPPORTED_FEATURES;\n          return _result;\n        } else {\n          // Otherwise, we assume no extra introspection features are supported,\n          // since all introspection spec additions were made in a single spec revision\n          supportedFeatures = NO_SUPPORTED_FEATURES;\n        }\n      } else if (supportResult.data && !supportResult.error) {\n        // Succeeding the support query, we get the supported features\n        supportedFeatures = toSupportedFeatures(supportResult.data);\n      } else if (supportResult.error) {\n        // On misc. error, we rethrow and reset supported features\n        supportedFeatures = null;\n        throw supportResult.error;\n      } else {\n        // Otherwise we assume no features are supported\n        supportedFeatures = NO_SUPPORTED_FEATURES;\n      }\n    }\n    return introspect(supportedFeatures);\n  };\n\n  return {\n    get name() {\n      return config.name;\n    },\n    async load(reload?: boolean) {\n      return reload || !result ? (result = await load()) : result;\n    },\n    notifyOnUpdate(onUpdate) {\n      subscriptions.add(onUpdate);\n      return () => {\n        subscriptions.delete(onUpdate);\n        if (!subscriptions.size && timeoutID) {\n          clearTimeout(timeoutID);\n          timeoutID = null;\n        }\n      };\n    },\n    async loadIntrospection() {\n      const result = await this.load();\n      return result && result.introspection;\n    },\n    async loadSchema() {\n      const result = await this.load();\n      return result && result.schema;\n    },\n  };\n}\n","export type * from './types';\n\nimport path from 'node:path';\nimport { loadFromSDL } from './sdl';\nimport { loadFromURL } from './url';\n\nimport type {\n  SchemaLoaderResult,\n  SchemaLoader,\n  SchemaOrigin,\n  SchemaRef,\n  SingleSchemaInput,\n  MultiSchemaInput,\n  BaseLoadConfig,\n} from './types';\n\nexport { loadFromSDL, loadFromURL };\n\nexport const getURLConfig = (origin: SchemaOrigin | null) => {\n  try {\n    return origin\n      ? {\n          url: new URL(typeof origin === 'object' ? origin.url : origin),\n          headers: typeof origin === 'object' ? origin.headers : undefined,\n        }\n      : null;\n  } catch (_error) {\n    return null;\n  }\n};\n\nexport interface LoadConfig extends BaseLoadConfig {\n  name?: string;\n  origin: SchemaOrigin;\n}\n\nexport function load(config: LoadConfig): SchemaLoader {\n  const urlOrigin = getURLConfig(config.origin);\n  if (urlOrigin) {\n    return loadFromURL({\n      ...urlOrigin,\n      interval: config.fetchInterval,\n      name: config.name,\n    });\n  } else if (typeof config.origin === 'string') {\n    const file = config.rootPath ? path.resolve(config.rootPath, config.origin) : config.origin;\n    const assumeValid = config.assumeValid != null ? config.assumeValid : true;\n    return loadFromSDL({\n      file,\n      assumeValid,\n      name: config.name,\n    });\n  } else {\n    throw new Error(`Configuration contains an invalid \"schema\" option`);\n  }\n}\n\nexport function loadRef(\n  input: SingleSchemaInput | MultiSchemaInput | (SingleSchemaInput & MultiSchemaInput)\n): SchemaRef {\n  const teardowns: (() => void)[] = [];\n\n  let _loaders: { input: SingleSchemaInput; loader: SchemaLoader }[] | undefined;\n  const getLoaders = (config?: BaseLoadConfig) => {\n    if (!_loaders) {\n      _loaders = (('schemas' in input && input.schemas) || []).map((input) => ({\n        input,\n        loader: load({ ...config, origin: input.schema, name: input.name }),\n      }));\n      if ('schema' in input && input.schema) {\n        _loaders.push({\n          input: { ...input, name: undefined },\n          loader: load({ ...config, origin: input.schema }),\n        });\n      }\n    }\n    return _loaders;\n  };\n\n  const ref: SchemaRef = {\n    version: 0,\n    current: null,\n\n    multi: (('schemas' in input && input.schemas) || []).reduce((acc, { name }) => {\n      if (name) acc[name] = null;\n      return acc;\n    }, {}),\n\n    autoupdate(config: BaseLoadConfig, onUpdate) {\n      const loaders = getLoaders(config);\n      teardowns.push(\n        ...loaders.map(({ input, loader }) => {\n          loader\n            .load()\n            .then((result) => {\n              ref.version++;\n              if (input.name) {\n                ref.multi[input.name] = { ...input, ...result };\n              } else {\n                ref.current = { ...input, ...result };\n              }\n            })\n            .catch((_error) => {\n              /*noop*/\n            });\n          return loader.notifyOnUpdate((result) => {\n            ref.version++;\n            if (input.name) {\n              ref.multi[input.name] = { ...input, ...result };\n            } else {\n              ref.current = { ...input, ...result };\n            }\n            onUpdate(ref, input);\n          });\n        })\n      );\n      return () => {\n        let teardown: (() => void) | undefined;\n        while ((teardown = teardowns.pop()) != null) teardown();\n      };\n    },\n    async load(config: BaseLoadConfig) {\n      const loaders = getLoaders(config);\n      await Promise.all(\n        loaders.map(async ({ input, loader }) => {\n          const result = await loader.load();\n          ref.version++;\n          if (input.name) {\n            ref.multi[input.name] = { ...input, ...result };\n          } else {\n            ref.current = { ...input, ...result };\n          }\n        })\n      );\n      return ref as SchemaRef<SchemaLoaderResult>;\n    },\n  };\n\n  return ref;\n}\n","import * as path from 'node:path';\n\nexport const cwd = process.cwd();\n\nexport const maybeRelative = (filePath: string): string => {\n  const relative = path.relative(cwd, filePath);\n  return !relative.startsWith('..') ? relative : filePath;\n};\n","import type ts from 'typescript';\nimport { maybeRelative } from './helpers';\n\nexport class TSError extends Error {\n  readonly name: 'TSError';\n  readonly diagnostic: ts.Diagnostic;\n  constructor(diagnostic: ts.Diagnostic) {\n    let message =\n      typeof diagnostic.messageText !== 'string'\n        ? diagnostic.messageText.messageText\n        : diagnostic.messageText;\n    if (diagnostic.file) message += ` (${maybeRelative(diagnostic.file.fileName)})`;\n    super(message);\n    this.name = 'TSError';\n    this.diagnostic = diagnostic;\n  }\n}\n\nexport class TadaError extends Error {\n  readonly name: 'TadaError';\n  constructor(message: string) {\n    super(message);\n    this.name = 'TadaError';\n  }\n}\n","import * as path from 'node:path';\nimport { TadaError } from './errors';\nimport { getURLConfig } from './loaders';\nimport type { SchemaOrigin } from './loaders';\n\nexport interface BaseConfig {\n  template?: string;\n}\n\nexport interface SchemaConfig {\n  name?: string;\n  schema: SchemaOrigin;\n  tadaOutputLocation?: string;\n  tadaTurboLocation?: string;\n  tadaPersistedLocation?: string;\n}\n\nconst SCHEMA_PROPS = [\n  'name',\n  'tadaOutputLocation',\n  'tadaTurboLocation',\n  'tadaPersistedLocation',\n] as const;\n\ninterface MultiSchemaConfig extends SchemaConfig {\n  name: string;\n}\n\nexport type GraphQLSPConfig = BaseConfig & (SchemaConfig | { schemas: MultiSchemaConfig[] });\n\nconst parseSchemaConfig = (input: unknown, rootPath: string): SchemaConfig => {\n  const resolveConfigDir = (input: string | undefined) => {\n    if (!input) return input;\n    return path.normalize(\n      input.replace(/\\${([^}]+)}/, (_match, name) => {\n        if (name === 'configDir') {\n          return rootPath;\n        } else {\n          throw new TadaError(\n            `Substitution \"\\${${name}}\" is not recognized (did you mean 'configDir'?)`\n          );\n        }\n      })\n    );\n  };\n\n  if (input == null || typeof input !== 'object') {\n    throw new TadaError(`Schema is not configured properly (Received: ${input})`);\n  }\n\n  if ('schema' in input && input.schema && typeof input.schema === 'object') {\n    const { schema } = input;\n    if (!('url' in schema)) {\n      throw new TadaError('Schema contains a `schema` object, but no `url` property');\n    }\n\n    if ('headers' in schema && schema.headers && typeof schema.headers === 'object') {\n      for (const key in schema.headers) {\n        if (schema.headers[key] && typeof schema.headers[key] !== 'string') {\n          throw new TadaError(\n            'Headers at `schema.headers` contain a non-string value at key: ' + key\n          );\n        }\n      }\n    } else if ('headers' in schema) {\n      throw new TadaError(\"Schema contains a `schema.headers` property, but it's not an object\");\n    }\n  }\n\n  if (!('schema' in input) || typeof input.schema !== 'string') {\n    throw new TadaError('Schema is missing a `schema` property');\n  } else if (\n    'tadaOutputLocation' in input &&\n    input.tadaOutputLocation &&\n    typeof input.tadaOutputLocation !== 'string'\n  ) {\n    throw new TadaError(\n      \"Schema contains a `tadaOutputLocation` property, but it's not a file path\"\n    );\n  } else if (\n    'tadaTurboLocation' in input &&\n    input.tadaTurboLocation &&\n    typeof input.tadaTurboLocation !== 'string'\n  ) {\n    throw new TadaError(\"Schema contains a `tadaTurboLocation` property, but it's not a file path\");\n  } else if (\n    'tadaPersistedLocation' in input &&\n    input.tadaPersistedLocation &&\n    typeof input.tadaPersistedLocation !== 'string'\n  ) {\n    throw new TadaError(\n      \"Schema contains a `tadaPersistedLocation` property, but it's not a file path\"\n    );\n  }\n\n  const output = input as any as SchemaConfig;\n\n  let schema: SchemaOrigin = output.schema;\n  if (typeof schema === 'string') {\n    const url = getURLConfig(schema);\n    if (!url) schema = resolveConfigDir(schema) || schema;\n  }\n\n  return {\n    ...output,\n    schema,\n    tadaOutputLocation: resolveConfigDir(output.tadaOutputLocation),\n    tadaTurboLocation: resolveConfigDir(output.tadaTurboLocation),\n    tadaPersistedLocation: resolveConfigDir(output.tadaPersistedLocation),\n  };\n};\n\nexport const parseConfig = (\n  input: unknown,\n  /** Defines the path of the \"main\" `tsconfig.json` file.\n   * @remarks\n   * This should be the `rootPath` output from `loadConfig`,\n   * which is the path of the user's `tsconfig.json` before\n   * resolving `extends` options.\n   */\n  rootPath: string = process.cwd()\n): GraphQLSPConfig => {\n  if (input == null || typeof input !== 'object') {\n    throw new TadaError(`Configuration is of an invalid type (Received: ${input})`);\n  } else if ('template' in input && input.template && typeof input.template !== 'string') {\n    throw new TadaError(\"Configuration contains a `template` property, but it's not a string\");\n  } else if ('name' in input && input.name && typeof input.name !== 'string') {\n    throw new TadaError(\"Configuration contains a `name` property, but it's not a string\");\n  }\n\n  if ('schemas' in input) {\n    if (!Array.isArray(input.schemas)) {\n      throw new TadaError(\"Configuration contains a `schema` property, but it's not an array\");\n    }\n\n    if ('schema' in input) {\n      throw new TadaError(\n        'If configuration contains a `schemas` property, it cannot contain a `schema` configuration.'\n      );\n    } else if ('tadaOutputLocation' in input) {\n      throw new TadaError(\n        \"If configuration contains a `schemas` property, it cannot contain a 'tadaOutputLocation` configuration.\"\n      );\n    } else if ('tadaTurboLocation' in input) {\n      throw new TadaError(\n        \"If configuration contains a `schemas` property, it cannot contain a 'tadaTurboLocation` configuration.\"\n      );\n    } else if ('tadaPersistedLocation' in input) {\n      throw new TadaError(\n        \"If configuration contains a `schemas` property, it cannot contain a 'tadaPersistedLocation` configuration.\"\n      );\n    }\n\n    const schemas = input.schemas.map((schema): MultiSchemaConfig => {\n      if (!('name' in schema) || !schema.name || typeof schema.name !== 'string')\n        throw new TadaError('All `schemas` configurations must contain a `name` label.');\n      if (\n        !('tadaOutputLocation' in schema) ||\n        !schema.tadaOutputLocation ||\n        typeof schema.tadaOutputLocation !== 'string'\n      )\n        throw new TadaError(\n          'All `schemas` configurations must contain a `tadaOutputLocation` path.'\n        );\n      return {\n        ...parseSchemaConfig(schema, rootPath),\n        name: schema.name,\n      };\n    });\n\n    for (const prop of SCHEMA_PROPS) {\n      const values = schemas.map((schema) => schema[prop]).filter(Boolean);\n      const uniqueValues = new Set(values);\n      if (values.length !== uniqueValues.size)\n        throw new TadaError(`All '${prop}' values in \\`schemas[]\\` must be unique.`);\n    }\n\n    return { ...input, schemas };\n  } else {\n    return { ...input, ...parseSchemaConfig(input, rootPath) };\n  }\n};\n\nexport const getSchemaNamesFromConfig = (config: GraphQLSPConfig): Set<null | string> => {\n  return new Set<null | string>([\n    ...('schema' in config ? [null] : []),\n    ...('schemas' in config ? config.schemas.map((input) => input.name) : []),\n  ]);\n};\n\nexport const getSchemaConfigForName = (\n  config: GraphQLSPConfig,\n  name: string | undefined\n): SchemaConfig | null => {\n  if (name && 'name' in config && config.name === name) {\n    return config;\n  } else if (!name && !('schemas' in config)) {\n    return config;\n  } else if (name && 'schemas' in config) {\n    for (let index = 0; index < config.schemas.length; index++)\n      if (config.schemas[index].name === name) return config.schemas[index];\n    return null;\n  } else {\n    return null;\n  }\n};\n","import ts from 'typescript';\nimport * as path from 'node:path';\nimport * as fs from 'node:fs/promises';\nimport { createRequire } from 'node:module';\nimport type { Stats } from 'node:fs';\nimport type { TsConfigJson } from 'type-fest';\n\nimport { cwd, maybeRelative } from './helpers';\nimport { TSError, TadaError } from './errors';\n\nconst TSCONFIG = 'tsconfig.json';\n\nconst isFile = (stat: Stats): boolean => stat.isFile();\nconst isDir = (stat: Stats): boolean => stat.isDirectory();\nconst stat = (file: string, predicate = isFile): Promise<boolean> =>\n  fs\n    .stat(file)\n    .then(predicate)\n    .catch(() => false);\n\nconst _resolve =\n  typeof require !== 'undefined'\n    ? require.resolve.bind(require)\n    : createRequire(import.meta.url).resolve;\nconst resolveExtend = async (extend: string, from: string) => {\n  try {\n    return toTSConfigPath(_resolve(extend, { paths: [from] }));\n  } catch (_error) {\n    return null;\n  }\n};\n\nconst toTSConfigPath = (tsconfigPath: string): string =>\n  path.extname(tsconfigPath) !== '.json'\n    ? path.resolve(cwd, tsconfigPath, TSCONFIG)\n    : path.resolve(cwd, tsconfigPath);\n\nexport const readTSConfigFile = async (filePath: string): Promise<TsConfigJson> => {\n  const tsconfigPath = toTSConfigPath(filePath);\n  const contents = await fs.readFile(tsconfigPath, 'utf8');\n  const result = ts.parseConfigFileTextToJson(tsconfigPath, contents);\n  if (result.error) throw new TSError(result.error);\n  return result.config || {};\n};\n\nexport const findTSConfigFile = async (targetPath?: string): Promise<string | null> => {\n  let tsconfigPath = toTSConfigPath(targetPath || cwd);\n  const rootPath = toTSConfigPath(path.resolve(tsconfigPath, '/'));\n  while (tsconfigPath !== rootPath) {\n    if (await stat(tsconfigPath)) return tsconfigPath;\n    const gitPath = path.resolve(tsconfigPath, '..', '.git');\n    if (await stat(gitPath, isDir)) return null;\n    const parentPath = toTSConfigPath(path.resolve(tsconfigPath, '..', '..'));\n    if (parentPath === tsconfigPath) break;\n    tsconfigPath = parentPath;\n  }\n  return null;\n};\n\nconst getPluginConfig = (tsconfig: TsConfigJson | null): Record<string, unknown> | null =>\n  (tsconfig &&\n    tsconfig.compilerOptions &&\n    tsconfig.compilerOptions.plugins &&\n    tsconfig.compilerOptions.plugins.find(\n      (x) => x.name === '@0no-co/graphqlsp' || x.name === 'gql.tada/lsp'\n    )) ||\n  null;\n\nexport interface LoadConfigResult {\n  pluginConfig: Record<string, unknown>;\n  configPath: string;\n  rootPath: string;\n}\n\nexport const loadConfig = async (targetPath?: string): Promise<LoadConfigResult> => {\n  const rootTsconfigPath = await findTSConfigFile(targetPath);\n  if (!rootTsconfigPath) {\n    throw new TadaError(\n      targetPath\n        ? `No tsconfig.json found at or above: ${maybeRelative(targetPath)}`\n        : 'No tsconfig.json found at or above current working directory'\n    );\n  }\n\n  const load = async (targetPath: string): Promise<LoadConfigResult> => {\n    const tsconfig = await readTSConfigFile(targetPath);\n    const pluginConfig = getPluginConfig(tsconfig);\n\n    if (pluginConfig) {\n      return {\n        pluginConfig,\n        configPath: targetPath,\n        rootPath: path.dirname(rootTsconfigPath),\n      };\n    }\n\n    if (Array.isArray(tsconfig.extends)) {\n      for (let extend of tsconfig.extends) {\n        if (path.extname(extend) !== '.json') extend += '.json';\n        try {\n          const tsconfigPath = await resolveExtend(extend, path.dirname(rootTsconfigPath));\n          if (tsconfigPath) return load(tsconfigPath);\n        } catch (_error) {}\n      }\n    } else if (tsconfig.extends) {\n      try {\n        const tsconfigPath = await resolveExtend(tsconfig.extends, path.dirname(rootTsconfigPath));\n        if (tsconfigPath) return load(tsconfigPath);\n      } catch (_error) {}\n    }\n\n    throw new TadaError(\n      `Could not find a valid GraphQLSP plugin entry in: ${maybeRelative(rootTsconfigPath)}`\n    );\n  };\n\n  return await load(rootTsconfigPath);\n};\n\n/** @deprecated Use {@link loadConfig} instead */\nexport const resolveTypeScriptRootDir = async (\n  tsconfigPath: string\n): Promise<string | undefined> => {\n  try {\n    const result = await loadConfig(tsconfigPath);\n    return path.dirname(result.configPath);\n  } catch (_error) {\n    return undefined;\n  }\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionNamedTypeRef,\n  IntrospectionOutputTypeRef,\n  IntrospectionInputTypeRef,\n  IntrospectionInputValue,\n  IntrospectionEnumValue,\n  IntrospectionField,\n} from 'graphql';\n\nimport type { IntrospectionResult } from '../loaders';\n\nfunction nameCompare(objA: { name: string }, objB: { name: string }) {\n  return objA.name < objB.name ? -1 : objA.name > objB.name ? 1 : 0;\n}\n\nfunction mapTypeRef<const T extends IntrospectionTypeRef>(fromType: T): T;\nfunction mapTypeRef(fromType: IntrospectionTypeRef): IntrospectionTypeRef;\nfunction mapTypeRef(fromType: IntrospectionOutputTypeRef): IntrospectionOutputTypeRef;\nfunction mapTypeRef(fromType: IntrospectionInputTypeRef): IntrospectionInputTypeRef;\n\nfunction mapTypeRef(fromType: IntrospectionTypeRef): IntrospectionTypeRef {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n      return {\n        kind: fromType.kind,\n        ofType: mapTypeRef(fromType.ofType),\n      };\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapTypeRef(fromType.ofType),\n      };\n    case 'ENUM':\n    case 'INPUT_OBJECT':\n    case 'SCALAR':\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return {\n        kind: fromType.kind,\n        name: fromType.name,\n      };\n  }\n}\n\nfunction mapEnumValue(value: IntrospectionEnumValue): IntrospectionEnumValue {\n  return {\n    name: value.name,\n    isDeprecated: !!value.isDeprecated,\n    deprecationReason: undefined,\n  };\n}\n\nfunction mapInputField(value: IntrospectionInputValue): IntrospectionInputValue {\n  return {\n    name: value.name,\n    type: mapTypeRef(value.type),\n    defaultValue: value.defaultValue || undefined,\n  };\n}\n\nfunction mapField(field: IntrospectionField): IntrospectionField {\n  return {\n    name: field.name,\n    type: mapTypeRef(field.type),\n    args: field.args ? field.args.map(mapInputField).sort(nameCompare) : [],\n    isDeprecated: !!field.isDeprecated,\n    deprecationReason: undefined,\n  };\n}\n\nfunction mapPossibleType<T extends IntrospectionNamedTypeRef>(ref: T): T {\n  return {\n    kind: ref.kind,\n    name: ref.name,\n  } as T;\n}\n\nfunction minifyIntrospectionType(type: IntrospectionType): IntrospectionType {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(mapEnumValue),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(mapInputField),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields ? type.fields.map(mapField).sort(nameCompare) : [],\n        interfaces: type.interfaces ? type.interfaces.map(mapPossibleType).sort(nameCompare) : [],\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields ? type.fields.map(mapField).sort(nameCompare) : [],\n        interfaces: type.interfaces ? type.interfaces.map(mapPossibleType).sort(nameCompare) : [],\n        possibleTypes: type.possibleTypes\n          ? type.possibleTypes.map(mapPossibleType).sort(nameCompare)\n          : [],\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes\n          ? type.possibleTypes.map(mapPossibleType).sort(nameCompare)\n          : [],\n      };\n  }\n}\n\n/** Minifies an {@link IntrospectionQuery} for use with Graphcache or the `populateExchange`.\n *\n * @param schema - An {@link IntrospectionQuery} object to be minified.\n * @param opts - An optional {@link MinifySchemaOptions} configuration object.\n * @returns the minified {@link IntrospectionQuery} object.\n *\n * @remarks\n * `minifyIntrospectionQuery` reduces the size of an {@link IntrospectionQuery} by\n * removing data and information that a client-side consumer, like Graphcache or the\n * `populateExchange`, may not require.\n *\n * At the very least, it will remove system types, descriptions, depreactions,\n * and source locations. Unless disabled via the options passed, it will also\n * by default remove all scalars, enums, inputs, and directives.\n *\n * @throws\n * If `schema` receives an object that isn’t an {@link IntrospectionQuery}, a\n * {@link TypeError} will be thrown.\n */\nexport const minifyIntrospectionQuery = (\n  schema: IntrospectionQuery | IntrospectionResult\n): IntrospectionResult => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter((type) => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            type.kind === 'SCALAR' ||\n            type.kind === 'ENUM' ||\n            type.kind === 'INPUT_OBJECT' ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType)\n    .sort(nameCompare);\n\n  return {\n    name: 'name' in schema ? schema.name : undefined,\n    __schema: {\n      queryType: {\n        kind: queryType.kind,\n        name: queryType.name,\n      },\n      mutationType: mutationType\n        ? {\n            kind: mutationType.kind,\n            name: mutationType.name,\n          }\n        : null,\n      subscriptionType: subscriptionType\n        ? {\n            kind: subscriptionType.kind,\n            name: subscriptionType.name,\n          }\n        : null,\n      types: minifiedTypes,\n      directives: [],\n    },\n  };\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionEnumValue,\n  IntrospectionInputValue,\n  IntrospectionTypeRef,\n  IntrospectionNamedTypeRef,\n  IntrospectionField,\n} from 'graphql';\n\nimport type { IntrospectionResult } from '../loaders';\n\nconst printName = (input: string | undefined | null): string => (input ? `'${input}'` : 'never');\n\nconst printTypeRef = (typeRef: IntrospectionTypeRef) => {\n  if (typeRef.kind === 'NON_NULL') {\n    return `{ kind: 'NON_NULL'; name: never; ofType: ${printTypeRef(typeRef.ofType)}; }`;\n  } else if (typeRef.kind === 'LIST') {\n    return `{ kind: 'LIST'; name: never; ofType: ${printTypeRef(typeRef.ofType)}; }`;\n  } else {\n    return `{ kind: ${printName(typeRef.kind)}; name: ${printName(typeRef.name)}; ofType: null; }`;\n  }\n};\n\nconst printInputFields = (inputFields: readonly IntrospectionInputValue[]) => {\n  let output = '';\n  for (const inputField of inputFields) {\n    if (output) output += ', ';\n    const name = printName(inputField.name);\n    const type = printTypeRef(inputField.type);\n    const defaultValue = inputField.defaultValue ? JSON.stringify(inputField.defaultValue) : 'null';\n    output += `{ name: ${name}; type: ${type}; defaultValue: ${defaultValue} }`;\n  }\n  return `[${output}]`;\n};\n\nconst printNamedTypes = (\n  values: readonly (IntrospectionEnumValue | IntrospectionNamedTypeRef)[]\n) => {\n  if (!values.length) return 'never';\n  let output = '';\n  for (const value of values) {\n    if (output) output += ' | ';\n    output += printName(value.name);\n  }\n  return output;\n};\n\nconst printFields = (fields: readonly IntrospectionField[]) => {\n  let output = '';\n  for (const field of fields) {\n    const name = printName(field.name);\n    const type = printTypeRef(field.type);\n    output += `${printName(field.name)}: { name: ${name}; type: ${type} }; `;\n  }\n  return `{ ${output}}`;\n};\n\nexport const printIntrospectionType = (type: IntrospectionType) => {\n  if (type.kind === 'ENUM') {\n    const values = printNamedTypes(type.enumValues);\n    return `{ name: ${printName(type.name)}; enumValues: ${values}; }`;\n  } else if (type.kind === 'INPUT_OBJECT') {\n    const fields = printInputFields(type.inputFields);\n    return `{ kind: 'INPUT_OBJECT'; name: ${printName(type.name)}; inputFields: ${fields}; }`;\n  } else if (type.kind === 'OBJECT') {\n    const fields = printFields(type.fields);\n    return `{ kind: 'OBJECT'; name: ${printName(type.name)}; fields: ${fields}; }`;\n  } else if (type.kind === 'INTERFACE') {\n    const name = printName(type.name);\n    const fields = printFields(type.fields);\n    const possibleTypes = printNamedTypes(type.possibleTypes);\n    return `{ kind: 'INTERFACE'; name: ${name}; fields: ${fields}; possibleTypes: ${possibleTypes}; }`;\n  } else if (type.kind === 'UNION') {\n    const name = printName(type.name);\n    const possibleTypes = printNamedTypes(type.possibleTypes);\n    return `{ kind: 'UNION'; name: ${name}; fields: {}; possibleTypes: ${possibleTypes}; }`;\n  } else {\n    return 'unknown';\n  }\n};\n\nexport function preprocessIntrospection(\n  introspection: IntrospectionResult | IntrospectionQuery\n): string {\n  const { __schema: schema } = introspection;\n  const name = 'name' in introspection ? introspection.name : undefined;\n  const queryName = printName(schema.queryType.name);\n  const mutationName = printName(schema.mutationType && schema.mutationType.name);\n  const subscriptionName = printName(schema.subscriptionType && schema.subscriptionType.name);\n\n  let evaluatedTypes = '';\n  for (const type of schema.types) {\n    const typeStr = printIntrospectionType(type);\n    if (evaluatedTypes) evaluatedTypes += '\\n';\n    evaluatedTypes += `    ${printName(type.name)}: ${typeStr};`;\n  }\n\n  return (\n    '{\\n' +\n    `  name: ${printName(name)};\\n` +\n    `  query: ${queryName};\\n` +\n    `  mutation: ${mutationName};\\n` +\n    `  subscription: ${subscriptionName};\\n` +\n    `  types: {\\n${evaluatedTypes}\\n  };\\n}`\n  );\n}\n","const PREAMBLE_IGNORE = ['/* eslint-disable */', '/* prettier-ignore */'].join('\\n') + '\\n';\n\nconst ANNOTATION_DTS = [\n  '/** An IntrospectionQuery representation of your schema.',\n  ' *',\n  ' * @remarks',\n  ' * This is an introspection of your schema saved as a file by GraphQLSP.',\n  ' * It will automatically be used by `gql.tada` to infer the types of your GraphQL documents.',\n  ' * If you need to reuse this data or update your `scalars`, update `tadaOutputLocation` to',\n  ' * instead save to a .ts instead of a .d.ts file.',\n  ' */',\n].join('\\n');\n\nconst ANNOTATION_TS = [\n  '/** An IntrospectionQuery representation of your schema.',\n  ' *',\n  ' * @remarks',\n  ' * This is an introspection of your schema saved as a file by GraphQLSP.',\n  ' * You may import it to create a `graphql()` tag function with `gql.tada`',\n  ' * by importing it and passing it to `initGraphQLTada<>()`.',\n  ' *',\n  ' * @example',\n  ' * ```',\n  \" * import { initGraphQLTada } from 'gql.tada';\",\n  \" * import type { introspection } from './introspection';\",\n  ' *',\n  ' * export const graphql = initGraphQLTada<{',\n  ' *   introspection: typeof introspection;',\n  ' *   scalars: {',\n  ' *     DateTime: string;',\n  ' *     Json: any;',\n  ' *   };',\n  ' * }>();',\n  ' * ```',\n  ' */',\n].join('\\n');\n\nexport { PREAMBLE_IGNORE, ANNOTATION_DTS, ANNOTATION_TS };\n","import type { IntrospectionQuery } from 'graphql';\nimport type { IntrospectionResult } from '../loaders';\n\nimport { TadaError } from '../errors';\nimport { PREAMBLE_IGNORE, ANNOTATION_DTS, ANNOTATION_TS } from './constants';\nimport { preprocessIntrospection } from './preprocess';\n\nconst stringifyJson = (input: unknown | string): string =>\n  typeof input === 'string' ? input : JSON.stringify(input, null, 2);\n\ninterface OutputIntrospectionFileOptions {\n  fileType: '.ts' | '.d.ts' | string;\n  shouldPreprocess?: boolean;\n}\n\nexport function outputIntrospectionFile(\n  introspection: IntrospectionQuery | IntrospectionResult,\n  opts: OutputIntrospectionFileOptions\n): string {\n  if (/\\.d\\.ts$/.test(opts.fileType)) {\n    const json =\n      typeof introspection !== 'string' && opts.shouldPreprocess\n        ? preprocessIntrospection(introspection)\n        : stringifyJson(introspection);\n    const out = [\n      PREAMBLE_IGNORE,\n      ANNOTATION_DTS,\n      `export type introspection = ${json};\\n`,\n      \"import * as gqlTada from 'gql.tada';\\n\",\n    ];\n    // NOTE: When the `name` option is used and multiple schemas are present,\n    // we omit the automatic schema declaration and rely on the user calling\n    // `initGraphQLTada()` themselves\n    if (!('name' in introspection) || !introspection.name) {\n      out.push(\n        \"declare module 'gql.tada' {\",\n        '  interface setupSchema {',\n        '    introspection: introspection',\n        '  }',\n        '}'\n      );\n    }\n    return out.join('\\n');\n  } else if (/\\.ts$/.test(opts.fileType)) {\n    const json = stringifyJson(introspection);\n    return [\n      PREAMBLE_IGNORE,\n      ANNOTATION_TS,\n      `const introspection = ${json} as const;\\n`,\n      'export { introspection };',\n    ].join('\\n');\n  }\n\n  throw new TadaError(\n    `No available introspection format for \"${opts.fileType}\" (expected \".ts\" or \".d.ts\")`\n  );\n}\n"],"names":["rehydrateGraphQlError","r","message","extensions","name","e","nodes","source","positions","path","CombinedError","Error","constructor","graphQLErrors","map","t","a","networkError","super","this","response","toString","_hasField","data","fieldName","fields","some","field","_supportsDeprecatedArgumentsArg","argsField","find","args","arg","toSupportedFeatures","directiveIsRepeatable","directive","specifiedByURL","type","inputValueDeprecation","inputValue","directiveArgumentsIsDeprecated","fieldArgumentsIsDeprecated","_introspectionQuery","_previousSupport","makeIntrospectionQuery","support","_makeIntrospectionQuery","kind","Kind","DOCUMENT","definitions","OPERATION_DEFINITION","NAME","value","operation","OperationTypeNode","QUERY","selectionSet","SELECTION_SET","selections","FIELD","_makeSchemaSelection","_makeSchemaFullTypeFragment","_makeSchemaInputValueFragment","_makeTypeRefFragment","makeIntrospectSupportQuery","alias","arguments","ARGUMENT","STRING","_makeFieldNamesSelection","includeArgs","options","FRAGMENT_SPREAD","_makeSchemaArgsField","FRAGMENT_DEFINITION","typeCondition","NAMED_TYPE","BOOLEAN","supportsValueDeprecation","_makeTypeRefSelection","depth","ALL_SUPPORTED_FEATURES","loadFromSDL","config","subscriptions","Set","controller","result","load","async","ext","extname","file","fs","readFile","encoding","introspection","JSON","parse","__schema","schema","buildClientSchema","assumeValid","buildSchema","assumeValidSDL","query","queryResult","executeSync","document","errors","reload","notifyOnUpdate","onUpdate","size","AbortController","watcher","watch","signal","persistent","_event","subscriber","error","add","delete","abort","loadIntrospection","loadSchema","retryExchange","y","retryIf","d","retryWith","s","l","initialDelayMs","p","maxDelayMs","m","maxNumberAttempts","c","randomDelay","forward","dispatchDebug","v","f","h","next","x","E","context","retry","count","delay","i","Math","random","min","key","process","env","NODE_ENV","retryCount","delayAmount","o","n","u","NO_SUPPORTED_FEATURES","loadFromURL","interval","timeoutID","supportedFeatures","client","Client","url","fetchOptions","headers","exchanges","NODE_TLS_REJECT_UNAUTHORIZED","fetchExchange","introspect","introspectionResult","scheduleUpdate","setTimeout","_error","supportResult","length","_result","clearTimeout","getURLConfig","origin","URL","undefined","urlOrigin","fetchInterval","rootPath","resolve","loadRef","input","teardowns","_loaders","getLoaders","schemas","loader","push","ref","version","current","multi","reduce","acc","autoupdate","loaders","then","catch","teardown","pop","Promise","all","cwd","maybeRelative","filePath","relative","startsWith","TSError","diagnostic","messageText","fileName","TadaError","SCHEMA_PROPS","parseSchemaConfig","resolveConfigDir","normalize","replace","_match","tadaOutputLocation","tadaTurboLocation","tadaPersistedLocation","output","parseConfig","template","Array","isArray","_loop","prop","values","filter","Boolean","uniqueValues","getSchemaNamesFromConfig","getSchemaConfigForName","index","isFile","stat","isDir","isDirectory","predicate","_resolve","require","bind","createRequire","resolveExtend","extend","from","toTSConfigPath","paths","tsconfigPath","readTSConfigFile","contents","ts","parseConfigFileTextToJson","findTSConfigFile","targetPath","gitPath","parentPath","loadConfig","rootTsconfigPath","tsconfig","pluginConfig","compilerOptions","plugins","getPluginConfig","configPath","dirname","extends","resolveTypeScriptRootDir","nameCompare","objA","objB","mapTypeRef","fromType","ofType","mapEnumValue","isDeprecated","deprecationReason","mapInputField","defaultValue","mapField","sort","mapPossibleType","minifyIntrospectionType","enumValues","inputFields","interfaces","possibleTypes","minifyIntrospectionQuery","TypeError","queryType","mutationType","subscriptionType","types","minifiedTypes","directives","printName","printTypeRef","typeRef","printNamedTypes","printFields","printIntrospectionType","inputField","stringify","printInputFields","preprocessIntrospection","queryName","mutationName","subscriptionName","evaluatedTypes","typeStr","PREAMBLE_IGNORE","join","ANNOTATION_DTS","ANNOTATION_TS","stringifyJson","outputIntrospectionFile","opts","test","fileType","json","shouldPreprocess","out"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA,IAAMA,wBAAyBC;EAC7B,IACEA,KACAA,EAAMC,YACLD,EAAME,cAA6B,mBAAfF,EAAMG;IAE3B,OAAOH;SACF,IAAqB,mBAAVA,KAAsBA,EAAMC;IAC5C,OAAO,IAAIG,EACTJ,EAAMC,SACND,EAAMK,OACNL,EAAMM,QACNN,EAAMO,WACNP,EAAMQ,MACNR,GACAA,EAAME,cAAc,CAAA;;IAGtB,OAAO,IAAIE,EAAaJ;;;;AAkBrB,MAAMS,sBAAsBC;EAwCjCC,WAAAA,CAAYP;IAKV,IAAMJ,KAA2BI,EAAMQ,iBAAiB,IAAIC,IAC1Dd;IAEF,IAAMe,IAnGmB,EAC3BV,GACAJ;MAEA,IAAIc,IAAQ;MACZ,IAAIV;QAAY,OAAQ,aAAYA,EAAWH;;MAC/C,IAAID;QACF,KAAK,IAAMe,KAAOf,GAAa;UAC7B,IAAIc;YAAOA,KAAS;;UACpBA,KAAU,aAAYC,EAAId;AAC5B;;MAEF,OAAOa;AAAK,MAZe,CAoGvBV,EAAMY,cACNhB;IAGFiB,MAAMH;IAENI,KAAKf,OAAO;IACZe,KAAKjB,UAAUa;IACfI,KAAKN,gBAAgBZ;IACrBkB,KAAKF,eAAeZ,EAAMY;IAC1BE,KAAKC,WAAWf,EAAMe;AACxB;EAEAC,QAAAA;IACE,OAAOF,KAAKjB;AACd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3FF,IAAMoB,YAAYA,CAChBC,GACAC,QACcD,OAAUA,EAAKE,UAAUF,EAAKE,OAAOC,MAAMC,KAAUA,EAAMvB,SAASoB;;AAEpF,IAAMI,kCACJL;EAEA,IAAMM,IAAYN,KAAQA,EAAKE,UAAUF,EAAKE,OAAOK,MAAMH,KAAyB,WAAfA,EAAMvB;EAC3E,UACEyB,KACAA,EAAUE,QACVF,EAAUE,KAAKD,MAAME,KAAqB,wBAAbA,EAAI5B;AAClC;;AAII,IAAM6B,sBAAuBV,MAAyD;EAC3FW,uBAAuBZ,UAAUC,EAAKY,WAAW;EACjDC,gBAAgBd,UAAUC,EAAKc,MAAM;EACrCC,uBAAuBhB,UAAUC,EAAKgB,YAAY;EAClDC,gCAAgCZ,gCAAgCL,EAAKY;EACrEM,4BAA4Bb,gCAAgCL,EAAKI;;;AAGnE,IAAIe;;AACJ,IAAIC;;AAEG,IAAMC,yBAA0BC;EACrC,IAAIH,KAAuBC,MAAqBE;IAC9C,OAAOH;;IAEP,OAAQA,IAAsBI,wBAAyBH,IAAmBE;;AAC5E;;AAGF,IAAMC,0BAA2BD,MAA8C;EAC7EE,MAAMC,EAAKC;EACXC,aAAa,EACX;IACEH,MAAMC,EAAKG;IACX/C,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCC,WAAWC,EAAkBC;IAC7BC,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCI,cAAcI,qBAAqBhB;;;KAM3CiB,4BAA4BjB,IAC5BkB,8BAA8BlB,IAC9BmB;;;AAKG,IAAMC,6BAA6BA,OAAqB;EAC7DlB,MAAMC,EAAKC;EACXC,aAAa,EACX;IACEH,MAAMC,EAAKG;IACX/C,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCC,WAAWC,EAAkBC;IAC7BC,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXM,OAAO;UAAEnB,MAAMC,EAAKI;UAAMC,OAAO;;QACjCjD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCc,WAAW,EACT;UACEpB,MAAMC,EAAKoB;UACXhE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;UAChCA,OAAO;YAAEN,MAAMC,EAAKqB;YAAQhB,OAAO;;;QAGvCI,cAAca,yBAAyB;UAAEC,cAAa;;SAExD;QACExB,MAAMC,EAAKY;QACXM,OAAO;UAAEnB,MAAMC,EAAKI;UAAMC,OAAO;;QACjCjD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCc,WAAW,EACT;UACEpB,MAAMC,EAAKoB;UACXhE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;UAChCA,OAAO;YAAEN,MAAMC,EAAKqB;YAAQhB,OAAO;;;QAGvCI,cAAca,yBAAyB;UAAEC,cAAa;;SAExD;QACExB,MAAMC,EAAKY;QACXM,OAAO;UAAEnB,MAAMC,EAAKI;UAAMC,OAAO;;QACjCjD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCc,WAAW,EACT;UACEpB,MAAMC,EAAKoB;UACXhE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;UAChCA,OAAO;YAAEN,MAAMC,EAAKqB;YAAQhB,OAAO;;;QAGvCI,cAAca,yBAAyB;UAAEC,cAAa;;SAExD;QACExB,MAAMC,EAAKY;QACXM,OAAO;UAAEnB,MAAMC,EAAKI;UAAMC,OAAO;;QACjCjD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCc,WAAW,EACT;UACEpB,MAAMC,EAAKoB;UACXhE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;UAChCA,OAAO;YAAEN,MAAMC,EAAKqB;YAAQhB,OAAO;;;QAGvCI,cAAca,yBAAyB;UAAEC,cAAa;;;;;;;AAQlE,IAAMD,2BAA4BE,MAAyD;EACzFzB,MAAMC,EAAKU;EACXC,YAAY,EACV;IACEZ,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;YAE9BmB,EAAQD,cACP,EACC;QACExB,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCI,cAAc;UACZV,MAAMC,EAAKU;UACXC,YAAY,EACV;YACEZ,MAAMC,EAAKY;YACXxD,MAAM;cAAE2C,MAAMC,EAAKI;cAAMC,OAAO;;;;YAM1C;;;;;AAOd,IAAMQ,uBAAwBhB,MAAkD;EAC9EE,MAAMC,EAAKU;EACXC,YAAY,EAEV;IACEZ,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;;;KAMxC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;;;KAMxC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;;;KAMxC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKyB;QACXrE,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;;;KAMxC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAc;MACZV,MAAMC,EAAKU;MACXC,YAAY,EACV;QACEZ,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;SAElC;QACEN,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;SAElC;QACEN,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;SAElCqB,qBAAqB7B,EAAQL,oCACzBK,EAAQX,wBACP,EACC;QACEa,MAAMC,EAAKY;QACXxD,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;YAGpC;;;;;AAOd,IAAMS,8BAA+BjB,MAAwD;EAC3FE,MAAMC,EAAK2B;EACXvE,MAAM;IAAE2C,MAAMC,EAAKI;IAAMC,OAAO;;EAChCuB,eAAe;IAAE7B,MAAMC,EAAK6B;IAAYzE,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;;EACxEI,cAAc;IACZV,MAAMC,EAAKU;IACXC,YAAY,EACV;MACEZ,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;OAElC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;OAElC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;UAE9BR,EAAQT,iBACP,EACC;MACEW,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;UAGpC,IACJ;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;MAChCc,WAAW,EACT;QACEpB,MAAMC,EAAKoB;QACXhE,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCA,OAAO;UAAEN,MAAMC,EAAK8B;UAASzB,QAAO;;;MAGxCI,cAAc;QACZV,MAAMC,EAAKU;QACXC,YAAY,EACV;UACEZ,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElC;UACEN,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElC;UACEN,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElC;UACEN,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElCqB,qBAAqB7B,EAAQJ,6BAC7B;UACEM,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;UAChCI,cAAc;YACZV,MAAMC,EAAKU;YACXC,YAAY,EACV;cACEZ,MAAMC,EAAKyB;cACXrE,MAAM;gBAAE2C,MAAMC,EAAKI;gBAAMC,OAAO;;;;;;OAQ9C;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;MAChCI,cAAc;QACZV,MAAMC,EAAKU;QACXC,YAAY,EACV;UACEZ,MAAMC,EAAKyB;UACXrE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;;;OAKxC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;MAChCI,cAAc;QACZV,MAAMC,EAAKU;QACXC,YAAY,EACV;UACEZ,MAAMC,EAAKyB;UACXrE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;;;OAKxC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;MAChCc,WAAWtB,EAAQP,wBACf,EACE;QACES,MAAMC,EAAKoB;QACXhE,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCA,OAAO;UAAEN,MAAMC,EAAK8B;UAASzB,QAAO;;YAGxC;MACJI,cAAc;QACZV,MAAMC,EAAKU;QACXC,YAAY,EACV;UACEZ,MAAMC,EAAKyB;UACXrE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;;;OAKxC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;MAChCc,WAAW,EACT;QACEpB,MAAMC,EAAKoB;QACXhE,MAAM;UAAE2C,MAAMC,EAAKI;UAAMC,OAAO;;QAChCA,OAAO;UAAEN,MAAMC,EAAK8B;UAASzB,QAAO;;;MAGxCI,cAAc;QACZV,MAAMC,EAAKU;QAEXC,YAAY,EACV;UACEZ,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElC;UACEN,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElC;UACEN,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;WAElC;UACEN,MAAMC,EAAKY;UACXxD,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;;;;;;;AAS9C,IAAMqB,uBAAwBK,MAAkD;EAC9EhC,MAAMC,EAAKY;EACXxD,MAAM;IAAE2C,MAAMC,EAAKI;IAAMC,OAAO;;EAChCc,WAAWY,IACP,EACE;IACEhC,MAAMC,EAAKoB;IACXhE,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCA,OAAO;MAAEN,MAAMC,EAAK8B;MAASzB,QAAO;;QAGxC;EACJI,cAAc;IACZV,MAAMC,EAAKU;IACXC,YAAY,EACV;MACEZ,MAAMC,EAAKyB;MACXrE,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;;;;;AAMxC,IAAMU,gCAAiClB,MAAwD;EAC7FE,MAAMC,EAAK2B;EACXvE,MAAM;IAAE2C,MAAMC,EAAKI;IAAMC,OAAO;;EAChCuB,eAAe;IAAE7B,MAAMC,EAAK6B;IAAYzE,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;;EACxEI,cAAc;IACZV,MAAMC,EAAKU;IACXC,YAAY,EACV;MACEZ,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;OAElC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;OAElC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;OAElC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;MAChCI,cAAc;QACZV,MAAMC,EAAKU;QACXC,YAAY,EACV;UACEZ,MAAMC,EAAKyB;UACXrE,MAAM;YAAE2C,MAAMC,EAAKI;YAAMC,OAAO;;;;UAKpCR,EAAQP,wBACP,EACC;MACES,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;OAElC;MACEN,MAAMC,EAAKY;MACXxD,MAAM;QAAE2C,MAAMC,EAAKI;QAAMC,OAAO;;UAGpC;;;;AAKV,IAAMW,uBAAuBA,OAA+B;EAC1DjB,MAAMC,EAAK2B;EACXvE,MAAM;IAAE2C,MAAMC,EAAKI;IAAMC,OAAO;;EAChCuB,eAAe;IAAE7B,MAAMC,EAAK6B;IAAYzE,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;;EACxEI,cAAcuB,sBAAsB;;;AAGtC,IAAMA,wBAAyBC,MAAqC;EAClElC,MAAMC,EAAKU;EACXC,YACEsB,IAAQ,IACJ,EACE;IACElC,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;KAElC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;KAElC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;IAChCI,cAAcuB,sBAAsBC,IAAQ;QAGhD,EACE;IACElC,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;KAElC;IACEN,MAAMC,EAAKY;IACXxD,MAAM;MAAE2C,MAAMC,EAAKI;MAAMC,OAAO;;;;;ACnhB5C,IAAM6B,IAA4C;EAChDhD,wBAAuB;EACvBE,iBAAgB;EAChBE,wBAAuB;EACvBE,iCAAgC;EAChCC,6BAA4B;;;AAGvB,SAAS0C,YAAYC;EAC1B,IAAMC,IAAgB,IAAIC;EAE1B,IAAIC,IAAqC;EACzC,IAAIC,IAAoC;EAExC,IAAMC,OAAOC;IACX,IAAMC,IAAMlF,EAAKmF,QAAQR,EAAOS;IAChC,IAAMtE,UAAauE,EAAGC,SAASX,EAAOS,MAAM;MAAEG,UAAU;;IACxD,IAAY,YAARL,GAAiB;MACnB,IAAMM,IAAgBC,KAAKC,MAAM5E;MACjC,KAAK0E,MAAkBA,EAAcG;QACnC,MAAM,IAAIzF,MACR;;MAIJ,OAAO;QACLsF,eAAe;aACVA;UACH7F,MAAMgF,EAAOhF;;QAEfiG,QAAQC,EAAkBL,GAAe;UAAEM,eAAenB,EAAOmB;;;AAErE,WAAO;MACL,IAAMF,IAASG,EAAYjF,GAAM;QAAEkF,kBAAkBrB,EAAOmB;;MAC5D,IAAMG,IAAQ9D,uBAAuBsC;MACrC,IAAMyB,IAAcC,EAAY;QAAEP;QAAQQ,UAAUH;;MACpD,IAAIC,EAAYG;QACd,MAAM,IAAIpG,cAAc;UAAEG,eAAe8F,EAAYG;;aAChD,IAAIH,EAAYpF,MAAM;QAK3B,OAAO;UAAE0E,eAJa;eAChBU,EAAYpF;YAChBnB,MAAMgF,EAAOhF;;UAESiG;;AAC1B;QACE,MAAM,IAAI1F,MACR;;AAIN;AAAA;EAsBF,OAAO;IACL,QAAIP;MACF,OAAOgF,EAAOhF;AACf;IACDsF,MAAUD,MAACsB,KACFA,MAAWvB,IAAUA,UAAeC,SAAUD;IAEvDwB,cAAAA,CAAeC;MACb,KAAK5B,EAAc6B;QA3BTxB;UACZH,IAAa,IAAI4B;UACjB,IAAMC,IAAUtB,EAAGuB,MAAMjC,EAAOS,MAAM;YACpCyB,QAAQ/B,EAAW+B;YACnBC,aAAY;;UAEd;YACE,WAAW,IAAMC,KAAUJ;cACzB,IAAK5B,UAAeC;gBAClB,KAAK,IAAMgC,KAAcpC;kBAAeoC,EAAWjC;;;;AAGxD,YAAC,OAAOkC;YACP,IAAmB,iBAAfA,EAAMtH;cAAuB,MAAMsH;;AACzC,YAAU;YACRnC,IAAa;AACf;AAAA,UAW2B8B;;MACzBhC,EAAcsC,IAAIV;MAClB,OAAO;QACL5B,EAAcuC,OAAOX;QACrB,KAAK5B,EAAc6B,QAAQ3B;UACzBA,EAAWsC;;AACb;AAEH;IACD,uBAAMC;MACJ,IAAMtC,UAAerE,KAAKsE;MAC1B,OAAOD,KAAUA,EAAOS;AACzB;IACD,gBAAM8B;MACJ,IAAMvC,UAAerE,KAAKsE;MAC1B,OAAOD,KAAUA,EAAOa;AAC1B;;AAEJ;;ACLa,IAAA2B,gBAAiBC;EAC5B,KAAMC,SAAEC,GAAOC,WAAEC,KAAcJ;EAC/B,IAAMK,IAAYL,EAAQM,kBAAkB;EAC5C,IAAMC,IAAYP,EAAQQ,cAAc;EACxC,IAAMC,IAAeT,EAAQU,qBAAqB;EAClD,IAAMC,IACmB,QAAvBX,EAAQY,gBAAwBZ,EAAQY,eAAc;EAExD,OAAO,EAAGC,SAAAb,GAASc,eAAAC,OACjBC;IACE,KAAQ1I,QAAQ2I,GAAQC,MAAMC,KAC5BnJ;IAEF,IAAMoJ,IAEJhJ,UAAUJ;MACR,IAAMI,IAAoBJ,EAAUqJ,QAAQC,SAAS;QACnDC,OAAO;QACPC,OAAO;;MAGT,IAAMC,MAAerJ,EAAMmJ;MAC3B,IAAIvB,IAAc5H,EAAMoJ,SAASnB;MAEjC,IAAMH,IAAgBwB,KAAKC,WAAW;MACtC,IAAIhB;QAGF,IAAIX,IAAcE,IAAgBK;UAChCP,KAAeE;;UAEfF,IAAcO;;;QAIhBP,IAAc0B,KAAKE,IAAIH,IAAapB,GAAWE;;MAIjDnI,EAAMoJ,QAAQxB;MAKd,IAAMI,IAEJtH,QAAOV,MAEU,YAAZA,EAAG0C,QAAgC,eAAZ1C,EAAG0C,SAC3B1C,EAAGyJ,QAAQ7J,EAAU6J,KAHzB/I,CADAkI;MASF,iBAAAc,QAAAC,IAAAC,YAAAjB,EAAc;QACZ3G,MAAM;QACNnC,SAAU,4DAA2DwJ,OAAgBhB;QACrFpF,WAAArD;QACAsB,MAAM;UACJ2I,YAAAR;UACAS,aAAAlC;;QACD1H,QAAA;;MAIH,OASES,UAAUqH,EAAVrH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAFAoJ,EAAS,MAAMnC,GAAfmC,CANAC,UACEC,cAAcrK,EAAU8C,MAAM9C,GAAW;WACpCA,EAAUqJ;QACbC,OAAAlJ;;OAtDRA,CADA6I;IAiEF,OAGEnI,QAAOd;MACL,IAAMI,IAAQJ,EAAIqD,UAAUgG,QAAQC;MAGpC,KACGtJ,EAAIyH,WACJS,IACIA,EAAQlI,EAAIyH,OAAOzH,EAAIqD,aACvB+E,KAAcpI,EAAIyH,MAAMzG,eAC7B;QAEA,IAAIZ,GAAO;UACTA,EAAMmJ,QAAQ;UACdnJ,EAAMoJ,QAAQ;AAChB;QACA,QAAO;AACT;MAIA,OADIpJ,KAASA,EAAMmJ,SAAU,MAAMd,IAAe,IAClB;QAC9B,IAAM3H,IAAYsH,IACdA,EAAUpI,EAAIyH,OAAOzH,EAAIqD,aACzBrD,EAAIqD;QACR,KAAKvC;UAAW,QAAO;;QAIvBqI,EAAmBrI;QACnB,QAAO;AACT;MAEA,iBAAAgJ,QAAAC,IAAAC,YAAAjB,EAAc;QACZ3G,MAAM;QACNnC,SACE;QACFoD,WAAWrD,EAAIqD;QAAS/C,QAAA;;MAG1B,QAAO;AAAA,OAvCTQ,CADAkH,EADAyB,MAAM,EAACT,GAAaI;AAAA;AAAmB;;AC7K/C,IAAMnE,IAA4C;EAChDhD,wBAAuB;EACvBE,iBAAgB;EAChBE,wBAAuB;EACvBE,iCAAgC;EAChCC,6BAA4B;;;AAG9B,IAAM8H,IAA2C;EAC/CrI,wBAAuB;EACvBE,iBAAgB;EAChBE,wBAAuB;EACvBE,iCAAgC;EAChCC,6BAA4B;;;AAGvB,SAAS+H,YAAYpF;EAC1B,IAAMqF,IAAWrF,EAAOqF,YAAY;EACpC,IAAMpF,IAAgB,IAAIC;EAE1B,IAAIoF,IAAmC;EACvC,IAAIC,IAA8C;EAClD,IAAInF,IAAoC;EAExC,IAAMoF,IAAS,IAAIC,EAAO;IACxBC,KAAM,GAAE1F,EAAO0F;IACfC,cAAc;MAAEC,SAAS5F,EAAO4F;;IAChCC,WAAW,EACTjD,cAAc;MACZO,gBAAgB;MAChBE,YAAY;MACZE,mBAAmB;MACnBP,SAAAA,CAAUV,GAAOpE;QACf,IAAIoE,EAAMzG;UAAc8I,QAAQC,IAAIkB,+BAA+B;;QACnE,OAAO5H;AACT;QAEF6H;;EAkBJ,IAAMC,aAAa1F;IACjB,IAAMgB,IAAQ9D,uBAAuBC;IACrC,IAAMwI,UAA4BT,EAAOlE,MAA0BA,GAAO,CAAE;IAC5E;MACE,IAAI2E,EAAoB3D;QACtB,MAAM2D,EAAoB3D;aACrB,IAAI2D,EAAoB9J,MAAM;QACnC,IAAM0E,IAAgBoF,EAAoB9J;QAC1C,OAAO;UACL0E,eAAe;eACVA;YACH7F,MAAMgF,EAAOhF;;UAEfiG,QAAQC,EAAkBL,GAAe;YAAEM,cAAa;;;AAE5D;QACE,MAAM,IAAI5F,MACR;;AAIN,MAAU;MAnCW2K;QACrB,IAAIjG,EAAc6B,SAASwD;UACzBA,IAAYa,YAAW7F;YACrBgF,IAAY;YACZ;cACElF,UAAeC;AAChB,cAAC,OAAO+F;cACPhG,IAAS;AACX;YACA,IAAIA;cAAQ,KAAK,IAAMiC,KAAcpC;gBAAeoC,EAAWjC;;;AAAO,cACrEiF;;AACL,QAyBEa;AACF;AAAA;EAGF,IAAM7F,OAAOC;IACX,KAAKiF,GAAmB;MACtB,IAAMjE,IAAQzC;MACd,IAAMwH,UAAsBb,EAAOlE,MAAkCA,GAAO,CAAE;MAC9E,IAAI+E,EAAc/D,SAAS+D,EAAc/D,MAAM7G,cAAc6K,SAAS,GAAG;QAEvE,IAAMC,UAAgBP,WAAWlG;QACjC,IAAIyG,GAAS;UAEXhB,IAAoBzF;UACpB,OAAOyG;AACT;UAGEhB,IAAoBJ;;AAEvB,aAAM,IAAIkB,EAAclK,SAASkK,EAAc/D;QAE9CiD,IAAoB1I,oBAAoBwJ,EAAclK;aACjD,IAAIkK,EAAc/D,OAAO;QAE9BiD,IAAoB;QACpB,MAAMc,EAAc/D;AACtB;QAEEiD,IAAoBJ;;AAExB;IACA,OAAOa,WAAWT;AAAkB;EAGtC,OAAO;IACL,QAAIvK;MACF,OAAOgF,EAAOhF;AACf;IACDsF,MAAUD,MAACsB,KACFA,MAAWvB,IAAUA,UAAeC,SAAUD;IAEvDwB,cAAAA,CAAeC;MACb5B,EAAcsC,IAAIV;MAClB,OAAO;QACL5B,EAAcuC,OAAOX;QACrB,KAAK5B,EAAc6B,QAAQwD,GAAW;UACpCkB,aAAalB;UACbA,IAAY;AACd;AAAA;AAEH;IACD,uBAAM5C;MACJ,IAAMtC,UAAerE,KAAKsE;MAC1B,OAAOD,KAAUA,EAAOS;AACzB;IACD,gBAAM8B;MACJ,IAAMvC,UAAerE,KAAKsE;MAC1B,OAAOD,KAAUA,EAAOa;AAC1B;;AAEJ;;ACzIawF,IAAAA,eAAgBC;EAC3B;IACE,OAAOA,IACH;MACEhB,KAAK,IAAIiB,IAAsB,mBAAXD,IAAsBA,EAAOhB,MAAMgB;MACvDd,SAA2B,mBAAXc,IAAsBA,EAAOd,eAAUgB;QAEzD;AACL,IAAC,OAAOR;IACP,OAAO;AACT;AAAA;;AAQK,SAAS/F,KAAKL;EACnB,IAAM6G,IAAYJ,aAAazG,EAAO0G;EACtC,IAAIG;IACF,OAAOzB,YAAY;SACdyB;MACHxB,UAAUrF,EAAO8G;MACjB9L,MAAMgF,EAAOhF;;SAEV,IAA6B,mBAAlBgF,EAAO0G,QAAqB;IAG5C,OAAO3G,YAAY;MACjBU,MAHWT,EAAO+G,WAAW1L,EAAK2L,QAAQhH,EAAO+G,UAAU/G,EAAO0G,UAAU1G,EAAO0G;MAInFvF,aAHwC,QAAtBnB,EAAOmB,cAAsBnB,EAAOmB,eAAc;MAIpEnG,MAAMgF,EAAOhF;;AAEjB;IACE,MAAM,IAAIO,MAAO;;AAErB;;AAEO,SAAS0L,QACdC;EAEA,IAAMC,IAA4B;EAElC,IAAIC;EACJ,IAAMC,aAAcrH;IAClB,KAAKoH,GAAU;MACbA,KAAa,aAAaF,KAASA,EAAMI,WAAY,IAAI5L,KAAKwL,MAAW;QACvEA;QACAK,QAAQlH,KAAK;aAAKL;UAAQ0G,QAAQQ,EAAMjG;UAAQjG,MAAMkM,EAAMlM;;;MAE9D,IAAI,YAAYkM,KAASA,EAAMjG;QAC7BmG,EAASI,KAAK;UACZN,OAAO;eAAKA;YAAOlM,WAAM4L;;UACzBW,QAAQlH,KAAK;eAAKL;YAAQ0G,QAAQQ,EAAMjG;;;;AAG9C;IACA,OAAOmG;AAAQ;EAGjB,IAAMK,IAAiB;IACrBC,SAAS;IACTC,SAAS;IAETC,QAAS,aAAaV,KAASA,EAAMI,WAAY,IAAIO,QAAO,CAACC,IAAO9M;MAClE,IAAIA;QAAM8M,EAAI9M,KAAQ;;MACtB,OAAO8M;AAAG,QACT;IAEHC,UAAAA,CAAW/H,GAAwB6B;MACjC,IAAMmG,IAAUX,WAAWrH;MAC3BmH,EAAUK,QACLQ,EAAQtM,KAAI,EAAGwL,UAAOK;QACvBA,EACGlH,OACA4H,MAAM7H;UACLqH,EAAIC;UACJ,IAAIR,EAAMlM;YACRyM,EAAIG,MAAMV,EAAMlM,QAAQ;iBAAKkM;iBAAU9G;;;YAEvCqH,EAAIE,UAAU;iBAAKT;iBAAU9G;;;AAC/B,YAED8H,OAAO9B;QAGV,OAAOmB,EAAO3F,gBAAgBxB;UAC5BqH,EAAIC;UACJ,IAAIR,EAAMlM;YACRyM,EAAIG,MAAMV,EAAMlM,QAAQ;iBAAKkM;iBAAU9G;;;YAEvCqH,EAAIE,UAAU;iBAAKT;iBAAU9G;;;UAE/ByB,EAAS4F,GAAKP;AAAM;AACpB;MAGN,OAAO;QACL,IAAIiB;QACJ,OAAuC,SAA/BA,IAAWhB,EAAUiB;UAAgBD;;AAAU;AAE1D;IACD,UAAM9H,CAAKL;MACT,IAAMgI,IAAUX,WAAWrH;YACrBqI,QAAQC,IACZN,EAAQtM,KAAI4E,QAAS4G,UAAOK;QAC1B,IAAMnH,UAAemH,EAAOlH;QAC5BoH,EAAIC;QACJ,IAAIR,EAAMlM;UACRyM,EAAIG,MAAMV,EAAMlM,QAAQ;eAAKkM;eAAU9G;;;UAEvCqH,EAAIE,UAAU;eAAKT;eAAU9G;;;AAC/B;MAGJ,OAAOqH;AACT;;EAGF,OAAOA;AACT;;ACzIO,IAAMc,IAAM5D,QAAQ4D;;AAEpB,IAAMC,gBAAiBC;EAC5B,IAAMC,IAAWrN,EAAKqN,SAASH,GAAKE;EACpC,QAAQC,EAASC,WAAW,QAAQD,IAAWD;AAAQ;;ACHlD,MAAMG,gBAAgBrN;EAG3BC,WAAAA,CAAYqN;IACV,IAAI/N,IACgC,mBAA3B+N,EAAWC,cACdD,EAAWC,YAAYA,cACvBD,EAAWC;IACjB,IAAID,EAAWpI;MAAM3F,KAAY,KAAI0N,cAAcK,EAAWpI,KAAKsI;;IACnEjN,MAAMhB;IACNiB,KAAKf,OAAO;IACZe,KAAK8M,aAAaA;AACpB;;;AAGK,MAAMG,kBAAkBzN;EAE7BC,WAAAA,CAAYV;IACVgB,MAAMhB;IACNiB,KAAKf,OAAO;AACd;;;ACNF,IAAMiO,IAAe,EACnB,QACA,sBACA,qBACA;;AASF,IAAMC,oBAAoBA,CAAChC,GAAgBH;EACzC,IAAMoC,mBAAoBjC;IACxB,KAAKA;MAAO,OAAOA;;IACnB,OAAO7L,EAAK+N,UACVlC,EAAMmC,QAAQ,gBAAe,CAACC,GAAQtO;MACpC,IAAa,gBAATA;QACF,OAAO+L;;QAEP,MAAM,IAAIiC,UACP,oBAAmBhO;;AAExB;AAEH;EAGH,IAAa,QAATkM,KAAkC,mBAAVA;IAC1B,MAAM,IAAI8B,UAAW,gDAA+C9B;;EAGtE,IAAI,YAAYA,KAASA,EAAMjG,UAAkC,mBAAjBiG,EAAMjG,QAAqB;IACzE,KAAQA,QAAAA,KAAWiG;IACnB,MAAM,SAASjG;MACb,MAAM,IAAI+H,UAAU;;IAGtB,IAAI,aAAa/H,KAAUA,EAAO2E,WAAqC,mBAAnB3E,EAAO2E;MACzD,KAAK,IAAMlB,KAAOzD,EAAO2E;QACvB,IAAI3E,EAAO2E,QAAQlB,MAAuC,mBAAxBzD,EAAO2E,QAAQlB;UAC/C,MAAM,IAAIsE,UACR,oEAAoEtE;;;WAIrE,IAAI,aAAazD;MACtB,MAAM,IAAI+H,UAAU;;AAExB;EAEA,MAAM,YAAY9B,MAAkC,mBAAjBA,EAAMjG;IACvC,MAAM,IAAI+H,UAAU;SACf,IACL,wBAAwB9B,KACxBA,EAAMqC,sBAC8B,mBAA7BrC,EAAMqC;IAEb,MAAM,IAAIP,UACR;SAEG,IACL,uBAAuB9B,KACvBA,EAAMsC,qBAC6B,mBAA5BtC,EAAMsC;IAEb,MAAM,IAAIR,UAAU;SACf,IACL,2BAA2B9B,KAC3BA,EAAMuC,yBACiC,mBAAhCvC,EAAMuC;IAEb,MAAM,IAAIT,UACR;;EAIJ,IAAMU,IAASxC;EAEf,IAAIjG,IAAuByI,EAAOzI;EAClC,IAAsB,mBAAXA,GAAqB;IAE9B,KADYwF,aAAaxF;MACfA,IAASkI,iBAAiBlI,MAAWA;;AACjD;EAEA,OAAO;OACFyI;IACHzI;IACAsI,oBAAoBJ,iBAAiBO,EAAOH;IAC5CC,mBAAmBL,iBAAiBO,EAAOF;IAC3CC,uBAAuBN,iBAAiBO,EAAOD;;AAChD;;AAGUE,IAAAA,cAAcA,CACzBzC,GAOAH,IAAmBpC,QAAQ4D;EAE3B,IAAa,QAATrB,KAAkC,mBAAVA;IAC1B,MAAM,IAAI8B,UAAW,kDAAiD9B;SACjE,IAAI,cAAcA,KAASA,EAAM0C,YAAsC,mBAAnB1C,EAAM0C;IAC/D,MAAM,IAAIZ,UAAU;SACf,IAAI,UAAU9B,KAASA,EAAMlM,QAA8B,mBAAfkM,EAAMlM;IACvD,MAAM,IAAIgO,UAAU;;EAGtB,IAAI,aAAa9B,GAAO;IACtB,KAAK2C,MAAMC,QAAQ5C,EAAMI;MACvB,MAAM,IAAI0B,UAAU;;IAGtB,IAAI,YAAY9B;MACd,MAAM,IAAI8B,UACR;WAEG,IAAI,wBAAwB9B;MACjC,MAAM,IAAI8B,UACR;WAEG,IAAI,uBAAuB9B;MAChC,MAAM,IAAI8B,UACR;WAEG,IAAI,2BAA2B9B;MACpC,MAAM,IAAI8B,UACR;;IAIJ,IAAM1B,IAAUJ,EAAMI,QAAQ5L,KAAKuF;MACjC,MAAM,UAAUA,OAAYA,EAAOjG,QAA+B,mBAAhBiG,EAAOjG;QACvD,MAAM,IAAIgO,UAAU;;MACtB,MACI,wBAAwB/H,OACzBA,EAAOsI,sBAC6B,mBAA9BtI,EAAOsI;QAEd,MAAM,IAAIP,UACR;;MAEJ,OAAO;WACFE,kBAAkBjI,GAAQ8F;QAC7B/L,MAAMiG,EAAOjG;;AACd;IACA,IAAA+O,QAAA,SAAAC;MAGD,IAAMC,IAAS3C,EAAQ5L,KAAKuF,KAAWA,EAAO+I,KAAOE,OAAOC;MAC5D,IAAMC,IAAe,IAAIlK,IAAI+J;MAC7B,IAAIA,EAAO3D,WAAW8D,EAAatI;QACjC,MAAM,IAAIkH,UAAW,QAAOgB;;;IAJhC,KAAK,IAAMA,KAAQf;MAAYc,MAAAC;;IAO/B,OAAO;SAAK9C;MAAOI;;AACrB;IACE,OAAO;SAAKJ;SAAUgC,kBAAkBhC,GAAOH;;;AACjD;;AAGWsD,IAAAA,2BAA4BrK,KAChC,IAAIE,IAAmB,KACxB,YAAYF,IAAS,EAAC,SAAQ,OAC9B,aAAaA,IAASA,EAAOsH,QAAQ5L,KAAKwL,KAAUA,EAAMlM,SAAQ;;IAI7DsP,yBAAyBA,CACpCtK,GACAhF;EAEA,IAAIA,KAAQ,UAAUgF,KAAUA,EAAOhF,SAASA;IAC9C,OAAOgF;SACF,KAAKhF,OAAU,aAAagF;IACjC,OAAOA;SACF,IAAIhF,KAAQ,aAAagF,GAAQ;IACtC,KAAK,IAAIuK,IAAQ,GAAGA,IAAQvK,EAAOsH,QAAQhB,QAAQiE;MACjD,IAAIvK,EAAOsH,QAAQiD,GAAOvP,SAASA;QAAM,OAAOgF,EAAOsH,QAAQiD;;;IACjE,OAAO;AACT;IACE,OAAO;;AACT;;AChMF,IAAMC,SAAUC,KAAyBA,EAAKD;;AAC9C,IAAME,QAASD,KAAyBA,EAAKE;;AAC7C,IAAMF,OAAOA,CAAChK,GAAcmK,IAAYJ,WACtC9J,EACG+J,KAAKhK,GACLwH,KAAK2C,GACL1C,OAAM,OAAM;;AAEjB,IAAM2C,IACe,sBAAZC,UACHA,QAAQ9D,QAAQ+D,KAAKD,WACrBE,cAA0BtF,KAAKsB;;AACrC,IAAMiE,gBAAgB3K,OAAO4K,GAAgBC;EAC3C;IACE,OAAOC,eAAeP,EAASK,GAAQ;MAAEG,OAAO,EAACF;;AAClD,IAAC,OAAO/E;IACP,OAAO;AACT;AAAA;;AAGF,IAAMgF,iBAAkBE,KACS,YAA/BjQ,EAAKmF,QAAQ8K,KACTjQ,EAAK2L,QAAQuB,GAAK+C,GAxBP,mBAyBXjQ,EAAK2L,QAAQuB,GAAK+C;;AAEXC,IAAAA,mBAAmBjL;EAC9B,IAAMgL,IAAeF,eAAe3C;EACpC,IAAM+C,UAAiB9K,EAAGC,SAAS2K,GAAc;EACjD,IAAMlL,IAASqL,EAAGC,0BAA0BJ,GAAcE;EAC1D,IAAIpL,EAAOkC;IAAO,MAAM,IAAIsG,QAAQxI,EAAOkC;;EAC3C,OAAOlC,EAAOJ,UAAU;AAAE;;AAGf2L,IAAAA,mBAAmBrL;EAC9B,IAAIgL,IAAeF,eAAeQ,KAAcrD;EAChD,IAAMxB,IAAWqE,eAAe/P,EAAK2L,QAAQsE,GAAc;EAC3D,OAAOA,MAAiBvE,GAAU;IAChC,UAAU0D,KAAKa;MAAe,OAAOA;;IACrC,IAAMO,IAAUxQ,EAAK2L,QAAQsE,GAAc,MAAM;IACjD,UAAUb,KAAKoB,GAASnB;MAAQ,OAAO;;IACvC,IAAMoB,IAAaV,eAAe/P,EAAK2L,QAAQsE,GAAc,MAAM;IACnE,IAAIQ,MAAeR;MAAc;;IACjCA,IAAeQ;AACjB;EACA,OAAO;AAAI;;AAkBAC,IAAAA,aAAazL;EACxB,IAAM0L,UAAyBL,iBAAiBC;EAChD,KAAKI;IACH,MAAM,IAAIhD,UACR4C,IACK,uCAAsCpD,cAAcoD,OACrD;;EAIR,IAAMvL,OAAOC;IACX,IAAM2L,UAAiBV,iBAAiBK;IACxC,IAAMM,IA3BeD,MACtBA,KACCA,EAASE,mBACTF,EAASE,gBAAgBC,WACzBH,EAASE,gBAAgBC,QAAQ1P,MAC9BsH,KAAiB,wBAAXA,EAAEhJ,QAA2C,mBAAXgJ,EAAEhJ,UAE/C,KAoBuBqR,CAAgBJ;IAErC,IAAIC;MACF,OAAO;QACLA;QACAI,YAAYV;QACZ7E,UAAU1L,EAAKkR,QAAQP;;;IAI3B,IAAInC,MAAMC,QAAQmC,EAASO;MACzB,KAAK,IAAItB,KAAUe,EAASO,SAAS;QACnC,IAA6B,YAAzBnR,EAAKmF,QAAQ0K;UAAqBA,KAAU;;QAChD;UACE,IAAMI,UAAqBL,cAAcC,GAAQ7P,EAAKkR,QAAQP;UAC9D,IAAIV;YAAc,OAAOjL,KAAKiL;;AAChC,UAAE,OAAOlF,IAAS;AACpB;WACK,IAAI6F,EAASO;MAClB;QACE,IAAMlB,UAAqBL,cAAcgB,EAASO,SAASnR,EAAKkR,QAAQP;QACxE,IAAIV;UAAc,OAAOjL,KAAKiL;;AAChC,QAAE,OAAOlF,IAAS;;IAGpB,MAAM,IAAI4C,UACP,qDAAoDR,cAAcwD;AACpE;EAGH,aAAa3L,KAAK2L;AAAiB;;AAIxBS,IAAAA,2BAA2BnM;EAGtC;IACE,IAAMF,UAAe2L,WAAWT;IAChC,OAAOjQ,EAAKkR,QAAQnM,EAAOkM;AAC5B,IAAC,OAAOlG;IACP;AACF;AAAA;;AClHF,SAASsG,YAAYC,GAAwBC;EAC3C,OAAOD,EAAK3R,OAAO4R,EAAK5R,QAAQ,IAAI2R,EAAK3R,OAAO4R,EAAK5R,OAAO,IAAI;AAClE;;AAOA,SAAS6R,WAAWC;EAClB,QAAQA,EAASnP;GACf,KAAK;GAKL,KAAK;IACH,OAAO;MACLA,MAAMmP,EAASnP;MACfoP,QAAQF,WAAWC,EAASC;;;GAEhC,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;IACH,OAAO;MACLpP,MAAMmP,EAASnP;MACf3C,MAAM8R,EAAS9R;;;AAGvB;;AAEA,SAASgS,aAAa/O;EACpB,OAAO;IACLjD,MAAMiD,EAAMjD;IACZiS,gBAAgBhP,EAAMgP;IACtBC,wBAAmBtG;;AAEvB;;AAEA,SAASuG,cAAclP;EACrB,OAAO;IACLjD,MAAMiD,EAAMjD;IACZiC,MAAM4P,WAAW5O,EAAMhB;IACvBmQ,cAAcnP,EAAMmP,qBAAgBxG;;AAExC;;AAEA,SAASyG,SAAS9Q;EAChB,OAAO;IACLvB,MAAMuB,EAAMvB;IACZiC,MAAM4P,WAAWtQ,EAAMU;IACvBN,MAAMJ,EAAMI,OAAOJ,EAAMI,KAAKjB,IAAIyR,eAAeG,KAAKZ,eAAe;IACrEO,gBAAgB1Q,EAAM0Q;IACtBC,wBAAmBtG;;AAEvB;;AAEA,SAAS2G,gBAAqD9F;EAC5D,OAAO;IACL9J,MAAM8J,EAAI9J;IACV3C,MAAMyM,EAAIzM;;AAEd;;AAEA,SAASwS,wBAAwBvQ;EAC/B,QAAQA,EAAKU;GACX,KAAK;IACH,OAAO;MACLA,MAAM;MACN3C,MAAMiC,EAAKjC;;;GAGf,KAAK;IACH,OAAO;MACL2C,MAAM;MACN3C,MAAMiC,EAAKjC;MACXyS,YAAYxQ,EAAKwQ,WAAW/R,IAAIsR;;;GAGpC,KAAK;IACH,OAAO;MACLrP,MAAM;MACN3C,MAAMiC,EAAKjC;MACX0S,aAAazQ,EAAKyQ,YAAYhS,IAAIyR;;;GAItC,KAAK;IACH,OAAO;MACLxP,MAAM;MACN3C,MAAMiC,EAAKjC;MACXqB,QAAQY,EAAKZ,SAASY,EAAKZ,OAAOX,IAAI2R,UAAUC,KAAKZ,eAAe;MACpEiB,YAAY1Q,EAAK0Q,aAAa1Q,EAAK0Q,WAAWjS,IAAI6R,iBAAiBD,KAAKZ,eAAe;;;GAG3F,KAAK;IACH,OAAO;MACL/O,MAAM;MACN3C,MAAMiC,EAAKjC;MACXqB,QAAQY,EAAKZ,SAASY,EAAKZ,OAAOX,IAAI2R,UAAUC,KAAKZ,eAAe;MACpEiB,YAAY1Q,EAAK0Q,aAAa1Q,EAAK0Q,WAAWjS,IAAI6R,iBAAiBD,KAAKZ,eAAe;MACvFkB,eAAe3Q,EAAK2Q,gBAChB3Q,EAAK2Q,cAAclS,IAAI6R,iBAAiBD,KAAKZ,eAC7C;;;GAGR,KAAK;IACH,OAAO;MACL/O,MAAM;MACN3C,MAAMiC,EAAKjC;MACX4S,eAAe3Q,EAAK2Q,gBAChB3Q,EAAK2Q,cAAclS,IAAI6R,iBAAiBD,KAAKZ,eAC7C;;;AAGZ;;AAqBamB,IAAAA,2BACX5M;EAEA,KAAKA,OAAY,cAAcA;IAC7B,MAAM,IAAI6M,UAAU;;EAGtB,KACE9M,WAAU+M,WAAEA,GAASC,cAAEA,GAAYC,kBAAEA,GAAgBC,OAAEA,MACrDjN;EAEJ,IAAMkN,IAAgBD,EACnBhE,QAAQjN;IACP,QAAQA,EAAKjC;KACX,KAAK;KACL,KAAK;KACL,KAAK;KACL,KAAK;KACL,KAAK;KACL,KAAK;KACL,KAAK;KACL,KAAK;MACH,QAAO;;KACT;MACE,OACgB,aAAdiC,EAAKU,QACS,WAAdV,EAAKU,QACS,mBAAdV,EAAKU,QACS,aAAdV,EAAKU,QACS,gBAAdV,EAAKU,QACS,YAAdV,EAAKU;;AAEX,MAEDjC,IAAI8R,yBACJF,KAAKZ;EAER,OAAO;IACL1R,MAAM,UAAUiG,IAASA,EAAOjG,YAAO4L;IACvC5F,UAAU;MACR+M,WAAW;QACTpQ,MAAMoQ,EAAUpQ;QAChB3C,MAAM+S,EAAU/S;;MAElBgT,cAAcA,IACV;QACErQ,MAAMqQ,EAAarQ;QACnB3C,MAAMgT,EAAahT;UAErB;MACJiT,kBAAkBA,IACd;QACEtQ,MAAMsQ,EAAiBtQ;QACvB3C,MAAMiT,EAAiBjT;UAEzB;MACJkT,OAAOC;MACPC,YAAY;;;AAEf;;ACxMH,IAAMC,YAAanH,KAA8CA,IAAS,IAAGA,OAAW;;AAExF,IAAMoH,eAAgBC;EACpB,IAAqB,eAAjBA,EAAQ5Q;IACV,OAAQ,4CAA2C2Q,aAAaC,EAAQxB;SACnE,IAAqB,WAAjBwB,EAAQ5Q;IACjB,OAAQ,wCAAuC2Q,aAAaC,EAAQxB;;IAEpE,OAAQ,WAAUsB,UAAUE,EAAQ5Q,gBAAgB0Q,UAAUE,EAAQvT;;AACxE;;AAeF,IAAMwT,kBACJvE;EAEA,KAAKA,EAAO3D;IAAQ,OAAO;;EAC3B,IAAIoD,IAAS;EACb,KAAK,IAAMzL,KAASgM,GAAQ;IAC1B,IAAIP;MAAQA,KAAU;;IACtBA,KAAU2E,UAAUpQ,EAAMjD;AAC5B;EACA,OAAO0O;AAAM;;AAGf,IAAM+E,cAAepS;EACnB,IAAIqN,IAAS;EACb,KAAK,IAAMnN,KAASF,GAAQ;IAC1B,IAAMrB,IAAOqT,UAAU9R,EAAMvB;IAC7B,IAAMiC,IAAOqR,aAAa/R,EAAMU;IAChCyM,KAAW,GAAE2E,UAAU9R,EAAMvB,kBAAkBA,YAAeiC;AAChE;EACA,OAAQ,KAAIyM;AAAS;;AAGhB,IAAMgF,yBAA0BzR;EACrC,IAAkB,WAAdA,EAAKU,MAAiB;IACxB,IAAMsM,IAASuE,gBAAgBvR,EAAKwQ;IACpC,OAAQ,WAAUY,UAAUpR,EAAKjC,sBAAsBiP;AACzD,SAAO,IAAkB,mBAAdhN,EAAKU,MAAyB;IACvC,IAAMtB,IAvCgBqR;MACxB,IAAIhE,IAAS;MACb,KAAK,IAAMiF,KAAcjB,GAAa;QACpC,IAAIhE;UAAQA,KAAU;;QAItBA,KAAW,WAHE2E,UAAUM,EAAW3T,gBACrBsT,aAAaK,EAAW1R,wBAChB0R,EAAWvB,eAAetM,KAAK8N,UAAUD,EAAWvB,gBAAgB;AAE3F;MACA,OAAQ,IAAG1D;AAAS,MA8BHmF,CAAiB5R,EAAKyQ;IACrC,OAAQ,iCAAgCW,UAAUpR,EAAKjC,uBAAuBqB;AAChF,SAAO,IAAkB,aAAdY,EAAKU,MAAmB;IACjC,IAAMtB,IAASoS,YAAYxR,EAAKZ;IAChC,OAAQ,2BAA0BgS,UAAUpR,EAAKjC,kBAAkBqB;AACrE,SAAO,IAAkB,gBAAdY,EAAKU,MAAsB;IAIpC,OAAQ,8BAHK0Q,UAAUpR,EAAKjC,kBACbyT,YAAYxR,EAAKZ,2BACVmS,gBAAgBvR,EAAK2Q;AAE7C,SAAO,IAAkB,YAAd3Q,EAAKU,MAAkB;IAGhC,OAAQ,0BAFK0Q,UAAUpR,EAAKjC,qCACNwT,gBAAgBvR,EAAK2Q;AAE7C;IACE,OAAO;;AACT;;AAGK,SAASkB,wBACdjO;EAEA,KAAQG,UAAUC,KAAWJ;EAC7B,IAAM7F,IAAO,UAAU6F,IAAgBA,EAAc7F,YAAO4L;EAC5D,IAAMmI,IAAYV,UAAUpN,EAAO8M,UAAU/S;EAC7C,IAAMgU,IAAeX,UAAUpN,EAAO+M,gBAAgB/M,EAAO+M,aAAahT;EAC1E,IAAMiU,IAAmBZ,UAAUpN,EAAOgN,oBAAoBhN,EAAOgN,iBAAiBjT;EAEtF,IAAIkU,IAAiB;EACrB,KAAK,IAAMjS,KAAQgE,EAAOiN,OAAO;IAC/B,IAAMiB,IAAUT,uBAAuBzR;IACvC,IAAIiS;MAAgBA,KAAkB;;IACtCA,KAAmB,OAAMb,UAAUpR,EAAKjC,UAAUmU;AACpD;EAEA,OAEG,cAAUd,UAAUrT,iBACT+T,mBACGC,uBACIC,mBACJC;AAEnB;;AC1GA,IAAME,IAAkB,EAAC,wBAAwB,0BAAyBC,KAAK,QAAQ;;AAEvF,IAAMC,IAAiB,EACrB,4DACA,MACA,eACA,4EACA,gGACA,8FACA,qDACA,QACAD,KAAK;;AAEP,IAAME,IAAgB,EACpB,4DACA,MACA,eACA,4EACA,6EACA,+DACA,MACA,eACA,UACA,kDACA,4DACA,MACA,+CACA,6CACA,mBACA,4BACA,qBACA,WACA,YACA,UACA,QACAF,KAAK;;AC5BP,IAAMG,gBAAiBtI,KACJ,mBAAVA,IAAqBA,IAAQpG,KAAK8N,UAAU1H,GAAO,MAAM;;AAO3D,SAASuI,wBACd5O,GACA6O;EAEA,IAAI,WAAWC,KAAKD,EAAKE,WAAW;IAClC,IAAMC,IACqB,mBAAlBhP,KAA8B6O,EAAKI,mBACtChB,wBAAwBjO,KACxB2O,cAAc3O;IACpB,IAAMkP,IAAM,EACVX,GACAE,GACC,+BAA8BO,QAC/B;IAKF,MAAM,UAAUhP,OAAmBA,EAAc7F;MAC/C+U,EAAIvI,KACF,+BACA,6BACA,oCACA,OACA;;IAGJ,OAAOuI,EAAIV,KAAK;AACjB,SAAM,IAAI,QAAQM,KAAKD,EAAKE,WAAW;IACtC,IAAMC,IAAOL,cAAc3O;IAC3B,OAAO,EACLuO,GACAG,GACC,yBAAwBM,iBACzB,8BACAR,KAAK;AACT;EAEA,MAAM,IAAIrG,UACP,0CAAyC0G,EAAKE;AAEnD;;","x_google_ignoreList":[0,3]}