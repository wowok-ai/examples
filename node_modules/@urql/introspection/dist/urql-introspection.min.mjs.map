{"version":3,"file":"urql-introspection.min.mjs","sources":["../src/getIntrospectedSchema.ts","../src/minifyIntrospectionQuery.ts"],"sourcesContent":["import type { IntrospectionQuery, GraphQLSchema } from 'graphql';\nimport { parse, buildSchema, execute, getIntrospectionQuery } from 'graphql';\n\n/** Returns an {@link IntrospectionQuery} result for a given GraphQL schema.\n *\n * @param input - A GraphQL schema, either as an SDL string, or a {@link GraphQLSchema} object.\n * @returns an {@link IntrospectionQuery} result.\n *\n * @remarks\n * `getIntrospectedSchema` can be used to get a Schema Introspection result from\n * a given GraphQL schema. The schema can be passed as an SDL string or a\n * {@link GraphQLSchema} object. If an {@link IntrospectionQuery} object is\n * passed, it'll be passed through.\n *\n * @throws\n * If `input` cannot be parsed or converted into a {@link GraphQLSchema} then\n * a {@link TypeError} will be thrown.\n */\nexport const getIntrospectedSchema = (\n  input: string | IntrospectionQuery | GraphQLSchema\n): IntrospectionQuery => {\n  if (typeof input === 'string') {\n    try {\n      input = JSON.parse(input);\n    } catch (_error) {\n      input = buildSchema(input as string);\n    }\n  }\n\n  if (typeof input === 'object' && '__schema' in input) {\n    return input;\n  }\n\n  const initialIntrospection: any = execute({\n    document: parse(getIntrospectionQuery({ descriptions: false })),\n    schema: input as GraphQLSchema,\n  });\n\n  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {\n    throw new TypeError(\n      'GraphQL could not generate an IntrospectionQuery from the given schema.'\n    );\n  }\n\n  return initialIntrospection.data as IntrospectionQuery;\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n  IntrospectionDirective,\n} from 'graphql';\n\nlet _includeScalars = false;\nlet _includeEnums = false;\nlet _includeInputs = false;\nlet _hasAnyType = false;\n\nconst anyType: IntrospectionTypeRef = {\n  kind: 'SCALAR',\n  name: 'Any',\n};\n\nconst mapType = (fromType: any): IntrospectionTypeRef => {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapType(fromType.ofType),\n      };\n\n    case 'SCALAR':\n      if (_includeScalars) {\n        return fromType;\n      } else {\n        _hasAnyType = true;\n        return anyType;\n      }\n\n    case 'INPUT_OBJECT':\n      if (_includeInputs) {\n        return fromType;\n      } else {\n        _hasAnyType = true;\n        return anyType;\n      }\n\n    case 'ENUM':\n      if (_includeEnums) {\n        return fromType;\n      } else {\n        _hasAnyType = true;\n        return anyType;\n      }\n\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return fromType;\n\n    default:\n      throw new TypeError(\n        `Unrecognized type reference of type: ${(fromType as any).kind}.`\n      );\n  }\n};\n\nconst minifyIntrospectionType = (\n  type: IntrospectionType\n): IntrospectionType => {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(\n          value =>\n            ({\n              name: value.name,\n            }) as any\n        ),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(\n          field =>\n            ({\n              name: field.name,\n              type: mapType(field.type),\n              defaultValue: field.defaultValue || undefined,\n            }) as IntrospectionInputValue\n        ),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            }) as any\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            }) as any\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n        possibleTypes:\n          type.possibleTypes &&\n          type.possibleTypes.map(type => ({\n            kind: type.kind,\n            name: type.name,\n          })),\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes.map(type => ({\n          kind: type.kind,\n          name: type.name,\n        })),\n      };\n\n    default:\n      return type;\n  }\n};\n\n/** Input parameters for the {@link minifyIntrospectionQuery} function. */\nexport interface MinifySchemaOptions {\n  /** Includes scalars instead of removing them.\n   *\n   * @remarks\n   * By default, all scalars will be replaced by a single scalar called `Any`\n   * in the output, unless this option is set to `true`.\n   */\n  includeScalars?: boolean;\n  /** Includes enums instead of removing them.\n   *\n   * @remarks\n   * By default, all enums will be replaced by a single scalar called `Any`\n   * in the output, unless this option is set to `true`.\n   */\n  includeEnums?: boolean;\n  /** Includes inputs instead of removing them.\n   *\n   * @remarks\n   * By default, all inputs will be replaced by a single scalar called `Any`\n   * in the output, unless this option is set to `true`.\n   */\n  includeInputs?: boolean;\n  /** Includes directives instead of removing them. */\n  includeDirectives?: boolean;\n}\n\n/** Minifies an {@link IntrospectionQuery} for use with Graphcache or the `populateExchange`.\n *\n * @param schema - An {@link IntrospectionQuery} object to be minified.\n * @param opts - An optional {@link MinifySchemaOptions} configuration object.\n * @returns the minified {@link IntrospectionQuery} object.\n *\n * @remarks\n * `minifyIntrospectionQuery` reduces the size of an {@link IntrospectionQuery} by\n * removing data and information that a client-side consumer, like Graphcache or the\n * `populateExchange`, may not require.\n *\n * At the very least, it will remove system types, descriptions, depreactions,\n * and source locations. Unless disabled via the options passed, it will also\n * by default remove all scalars, enums, inputs, and directives.\n *\n * @throws\n * If `schema` receives an object that isnâ€™t an {@link IntrospectionQuery}, a\n * {@link TypeError} will be thrown.\n */\nexport const minifyIntrospectionQuery = (\n  schema: IntrospectionQuery,\n  opts: MinifySchemaOptions = {}\n): IntrospectionQuery => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  _hasAnyType = false;\n  _includeScalars = !!opts.includeScalars;\n  _includeEnums = !!opts.includeEnums;\n  _includeInputs = !!opts.includeInputs;\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types, directives },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter(type => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            (_includeScalars && type.kind === 'SCALAR') ||\n            (_includeEnums && type.kind === 'ENUM') ||\n            (_includeInputs && type.kind === 'INPUT_OBJECT') ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType);\n\n  if (_hasAnyType) {\n    minifiedTypes.push({ kind: 'SCALAR', name: anyType.name });\n  }\n\n  let minifiedDirectives: IntrospectionDirective[] = [];\n  if (opts.includeDirectives) {\n    minifiedDirectives = (directives || []).map(directive => ({\n      name: directive.name,\n      isRepeatable: directive.isRepeatable ? true : undefined,\n      locations: directive.locations,\n      args: directive.args.map(\n        arg =>\n          ({\n            name: arg.name,\n            type: mapType(arg.type),\n            defaultValue: arg.defaultValue || undefined,\n          }) as IntrospectionInputValue\n      ),\n    }));\n  }\n\n  return {\n    __schema: {\n      queryType,\n      mutationType,\n      subscriptionType,\n      types: minifiedTypes,\n      directives: minifiedDirectives,\n    },\n  };\n};\n"],"names":["getIntrospectedSchema","input","JSON","parse","_error","buildSchema","initialIntrospection","execute","document","getIntrospectionQuery","descriptions","schema","data","__schema","TypeError","_includeScalars","_includeEnums","_includeInputs","_hasAnyType","anyType","kind","name","mapType","fromType","ofType","minifyIntrospectionType","type","enumValues","map","value","inputFields","field","defaultValue","undefined","fields","args","arg","interfaces","int","possibleTypes","minifyIntrospectionQuery","opts","includeScalars","includeEnums","includeInputs","queryType","mutationType","subscriptionType","types","directives","minifiedTypes","filter","push","minifiedDirectives","includeDirectives","directive","isRepeatable","locations"],"mappings":"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"}