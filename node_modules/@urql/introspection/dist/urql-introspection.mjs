import { buildSchema as e, execute as a, parse as n, getIntrospectionQuery as r } from "graphql";

var getIntrospectedSchema = t => {
  if ("string" == typeof t) {
    try {
      t = JSON.parse(t);
    } catch (a) {
      t = e(t);
    }
  }
  if ("object" == typeof t && "__schema" in t) {
    return t;
  }
  var i = a({
    document: n(r({
      descriptions: !1
    })),
    schema: t
  });
  if (!i.data || !i.data.__schema) {
    throw new TypeError("GraphQL could not generate an IntrospectionQuery from the given schema.");
  }
  return i.data;
};

var t = !1;

var i = !1;

var s = !1;

var p = !1;

var m = {
  kind: "SCALAR",
  name: "Any"
};

var mapType = e => {
  switch (e.kind) {
   case "NON_NULL":
   case "LIST":
    return {
      kind: e.kind,
      ofType: mapType(e.ofType)
    };

   case "SCALAR":
    if (t) {
      return e;
    } else {
      p = !0;
      return m;
    }

   case "INPUT_OBJECT":
    if (s) {
      return e;
    } else {
      p = !0;
      return m;
    }

   case "ENUM":
    if (i) {
      return e;
    } else {
      p = !0;
      return m;
    }

   case "OBJECT":
   case "INTERFACE":
   case "UNION":
    return e;

   default:
    throw new TypeError(`Unrecognized type reference of type: ${e.kind}.`);
  }
};

var minifyIntrospectionType = e => {
  switch (e.kind) {
   case "SCALAR":
    return {
      kind: "SCALAR",
      name: e.name
    };

   case "ENUM":
    return {
      kind: "ENUM",
      name: e.name,
      enumValues: e.enumValues.map((e => ({
        name: e.name
      })))
    };

   case "INPUT_OBJECT":
    return {
      kind: "INPUT_OBJECT",
      name: e.name,
      inputFields: e.inputFields.map((e => ({
        name: e.name,
        type: mapType(e.type),
        defaultValue: e.defaultValue || void 0
      })))
    };

   case "OBJECT":
    return {
      kind: "OBJECT",
      name: e.name,
      fields: e.fields.map((e => ({
        name: e.name,
        type: e.type && mapType(e.type),
        args: e.args && e.args.map((e => ({
          name: e.name,
          type: mapType(e.type)
        })))
      }))),
      interfaces: e.interfaces && e.interfaces.map((e => ({
        kind: "INTERFACE",
        name: e.name
      })))
    };

   case "INTERFACE":
    return {
      kind: "INTERFACE",
      name: e.name,
      fields: e.fields.map((e => ({
        name: e.name,
        type: e.type && mapType(e.type),
        args: e.args && e.args.map((e => ({
          name: e.name,
          type: mapType(e.type)
        })))
      }))),
      interfaces: e.interfaces && e.interfaces.map((e => ({
        kind: "INTERFACE",
        name: e.name
      }))),
      possibleTypes: e.possibleTypes && e.possibleTypes.map((e => ({
        kind: e.kind,
        name: e.name
      })))
    };

   case "UNION":
    return {
      kind: "UNION",
      name: e.name,
      possibleTypes: e.possibleTypes.map((e => ({
        kind: e.kind,
        name: e.name
      })))
    };

   default:
    return e;
  }
};

var minifyIntrospectionQuery = (e, a = {}) => {
  if (!e || !("__schema" in e)) {
    throw new TypeError("Expected to receive an IntrospectionQuery.");
  }
  p = !1;
  t = !!a.includeScalars;
  i = !!a.includeEnums;
  s = !!a.includeInputs;
  var {__schema: {queryType: n, mutationType: r, subscriptionType: c, types: u, directives: d}} = e;
  var o = u.filter((e => {
    switch (e.name) {
     case "__Directive":
     case "__DirectiveLocation":
     case "__EnumValue":
     case "__InputValue":
     case "__Field":
     case "__Type":
     case "__TypeKind":
     case "__Schema":
      return !1;

     default:
      return t && "SCALAR" === e.kind || i && "ENUM" === e.kind || s && "INPUT_OBJECT" === e.kind || "OBJECT" === e.kind || "INTERFACE" === e.kind || "UNION" === e.kind;
    }
  })).map(minifyIntrospectionType);
  if (p) {
    o.push({
      kind: "SCALAR",
      name: m.name
    });
  }
  var y = [];
  if (a.includeDirectives) {
    y = (d || []).map((e => ({
      name: e.name,
      isRepeatable: e.isRepeatable ? !0 : void 0,
      locations: e.locations,
      args: e.args.map((e => ({
        name: e.name,
        type: mapType(e.type),
        defaultValue: e.defaultValue || void 0
      })))
    })));
  }
  return {
    __schema: {
      queryType: n,
      mutationType: r,
      subscriptionType: c,
      types: o,
      directives: y
    }
  };
};

export { getIntrospectedSchema, minifyIntrospectionQuery };
//# sourceMappingURL=urql-introspection.mjs.map
