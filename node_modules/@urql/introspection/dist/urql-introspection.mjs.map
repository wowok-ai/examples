{"version":3,"file":"urql-introspection.mjs","sources":["../src/getIntrospectedSchema.ts","../src/minifyIntrospectionQuery.ts"],"sourcesContent":["import type { IntrospectionQuery, GraphQLSchema } from 'graphql';\nimport { parse, buildSchema, execute, getIntrospectionQuery } from 'graphql';\n\n/** Returns an {@link IntrospectionQuery} result for a given GraphQL schema.\n *\n * @param input - A GraphQL schema, either as an SDL string, or a {@link GraphQLSchema} object.\n * @returns an {@link IntrospectionQuery} result.\n *\n * @remarks\n * `getIntrospectedSchema` can be used to get a Schema Introspection result from\n * a given GraphQL schema. The schema can be passed as an SDL string or a\n * {@link GraphQLSchema} object. If an {@link IntrospectionQuery} object is\n * passed, it'll be passed through.\n *\n * @throws\n * If `input` cannot be parsed or converted into a {@link GraphQLSchema} then\n * a {@link TypeError} will be thrown.\n */\nexport const getIntrospectedSchema = (\n  input: string | IntrospectionQuery | GraphQLSchema\n): IntrospectionQuery => {\n  if (typeof input === 'string') {\n    try {\n      input = JSON.parse(input);\n    } catch (_error) {\n      input = buildSchema(input as string);\n    }\n  }\n\n  if (typeof input === 'object' && '__schema' in input) {\n    return input;\n  }\n\n  const initialIntrospection: any = execute({\n    document: parse(getIntrospectionQuery({ descriptions: false })),\n    schema: input as GraphQLSchema,\n  });\n\n  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {\n    throw new TypeError(\n      'GraphQL could not generate an IntrospectionQuery from the given schema.'\n    );\n  }\n\n  return initialIntrospection.data as IntrospectionQuery;\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n  IntrospectionDirective,\n} from 'graphql';\n\nlet _includeScalars = false;\nlet _includeEnums = false;\nlet _includeInputs = false;\nlet _hasAnyType = false;\n\nconst anyType: IntrospectionTypeRef = {\n  kind: 'SCALAR',\n  name: 'Any',\n};\n\nconst mapType = (fromType: any): IntrospectionTypeRef => {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapType(fromType.ofType),\n      };\n\n    case 'SCALAR':\n      if (_includeScalars) {\n        return fromType;\n      } else {\n        _hasAnyType = true;\n        return anyType;\n      }\n\n    case 'INPUT_OBJECT':\n      if (_includeInputs) {\n        return fromType;\n      } else {\n        _hasAnyType = true;\n        return anyType;\n      }\n\n    case 'ENUM':\n      if (_includeEnums) {\n        return fromType;\n      } else {\n        _hasAnyType = true;\n        return anyType;\n      }\n\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return fromType;\n\n    default:\n      throw new TypeError(\n        `Unrecognized type reference of type: ${(fromType as any).kind}.`\n      );\n  }\n};\n\nconst minifyIntrospectionType = (\n  type: IntrospectionType\n): IntrospectionType => {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(\n          value =>\n            ({\n              name: value.name,\n            }) as any\n        ),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(\n          field =>\n            ({\n              name: field.name,\n              type: mapType(field.type),\n              defaultValue: field.defaultValue || undefined,\n            }) as IntrospectionInputValue\n        ),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            }) as any\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            }) as any\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n        possibleTypes:\n          type.possibleTypes &&\n          type.possibleTypes.map(type => ({\n            kind: type.kind,\n            name: type.name,\n          })),\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes.map(type => ({\n          kind: type.kind,\n          name: type.name,\n        })),\n      };\n\n    default:\n      return type;\n  }\n};\n\n/** Input parameters for the {@link minifyIntrospectionQuery} function. */\nexport interface MinifySchemaOptions {\n  /** Includes scalars instead of removing them.\n   *\n   * @remarks\n   * By default, all scalars will be replaced by a single scalar called `Any`\n   * in the output, unless this option is set to `true`.\n   */\n  includeScalars?: boolean;\n  /** Includes enums instead of removing them.\n   *\n   * @remarks\n   * By default, all enums will be replaced by a single scalar called `Any`\n   * in the output, unless this option is set to `true`.\n   */\n  includeEnums?: boolean;\n  /** Includes inputs instead of removing them.\n   *\n   * @remarks\n   * By default, all inputs will be replaced by a single scalar called `Any`\n   * in the output, unless this option is set to `true`.\n   */\n  includeInputs?: boolean;\n  /** Includes directives instead of removing them. */\n  includeDirectives?: boolean;\n}\n\n/** Minifies an {@link IntrospectionQuery} for use with Graphcache or the `populateExchange`.\n *\n * @param schema - An {@link IntrospectionQuery} object to be minified.\n * @param opts - An optional {@link MinifySchemaOptions} configuration object.\n * @returns the minified {@link IntrospectionQuery} object.\n *\n * @remarks\n * `minifyIntrospectionQuery` reduces the size of an {@link IntrospectionQuery} by\n * removing data and information that a client-side consumer, like Graphcache or the\n * `populateExchange`, may not require.\n *\n * At the very least, it will remove system types, descriptions, depreactions,\n * and source locations. Unless disabled via the options passed, it will also\n * by default remove all scalars, enums, inputs, and directives.\n *\n * @throws\n * If `schema` receives an object that isnâ€™t an {@link IntrospectionQuery}, a\n * {@link TypeError} will be thrown.\n */\nexport const minifyIntrospectionQuery = (\n  schema: IntrospectionQuery,\n  opts: MinifySchemaOptions = {}\n): IntrospectionQuery => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  _hasAnyType = false;\n  _includeScalars = !!opts.includeScalars;\n  _includeEnums = !!opts.includeEnums;\n  _includeInputs = !!opts.includeInputs;\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types, directives },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter(type => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            (_includeScalars && type.kind === 'SCALAR') ||\n            (_includeEnums && type.kind === 'ENUM') ||\n            (_includeInputs && type.kind === 'INPUT_OBJECT') ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType);\n\n  if (_hasAnyType) {\n    minifiedTypes.push({ kind: 'SCALAR', name: anyType.name });\n  }\n\n  let minifiedDirectives: IntrospectionDirective[] = [];\n  if (opts.includeDirectives) {\n    minifiedDirectives = (directives || []).map(directive => ({\n      name: directive.name,\n      isRepeatable: directive.isRepeatable ? true : undefined,\n      locations: directive.locations,\n      args: directive.args.map(\n        arg =>\n          ({\n            name: arg.name,\n            type: mapType(arg.type),\n            defaultValue: arg.defaultValue || undefined,\n          }) as IntrospectionInputValue\n      ),\n    }));\n  }\n\n  return {\n    __schema: {\n      queryType,\n      mutationType,\n      subscriptionType,\n      types: minifiedTypes,\n      directives: minifiedDirectives,\n    },\n  };\n};\n"],"names":["getIntrospectedSchema","input","JSON","parse","_error","buildSchema","initialIntrospection","execute","document","getIntrospectionQuery","descriptions","schema","data","__schema","TypeError","_includeScalars","_includeEnums","_includeInputs","_hasAnyType","anyType","kind","name","mapType","fromType","ofType","minifyIntrospectionType","type","enumValues","map","value","inputFields","field","defaultValue","undefined","fields","args","arg","interfaces","int","possibleTypes","minifyIntrospectionQuery","opts","includeScalars","includeEnums","includeInputs","queryType","mutationType","subscriptionType","types","directives","minifiedTypes","filter","push","minifiedDirectives","includeDirectives","directive","isRepeatable","locations"],"mappings":"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"}