Object.defineProperty(exports, '__esModule', { value: true });

var graphql = require('graphql');

/** Returns an {@link IntrospectionQuery} result for a given GraphQL schema.
 *
 * @param input - A GraphQL schema, either as an SDL string, or a {@link GraphQLSchema} object.
 * @returns an {@link IntrospectionQuery} result.
 *
 * @remarks
 * `getIntrospectedSchema` can be used to get a Schema Introspection result from
 * a given GraphQL schema. The schema can be passed as an SDL string or a
 * {@link GraphQLSchema} object. If an {@link IntrospectionQuery} object is
 * passed, it'll be passed through.
 *
 * @throws
 * If `input` cannot be parsed or converted into a {@link GraphQLSchema} then
 * a {@link TypeError} will be thrown.
 */
var getIntrospectedSchema = input => {
  if (typeof input === 'string') {
    try {
      input = JSON.parse(input);
    } catch (_error) {
      input = graphql.buildSchema(input);
    }
  }
  if (typeof input === 'object' && '__schema' in input) {
    return input;
  }
  var initialIntrospection = graphql.execute({
    document: graphql.parse(graphql.getIntrospectionQuery({
      descriptions: false
    })),
    schema: input
  });
  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {
    throw new TypeError('GraphQL could not generate an IntrospectionQuery from the given schema.');
  }
  return initialIntrospection.data;
};

var _includeScalars = false;
var _includeEnums = false;
var _includeInputs = false;
var _hasAnyType = false;
var anyType = {
  kind: 'SCALAR',
  name: 'Any'
};
var mapType = fromType => {
  switch (fromType.kind) {
    case 'NON_NULL':
    case 'LIST':
      return {
        kind: fromType.kind,
        ofType: mapType(fromType.ofType)
      };
    case 'SCALAR':
      if (_includeScalars) {
        return fromType;
      } else {
        _hasAnyType = true;
        return anyType;
      }
    case 'INPUT_OBJECT':
      if (_includeInputs) {
        return fromType;
      } else {
        _hasAnyType = true;
        return anyType;
      }
    case 'ENUM':
      if (_includeEnums) {
        return fromType;
      } else {
        _hasAnyType = true;
        return anyType;
      }
    case 'OBJECT':
    case 'INTERFACE':
    case 'UNION':
      return fromType;
    default:
      throw new TypeError(`Unrecognized type reference of type: ${fromType.kind}.`);
  }
};
var minifyIntrospectionType = type => {
  switch (type.kind) {
    case 'SCALAR':
      return {
        kind: 'SCALAR',
        name: type.name
      };
    case 'ENUM':
      return {
        kind: 'ENUM',
        name: type.name,
        enumValues: type.enumValues.map(value => ({
          name: value.name
        }))
      };
    case 'INPUT_OBJECT':
      {
        return {
          kind: 'INPUT_OBJECT',
          name: type.name,
          inputFields: type.inputFields.map(field => ({
            name: field.name,
            type: mapType(field.type),
            defaultValue: field.defaultValue || undefined
          }))
        };
      }
    case 'OBJECT':
      return {
        kind: 'OBJECT',
        name: type.name,
        fields: type.fields.map(field => ({
          name: field.name,
          type: field.type && mapType(field.type),
          args: field.args && field.args.map(arg => ({
            name: arg.name,
            type: mapType(arg.type)
          }))
        })),
        interfaces: type.interfaces && type.interfaces.map(int => ({
          kind: 'INTERFACE',
          name: int.name
        }))
      };
    case 'INTERFACE':
      return {
        kind: 'INTERFACE',
        name: type.name,
        fields: type.fields.map(field => ({
          name: field.name,
          type: field.type && mapType(field.type),
          args: field.args && field.args.map(arg => ({
            name: arg.name,
            type: mapType(arg.type)
          }))
        })),
        interfaces: type.interfaces && type.interfaces.map(int => ({
          kind: 'INTERFACE',
          name: int.name
        })),
        possibleTypes: type.possibleTypes && type.possibleTypes.map(type => ({
          kind: type.kind,
          name: type.name
        }))
      };
    case 'UNION':
      return {
        kind: 'UNION',
        name: type.name,
        possibleTypes: type.possibleTypes.map(type => ({
          kind: type.kind,
          name: type.name
        }))
      };
    default:
      return type;
  }
};

/** Input parameters for the {@link minifyIntrospectionQuery} function. */

/** Minifies an {@link IntrospectionQuery} for use with Graphcache or the `populateExchange`.
 *
 * @param schema - An {@link IntrospectionQuery} object to be minified.
 * @param opts - An optional {@link MinifySchemaOptions} configuration object.
 * @returns the minified {@link IntrospectionQuery} object.
 *
 * @remarks
 * `minifyIntrospectionQuery` reduces the size of an {@link IntrospectionQuery} by
 * removing data and information that a client-side consumer, like Graphcache or the
 * `populateExchange`, may not require.
 *
 * At the very least, it will remove system types, descriptions, depreactions,
 * and source locations. Unless disabled via the options passed, it will also
 * by default remove all scalars, enums, inputs, and directives.
 *
 * @throws
 * If `schema` receives an object that isnâ€™t an {@link IntrospectionQuery}, a
 * {@link TypeError} will be thrown.
 */
var minifyIntrospectionQuery = (schema, opts = {}) => {
  if (!schema || !('__schema' in schema)) {
    throw new TypeError('Expected to receive an IntrospectionQuery.');
  }
  _hasAnyType = false;
  _includeScalars = !!opts.includeScalars;
  _includeEnums = !!opts.includeEnums;
  _includeInputs = !!opts.includeInputs;
  var {
    __schema: {
      queryType,
      mutationType,
      subscriptionType,
      types,
      directives
    }
  } = schema;
  var minifiedTypes = types.filter(type => {
    switch (type.name) {
      case '__Directive':
      case '__DirectiveLocation':
      case '__EnumValue':
      case '__InputValue':
      case '__Field':
      case '__Type':
      case '__TypeKind':
      case '__Schema':
        return false;
      default:
        return _includeScalars && type.kind === 'SCALAR' || _includeEnums && type.kind === 'ENUM' || _includeInputs && type.kind === 'INPUT_OBJECT' || type.kind === 'OBJECT' || type.kind === 'INTERFACE' || type.kind === 'UNION';
    }
  }).map(minifyIntrospectionType);
  if (_hasAnyType) {
    minifiedTypes.push({
      kind: 'SCALAR',
      name: anyType.name
    });
  }
  var minifiedDirectives = [];
  if (opts.includeDirectives) {
    minifiedDirectives = (directives || []).map(directive => ({
      name: directive.name,
      isRepeatable: directive.isRepeatable ? true : undefined,
      locations: directive.locations,
      args: directive.args.map(arg => ({
        name: arg.name,
        type: mapType(arg.type),
        defaultValue: arg.defaultValue || undefined
      }))
    }));
  }
  return {
    __schema: {
      queryType,
      mutationType,
      subscriptionType,
      types: minifiedTypes,
      directives: minifiedDirectives
    }
  };
};

exports.getIntrospectedSchema = getIntrospectedSchema;
exports.minifyIntrospectionQuery = minifyIntrospectionQuery;
//# sourceMappingURL=urql-introspection.js.map
